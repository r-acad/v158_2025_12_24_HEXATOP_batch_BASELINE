"// # FILE: .\Manifest.toml";
# This file is machine-generated - editing it directly is not advised

julia_version = "1.12.3"
manifest_format = "2.0"
project_hash = "6ff019649144daf98fa29978c0629619a9b02520"

[[deps.ADTypes]]
git-tree-sha1 = "8b2b045b22740e4be20654175cc38291d48539db"
uuid = "47edcb42-4c32-4615-8424-f2b9edc5f35b"
version = "1.20.0"

    [deps.ADTypes.extensions]
    ADTypesChainRulesCoreExt = "ChainRulesCore"
    ADTypesConstructionBaseExt = "ConstructionBase"
    ADTypesEnzymeCoreExt = "EnzymeCore"

    [deps.ADTypes.weakdeps]
    ChainRulesCore = "d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4"
    ConstructionBase = "187b0558-2788-49d3-abe0-74a17ed4e7c9"
    EnzymeCore = "f151be2c-9106-41f4-ab19-57ee4f262869"

[[deps.AMGX]]
deps = ["AMGX_jll", "CEnum", "CUDA", "JSON", "Libdl", "SparseArrays"]
git-tree-sha1 = "56624f0147f7bcb40d57082e1409422cb2bf2a0f"
uuid = "c963dde9-0319-47f5-bf0c-b07d3c80ffa6"
version = "0.2.0"

[[deps.AMGX_jll]]
deps = ["Artifacts", "CUDA_Runtime_jll", "JLLWrappers", "LazyArtifacts", "Libdl", "TOML"]
git-tree-sha1 = "c7454ddf1dad790a8bfd83921d62d79eea60e50a"
uuid = "656d14af-56e4-5275-8e68-4e861d7b5043"
version = "2.4.0+0"

[[deps.AbstractFFTs]]
deps = ["LinearAlgebra"]
git-tree-sha1 = "d92ad398961a3ed262d8bf04a1a2b8340f915fef"
uuid = "621f4979-c628-5d54-868e-fcf4e3e8185c"
version = "1.5.0"

    [deps.AbstractFFTs.extensions]
    AbstractFFTsChainRulesCoreExt = "ChainRulesCore"
    AbstractFFTsTestExt = "Test"

    [deps.AbstractFFTs.weakdeps]
    ChainRulesCore = "d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4"
    Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[[deps.Accessors]]
deps = ["CompositionsBase", "ConstructionBase", "Dates", "InverseFunctions", "MacroTools"]
git-tree-sha1 = "856ecd7cebb68e5fc87abecd2326ad59f0f911f3"
uuid = "7d9f7c33-5ae7-4f3b-8dc6-eff91059b697"
version = "0.1.43"

    [deps.Accessors.extensions]
    AxisKeysExt = "AxisKeys"
    IntervalSetsExt = "IntervalSets"
    LinearAlgebraExt = "LinearAlgebra"
    StaticArraysExt = "StaticArrays"
    StructArraysExt = "StructArrays"
    TestExt = "Test"
    UnitfulExt = "Unitful"

    [deps.Accessors.weakdeps]
    AxisKeys = "94b1ba4f-4ee9-5380-92f1-94cde586c3c5"
    IntervalSets = "8197267c-284f-5f27-9208-e0e47529a953"
    LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
    StaticArrays = "90137ffa-7385-5640-81b9-e52037218182"
    StructArrays = "09ab397b-f2b6-538f-b94a-2f83cf4a842a"
    Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"
    Unitful = "1986cc42-f94f-5a68-af5c-568840ba703d"

[[deps.Adapt]]
deps = ["LinearAlgebra", "Requires"]
git-tree-sha1 = "7e35fca2bdfba44d797c53dfe63a51fabf39bfc0"
uuid = "79e6a3ab-5dfb-504d-930d-738a2a938a0e"
version = "4.4.0"
weakdeps = ["SparseArrays", "StaticArrays"]

    [deps.Adapt.extensions]
    AdaptSparseArraysExt = "SparseArrays"
    AdaptStaticArraysExt = "StaticArrays"

[[deps.AlgebraicMultigrid]]
deps = ["CommonSolve", "LinearAlgebra", "LinearSolve", "Printf", "Reexport", "SparseArrays"]
git-tree-sha1 = "5aadf2440f5fd35f32336f5c6c0fa7e8fe64459a"
uuid = "2169fc97-5a83-5252-b627-83903c6c433c"
version = "1.1.0"

[[deps.ArgParse]]
deps = ["Logging", "TextWrap"]
git-tree-sha1 = "22cf435ac22956a7b45b0168abbc871176e7eecc"
uuid = "c7e460c6-2fb9-53a9-8c5b-16f535851c63"
version = "1.2.0"

[[deps.ArgTools]]
uuid = "0dad84c5-d112-42e6-8d28-ef12dabb789f"
version = "1.1.2"

[[deps.ArrayInterface]]
deps = ["Adapt", "LinearAlgebra"]
git-tree-sha1 = "d81ae5489e13bc03567d4fbbb06c546a5e53c857"
uuid = "4fba245c-0d91-5ea0-9b3e-6abc04ee57a9"
version = "7.22.0"

    [deps.ArrayInterface.extensions]
    ArrayInterfaceBandedMatricesExt = "BandedMatrices"
    ArrayInterfaceBlockBandedMatricesExt = "BlockBandedMatrices"
    ArrayInterfaceCUDAExt = "CUDA"
    ArrayInterfaceCUDSSExt = ["CUDSS", "CUDA"]
    ArrayInterfaceChainRulesCoreExt = "ChainRulesCore"
    ArrayInterfaceChainRulesExt = "ChainRules"
    ArrayInterfaceGPUArraysCoreExt = "GPUArraysCore"
    ArrayInterfaceMetalExt = "Metal"
    ArrayInterfaceReverseDiffExt = "ReverseDiff"
    ArrayInterfaceSparseArraysExt = "SparseArrays"
    ArrayInterfaceStaticArraysCoreExt = "StaticArraysCore"
    ArrayInterfaceTrackerExt = "Tracker"

    [deps.ArrayInterface.weakdeps]
    BandedMatrices = "aae01518-5342-5314-be14-df237901396f"
    BlockBandedMatrices = "ffab5731-97b5-5995-9138-79e8c1846df0"
    CUDA = "052768ef-5323-5732-b1bb-66c8b64840ba"
    CUDSS = "45b445bb-4962-46a0-9369-b4df9d0f772e"
    ChainRules = "082447d4-558c-5d27-93f4-14fc19e9eca2"
    ChainRulesCore = "d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4"
    GPUArraysCore = "46192b85-c4d5-4398-a991-12ede77f4527"
    Metal = "dde4c033-4e86-420c-a63e-0dd931031962"
    ReverseDiff = "37e2e3b7-166d-5795-8a7a-e32c996b4267"
    SparseArrays = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"
    StaticArraysCore = "1e83bf80-4336-4d27-bf5d-d5a4f845583c"
    Tracker = "9f7883ad-71c0-57eb-9f7f-b5c9e6d3789c"

[[deps.ArrayLayouts]]
deps = ["FillArrays", "LinearAlgebra", "StaticArrays"]
git-tree-sha1 = "e0b47732a192dd59b9d079a06d04235e2f833963"
uuid = "4c555306-a7a7-4459-81d9-ec55ddd5c99a"
version = "1.12.2"
weakdeps = ["SparseArrays"]

    [deps.ArrayLayouts.extensions]
    ArrayLayoutsSparseArraysExt = "SparseArrays"

[[deps.Artifacts]]
uuid = "56f22d72-fd6d-98f1-02f0-08ddc0907c33"
version = "1.11.0"

[[deps.Atomix]]
deps = ["UnsafeAtomics"]
git-tree-sha1 = "29bb0eb6f578a587a49da16564705968667f5fa8"
uuid = "a9b6321e-bd34-4604-b9c9-b65b8de01458"
version = "1.1.2"

    [deps.Atomix.extensions]
    AtomixCUDAExt = "CUDA"
    AtomixMetalExt = "Metal"
    AtomixOpenCLExt = "OpenCL"
    AtomixoneAPIExt = "oneAPI"

    [deps.Atomix.weakdeps]
    CUDA = "052768ef-5323-5732-b1bb-66c8b64840ba"
    Metal = "dde4c033-4e86-420c-a63e-0dd931031962"
    OpenCL = "08131aa3-fb12-5dee-8b74-c09406e224a2"
    oneAPI = "8f75cd03-7ff8-4ecb-9b8f-daf728133b1b"

[[deps.BFloat16s]]
deps = ["LinearAlgebra", "Printf", "Random"]
git-tree-sha1 = "0a6d6d072cb5f2baeba7667023075801f6ea4a7d"
uuid = "ab4f0b2a-ad5b-11e8-123f-65d77653426b"
version = "0.6.0"

[[deps.Base64]]
uuid = "2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"
version = "1.11.0"

[[deps.CEnum]]
git-tree-sha1 = "389ad5c84de1ae7cf0e28e381131c98ea87d54fc"
uuid = "fa961155-64e5-5f13-b03f-caf6b980ea82"
version = "0.5.0"

[[deps.CUDA]]
deps = ["AbstractFFTs", "Adapt", "BFloat16s", "CEnum", "CUDA_Compiler_jll", "CUDA_Driver_jll", "CUDA_Runtime_Discovery", "CUDA_Runtime_jll", "Crayons", "DataFrames", "ExprTools", "GPUArrays", "GPUCompiler", "GPUToolbox", "KernelAbstractions", "LLVM", "LLVMLoopInfo", "LazyArtifacts", "Libdl", "LinearAlgebra", "Logging", "NVTX", "Preferences", "PrettyTables", "Printf", "Random", "Random123", "RandomNumbers", "Reexport", "Requires", "SparseArrays", "StaticArrays", "Statistics", "demumble_jll"]
git-tree-sha1 = "27d1cd229e3e1d5542352a63ad29268439f79fe9"
uuid = "052768ef-5323-5732-b1bb-66c8b64840ba"
version = "5.9.5"

    [deps.CUDA.extensions]
    ChainRulesCoreExt = "ChainRulesCore"
    EnzymeCoreExt = "EnzymeCore"
    SparseMatricesCSRExt = "SparseMatricesCSR"
    SpecialFunctionsExt = "SpecialFunctions"

    [deps.CUDA.weakdeps]
    ChainRulesCore = "d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4"
    EnzymeCore = "f151be2c-9106-41f4-ab19-57ee4f262869"
    SparseMatricesCSR = "a0a7dd2c-ebf4-11e9-1f05-cf50bc540ca1"
    SpecialFunctions = "276daf66-3868-5448-9aa4-cd146d93841b"

[[deps.CUDA_Compiler_jll]]
deps = ["Artifacts", "CUDA_Driver_jll", "CUDA_Runtime_jll", "JLLWrappers", "LazyArtifacts", "Libdl", "TOML"]
git-tree-sha1 = "147c18cdffe34911a3ed1be32028e324f0e89427"
uuid = "d1e2174e-dfdc-576e-b43e-73b79eb1aca8"
version = "0.3.0+1"

[[deps.CUDA_Driver_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl", "Pkg"]
git-tree-sha1 = "63b4911c80ade9de10ec4b766e99cb1a628f465f"
uuid = "4ee394cb-3365-5eb0-8335-949819d2adfc"
version = "13.1.0+0"

[[deps.CUDA_Runtime_Discovery]]
deps = ["Libdl"]
git-tree-sha1 = "f9a521f52d236fe49f1028d69e549e7f2644bb72"
uuid = "1af6417a-86b4-443c-805f-a4643ffb695f"
version = "1.0.0"

[[deps.CUDA_Runtime_jll]]
deps = ["Artifacts", "CUDA_Driver_jll", "JLLWrappers", "LazyArtifacts", "Libdl", "TOML"]
git-tree-sha1 = "92cd84e2b760e471d647153ea5efc5789fc5e8b2"
uuid = "76a88914-d11a-5bdc-97e0-2f5a05c973a2"
version = "0.19.2+0"

[[deps.ChainRulesCore]]
deps = ["Compat", "LinearAlgebra"]
git-tree-sha1 = "e4c6a16e77171a5f5e25e9646617ab1c276c5607"
uuid = "d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4"
version = "1.26.0"
weakdeps = ["SparseArrays"]

    [deps.ChainRulesCore.extensions]
    ChainRulesCoreSparseArraysExt = "SparseArrays"

[[deps.ColorTypes]]
deps = ["FixedPointNumbers", "Random"]
git-tree-sha1 = "67e11ee83a43eb71ddc950302c53bf33f0690dfe"
uuid = "3da002f7-5984-5a60-b8a6-cbb66c0b333f"
version = "0.12.1"
weakdeps = ["StyledStrings"]

    [deps.ColorTypes.extensions]
    StyledStringsExt = "StyledStrings"

[[deps.Colors]]
deps = ["ColorTypes", "FixedPointNumbers", "Reexport"]
git-tree-sha1 = "37ea44092930b1811e666c3bc38065d7d87fcc74"
uuid = "5ae59095-9a9b-59fe-a467-6f913c188581"
version = "0.13.1"

[[deps.CommonSolve]]
git-tree-sha1 = "0eee5eb66b1cf62cd6ad1b460238e60e4b09400c"
uuid = "38540f10-b2f7-11e9-35d8-d573e4eb0ff2"
version = "0.2.4"

[[deps.Compat]]
deps = ["TOML", "UUIDs"]
git-tree-sha1 = "9d8a54ce4b17aa5bdce0ea5c34bc5e7c340d16ad"
uuid = "34da2185-b29b-5c13-b0c7-acf172513d20"
version = "4.18.1"
weakdeps = ["Dates", "LinearAlgebra"]

    [deps.Compat.extensions]
    CompatLinearAlgebraExt = "LinearAlgebra"

[[deps.CompilerSupportLibraries_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "e66e0078-7015-5450-92f7-15fbd957f2ae"
version = "1.3.0+1"

[[deps.CompositionsBase]]
git-tree-sha1 = "802bb88cd69dfd1509f6670416bd4434015693ad"
uuid = "a33af91c-f02d-484b-be07-31d278c5ca2b"
version = "0.1.2"
weakdeps = ["InverseFunctions"]

    [deps.CompositionsBase.extensions]
    CompositionsBaseInverseFunctionsExt = "InverseFunctions"

[[deps.ConcreteStructs]]
git-tree-sha1 = "f749037478283d372048690eb3b5f92a79432b34"
uuid = "2569d6c7-a4a2-43d3-a901-331e8e4be471"
version = "0.2.3"

[[deps.ConstructionBase]]
git-tree-sha1 = "b4b092499347b18a015186eae3042f72267106cb"
uuid = "187b0558-2788-49d3-abe0-74a17ed4e7c9"
version = "1.6.0"

    [deps.ConstructionBase.extensions]
    ConstructionBaseIntervalSetsExt = "IntervalSets"
    ConstructionBaseLinearAlgebraExt = "LinearAlgebra"
    ConstructionBaseStaticArraysExt = "StaticArrays"

    [deps.ConstructionBase.weakdeps]
    IntervalSets = "8197267c-284f-5f27-9208-e0e47529a953"
    LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
    StaticArrays = "90137ffa-7385-5640-81b9-e52037218182"

[[deps.Crayons]]
git-tree-sha1 = "249fe38abf76d48563e2f4556bebd215aa317e15"
uuid = "a8cc5b0e-0ffa-5ad4-8c14-923d3ee1735f"
version = "4.1.1"

[[deps.DataAPI]]
git-tree-sha1 = "abe83f3a2f1b857aac70ef8b269080af17764bbe"
uuid = "9a962f9c-6df0-11e9-0e5d-c546b8b5ee8a"
version = "1.16.0"

[[deps.DataFrames]]
deps = ["Compat", "DataAPI", "DataStructures", "Future", "InlineStrings", "InvertedIndices", "IteratorInterfaceExtensions", "LinearAlgebra", "Markdown", "Missings", "PooledArrays", "PrecompileTools", "PrettyTables", "Printf", "Random", "Reexport", "SentinelArrays", "SortingAlgorithms", "Statistics", "TableTraits", "Tables", "Unicode"]
git-tree-sha1 = "d8928e9169ff76c6281f39a659f9bca3a573f24c"
uuid = "a93c6f00-e57d-5684-b7b6-d8193f3e46c0"
version = "1.8.1"

[[deps.DataStructures]]
deps = ["OrderedCollections"]
git-tree-sha1 = "e357641bb3e0638d353c4b29ea0e40ea644066a6"
uuid = "864edb3b-99cc-5e75-8d2d-829cb0a9cfe8"
version = "0.19.3"

[[deps.DataValueInterfaces]]
git-tree-sha1 = "bfc1187b79289637fa0ef6d4436ebdfe6905cbd6"
uuid = "e2d170a0-9d28-54be-80f0-106bbe20a464"
version = "1.0.0"

[[deps.Dates]]
deps = ["Printf"]
uuid = "ade2ca70-3891-5945-98fb-dc099432e06a"
version = "1.11.0"

[[deps.Distributed]]
deps = ["Random", "Serialization", "Sockets"]
uuid = "8ba89e20-285c-5b6f-9357-94700520ee1b"
version = "1.11.0"

[[deps.DocStringExtensions]]
git-tree-sha1 = "7442a5dfe1ebb773c29cc2962a8980f47221d76c"
uuid = "ffbed154-4ef7-542d-bbb7-c09d3a79fcae"
version = "0.9.5"

[[deps.Downloads]]
deps = ["ArgTools", "FileWatching", "LibCURL", "NetworkOptions"]
uuid = "f43a241f-c20a-4ad4-852c-f6b1247861c6"
version = "1.7.0"

[[deps.EarCut_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl", "Pkg"]
git-tree-sha1 = "e3290f2d49e661fbd94046d7e3726ffcb2d41053"
uuid = "5ae413db-bbd1-5e63-b57d-d24a61df00f5"
version = "2.2.4+0"

[[deps.EnumX]]
git-tree-sha1 = "bddad79635af6aec424f53ed8aad5d7555dc6f00"
uuid = "4e289a0a-7415-4d19-859d-a7e5c4648b56"
version = "1.0.5"

[[deps.ExprTools]]
git-tree-sha1 = "27415f162e6028e81c72b82ef756bf321213b6ec"
uuid = "e2ba6199-217a-4e67-a87a-7c52f15ade04"
version = "0.1.10"

[[deps.ExproniconLite]]
git-tree-sha1 = "c13f0b150373771b0fdc1713c97860f8df12e6c2"
uuid = "55351af7-c7e9-48d6-89ff-24e801d99491"
version = "0.10.14"

[[deps.Extents]]
git-tree-sha1 = "b309b36a9e02fe7be71270dd8c0fd873625332b4"
uuid = "411431e0-e8b7-467b-b5e0-f676ba4f2910"
version = "0.1.6"

[[deps.FastClosures]]
git-tree-sha1 = "acebe244d53ee1b461970f8910c235b259e772ef"
uuid = "9aa1b823-49e4-5ca5-8b0f-3971ec8bab6a"
version = "0.3.2"

[[deps.FilePathsBase]]
deps = ["Compat", "Dates"]
git-tree-sha1 = "3bab2c5aa25e7840a4b065805c0cdfc01f3068d2"
uuid = "48062228-2e41-5def-b9a4-89aafe57970f"
version = "0.9.24"

    [deps.FilePathsBase.extensions]
    FilePathsBaseMmapExt = "Mmap"
    FilePathsBaseTestExt = "Test"

    [deps.FilePathsBase.weakdeps]
    Mmap = "a63ad114-7e13-5084-954f-fe012c677804"
    Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[[deps.FileWatching]]
uuid = "7b1f6079-737a-58dc-b8bc-7a2ca5c1b5ee"
version = "1.11.0"

[[deps.FillArrays]]
deps = ["LinearAlgebra"]
git-tree-sha1 = "5bfcd42851cf2f1b303f51525a54dc5e98d408a3"
uuid = "1a297f60-69ca-5386-bcde-b61e274b549b"
version = "1.15.0"

    [deps.FillArrays.extensions]
    FillArraysPDMatsExt = "PDMats"
    FillArraysSparseArraysExt = "SparseArrays"
    FillArraysStatisticsExt = "Statistics"

    [deps.FillArrays.weakdeps]
    PDMats = "90014a1f-27ba-587c-ab20-58faa44d9150"
    SparseArrays = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"
    Statistics = "10745b16-79ce-11e8-11f9-7d13ad32a3b2"

[[deps.FixedPointNumbers]]
deps = ["Statistics"]
git-tree-sha1 = "05882d6995ae5c12bb5f36dd2ed3f61c98cbb172"
uuid = "53c48c17-4a7d-5ca2-90c5-79b7896eea93"
version = "0.8.5"

[[deps.FunctionWrappers]]
git-tree-sha1 = "d62485945ce5ae9c0c48f124a84998d755bae00e"
uuid = "069b7b12-0de2-55c6-9aab-29f3d0a68a2e"
version = "1.1.3"

[[deps.FunctionWrappersWrappers]]
deps = ["FunctionWrappers"]
git-tree-sha1 = "b104d487b34566608f8b4e1c39fb0b10aa279ff8"
uuid = "77dc65aa-8811-40c2-897b-53d922fa7daf"
version = "0.1.3"

[[deps.Future]]
deps = ["Random"]
uuid = "9fa8497b-333b-5362-9e8d-4d0656e87820"
version = "1.11.0"

[[deps.GPUArrays]]
deps = ["Adapt", "GPUArraysCore", "KernelAbstractions", "LLVM", "LinearAlgebra", "Printf", "Random", "Reexport", "ScopedValues", "Serialization", "SparseArrays", "Statistics"]
git-tree-sha1 = "d6ee21b67347871a78da57c4a77318caa5e75a05"
uuid = "0c68f7d7-f131-5f86-a1c3-88cf8149b2d7"
version = "11.3.2"

    [deps.GPUArrays.extensions]
    JLD2Ext = "JLD2"

    [deps.GPUArrays.weakdeps]
    JLD2 = "033835bb-8acc-5ee8-8aae-3f567f8a3819"

[[deps.GPUArraysCore]]
deps = ["Adapt"]
git-tree-sha1 = "83cf05ab16a73219e5f6bd1bdfa9848fa24ac627"
uuid = "46192b85-c4d5-4398-a991-12ede77f4527"
version = "0.2.0"

[[deps.GPUCompiler]]
deps = ["ExprTools", "InteractiveUtils", "LLVM", "Libdl", "Logging", "PrecompileTools", "Preferences", "Scratch", "Serialization", "TOML", "Tracy", "UUIDs"]
git-tree-sha1 = "6e5a25bc455da8e8d88b6b7377e341e9af1929f0"
uuid = "61eb1bfa-7361-4325-ad38-22787b887f55"
version = "1.7.5"

[[deps.GPUToolbox]]
deps = ["LLVM"]
git-tree-sha1 = "9e9186b09a13b7f094f87d1a9bb266d8780e1b1c"
uuid = "096a3bc2-3ced-46d0-87f4-dd12716f4bfc"
version = "1.0.0"

[[deps.GeometryBasics]]
deps = ["EarCut_jll", "Extents", "IterTools", "LinearAlgebra", "PrecompileTools", "Random", "StaticArrays"]
git-tree-sha1 = "1f5a80f4ed9f5a4aada88fc2db456e637676414b"
uuid = "5c1252a2-5f33-56bf-86c9-59e7332b4326"
version = "0.5.10"

    [deps.GeometryBasics.extensions]
    GeometryBasicsGeoInterfaceExt = "GeoInterface"

    [deps.GeometryBasics.weakdeps]
    GeoInterface = "cf35fbd7-0cd7-5166-be24-54bfbe79505f"

[[deps.HEXA_TopOpt]]
deps = ["AMGX", "AlgebraicMultigrid", "ArgParse", "CUDA", "Dates", "FilePathsBase", "JSON", "JSON3", "Krylov", "LinearAlgebra", "LinearOperators", "MarchingCubes", "Printf", "SparseArrays", "Statistics", "SuiteSparse", "YAML"]
path = "."
uuid = "ca0ed32d-1ad4-4b7a-9919-fa42dfec13a8"
version = "1.0.0"

[[deps.HashArrayMappedTries]]
git-tree-sha1 = "2eaa69a7cab70a52b9687c8bf950a5a93ec895ae"
uuid = "076d061b-32b6-4027-95e0-9a2c6f6d7e74"
version = "0.2.0"

[[deps.InlineStrings]]
git-tree-sha1 = "8f3d257792a522b4601c24a577954b0a8cd7334d"
uuid = "842dd82b-1e85-43dc-bf29-5d0ee9dffc48"
version = "1.4.5"

    [deps.InlineStrings.extensions]
    ArrowTypesExt = "ArrowTypes"
    ParsersExt = "Parsers"

    [deps.InlineStrings.weakdeps]
    ArrowTypes = "31f734f8-188a-4ce0-8406-c8a06bd891cd"
    Parsers = "69de0a69-1ddd-5017-9359-2bf0b02dc9f0"

[[deps.IntelOpenMP_jll]]
deps = ["Artifacts", "JLLWrappers", "LazyArtifacts", "Libdl"]
git-tree-sha1 = "ec1debd61c300961f98064cfb21287613ad7f303"
uuid = "1d5cc7b8-4909-519e-a0f8-d0f5ad9712d0"
version = "2025.2.0+0"

[[deps.InteractiveUtils]]
deps = ["Markdown"]
uuid = "b77e0a4c-d291-57a0-90e8-8db25a27a240"
version = "1.11.0"

[[deps.InverseFunctions]]
git-tree-sha1 = "a779299d77cd080bf77b97535acecd73e1c5e5cb"
uuid = "3587e190-3f89-42d0-90ee-14403ec27112"
version = "0.1.17"

    [deps.InverseFunctions.extensions]
    InverseFunctionsDatesExt = "Dates"
    InverseFunctionsTestExt = "Test"

    [deps.InverseFunctions.weakdeps]
    Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"
    Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[[deps.InvertedIndices]]
git-tree-sha1 = "6da3c4316095de0f5ee2ebd875df8721e7e0bdbe"
uuid = "41ab1584-1d38-5bbf-9106-f11c6c58b48f"
version = "1.3.1"

[[deps.IterTools]]
git-tree-sha1 = "42d5f897009e7ff2cf88db414a389e5ed1bdd023"
uuid = "c8e1da08-722c-5040-9ed9-7db0dc04731e"
version = "1.10.0"

[[deps.IteratorInterfaceExtensions]]
git-tree-sha1 = "a3f24677c21f5bbe9d2a714f95dcd58337fb2856"
uuid = "82899510-4779-5014-852e-03e436cf321d"
version = "1.0.0"

[[deps.JLLWrappers]]
deps = ["Artifacts", "Preferences"]
git-tree-sha1 = "0533e564aae234aff59ab625543145446d8b6ec2"
uuid = "692b3bcd-3c85-4b1f-b108-f13ce0eb3210"
version = "1.7.1"

[[deps.JSON]]
deps = ["Dates", "Mmap", "Parsers", "Unicode"]
git-tree-sha1 = "31e996f0a15c7b280ba9f76636b3ff9e2ae58c9a"
uuid = "682c06a0-de6a-54ab-a142-c8b1cf79cde6"
version = "0.21.4"

[[deps.JSON3]]
deps = ["Dates", "Mmap", "Parsers", "PrecompileTools", "StructTypes", "UUIDs"]
git-tree-sha1 = "411eccfe8aba0814ffa0fdf4860913ed09c34975"
uuid = "0f8b85d8-7281-11e9-16c2-39a750bddbf1"
version = "1.14.3"

    [deps.JSON3.extensions]
    JSON3ArrowExt = ["ArrowTypes"]

    [deps.JSON3.weakdeps]
    ArrowTypes = "31f734f8-188a-4ce0-8406-c8a06bd891cd"

[[deps.Jieko]]
deps = ["ExproniconLite"]
git-tree-sha1 = "2f05ed29618da60c06a87e9c033982d4f71d0b6c"
uuid = "ae98c720-c025-4a4a-838c-29b094483192"
version = "0.2.1"

[[deps.JuliaNVTXCallbacks_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl", "Pkg"]
git-tree-sha1 = "af433a10f3942e882d3c671aacb203e006a5808f"
uuid = "9c1d0b0a-7046-5b2e-a33f-ea22f176ac7e"
version = "0.2.1+0"

[[deps.JuliaSyntaxHighlighting]]
deps = ["StyledStrings"]
uuid = "ac6e5ff7-fb65-4e79-a425-ec3bc9c03011"
version = "1.12.0"

[[deps.KernelAbstractions]]
deps = ["Adapt", "Atomix", "InteractiveUtils", "MacroTools", "PrecompileTools", "Requires", "StaticArrays", "UUIDs"]
git-tree-sha1 = "b5a371fcd1d989d844a4354127365611ae1e305f"
uuid = "63c18a36-062a-441e-b654-da1e3ab1ce7c"
version = "0.9.39"

    [deps.KernelAbstractions.extensions]
    EnzymeExt = "EnzymeCore"
    LinearAlgebraExt = "LinearAlgebra"
    SparseArraysExt = "SparseArrays"

    [deps.KernelAbstractions.weakdeps]
    EnzymeCore = "f151be2c-9106-41f4-ab19-57ee4f262869"
    LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
    SparseArrays = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"

[[deps.Krylov]]
deps = ["LinearAlgebra", "Printf", "SparseArrays"]
git-tree-sha1 = "09895a8e17b0aa97df8964ed13c94d1b6d9de666"
uuid = "ba0b0d4f-ebba-5204-a429-3ac8c609bfb7"
version = "0.10.3"

[[deps.LLVM]]
deps = ["CEnum", "LLVMExtra_jll", "Libdl", "Preferences", "Printf", "Unicode"]
git-tree-sha1 = "ce8614210409eaa54ed5968f4b50aa96da7ae543"
uuid = "929cbde3-209d-540e-8aea-75f648917ca0"
version = "9.4.4"
weakdeps = ["BFloat16s"]

    [deps.LLVM.extensions]
    BFloat16sExt = "BFloat16s"

[[deps.LLVMExtra_jll]]
deps = ["Artifacts", "JLLWrappers", "LazyArtifacts", "Libdl", "TOML"]
git-tree-sha1 = "8e76807afb59ebb833e9b131ebf1a8c006510f33"
uuid = "dad2f222-ce93-54a1-a47d-0025e8a3acab"
version = "0.0.38+0"

[[deps.LLVMLoopInfo]]
git-tree-sha1 = "2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea"
uuid = "8b046642-f1f6-4319-8d3c-209ddc03c586"
version = "1.0.0"

[[deps.LaTeXStrings]]
git-tree-sha1 = "dda21b8cbd6a6c40d9d02a73230f9d70fed6918c"
uuid = "b964fa9f-0449-5b57-a5c2-d3ea65f4040f"
version = "1.4.0"

[[deps.LazyArrays]]
deps = ["ArrayLayouts", "FillArrays", "LinearAlgebra", "MacroTools", "SparseArrays"]
git-tree-sha1 = "70ebe3bcf87d6a1e7435ef5182c13a91161ba9b8"
uuid = "5078a376-72f3-5289-bfd5-ec5146d43c02"
version = "2.9.4"

    [deps.LazyArrays.extensions]
    LazyArraysBandedMatricesExt = "BandedMatrices"
    LazyArraysBlockArraysExt = "BlockArrays"
    LazyArraysBlockBandedMatricesExt = "BlockBandedMatrices"
    LazyArraysStaticArraysExt = "StaticArrays"

    [deps.LazyArrays.weakdeps]
    BandedMatrices = "aae01518-5342-5314-be14-df237901396f"
    BlockArrays = "8e7c35d0-a365-5155-bbbb-fb81a777f24e"
    BlockBandedMatrices = "ffab5731-97b5-5995-9138-79e8c1846df0"
    StaticArrays = "90137ffa-7385-5640-81b9-e52037218182"

[[deps.LazyArtifacts]]
deps = ["Artifacts", "Pkg"]
uuid = "4af54fe1-eca0-43a8-85a7-787d91b784e3"
version = "1.11.0"

[[deps.LibCURL]]
deps = ["LibCURL_jll", "MozillaCACerts_jll"]
uuid = "b27032c2-a3e7-50c8-80cd-2d36dbcbfd21"
version = "0.6.4"

[[deps.LibCURL_jll]]
deps = ["Artifacts", "LibSSH2_jll", "Libdl", "OpenSSL_jll", "Zlib_jll", "nghttp2_jll"]
uuid = "deac9b47-8bc7-5906-a0fe-35ac56dc84c0"
version = "8.15.0+0"

[[deps.LibGit2]]
deps = ["LibGit2_jll", "NetworkOptions", "Printf", "SHA"]
uuid = "76f85450-5226-5b5a-8eaa-529ad045b433"
version = "1.11.0"

[[deps.LibGit2_jll]]
deps = ["Artifacts", "LibSSH2_jll", "Libdl", "OpenSSL_jll"]
uuid = "e37daf67-58a4-590a-8e99-b0245dd2ffc5"
version = "1.9.0+0"

[[deps.LibSSH2_jll]]
deps = ["Artifacts", "Libdl", "OpenSSL_jll"]
uuid = "29816b5a-b9ab-546f-933c-edad1886dfa8"
version = "1.11.3+1"

[[deps.LibTracyClient_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl"]
git-tree-sha1 = "d2bc4e1034b2d43076b50f0e34ea094c2cb0a717"
uuid = "ad6e5548-8b26-5c9f-8ef3-ef0ad883f3a5"
version = "0.9.1+6"

[[deps.Libdl]]
uuid = "8f399da3-3557-5675-b5ff-fb832c97cbdb"
version = "1.11.0"

[[deps.Libiconv_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl"]
git-tree-sha1 = "be484f5c92fad0bd8acfef35fe017900b0b73809"
uuid = "94ce4f54-9a6c-5748-9c1c-f9c7231a4531"
version = "1.18.0+0"

[[deps.LinearAlgebra]]
deps = ["Libdl", "OpenBLAS_jll", "libblastrampoline_jll"]
uuid = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
version = "1.12.0"

[[deps.LinearOperators]]
deps = ["FastClosures", "LinearAlgebra", "Printf", "Requires", "SparseArrays", "TimerOutputs"]
git-tree-sha1 = "db137007d2c4ed948aa5f2518a2b451851ea8bda"
uuid = "5c8ed15e-5a4c-59e4-a42b-c7e8811fb125"
version = "2.11.0"

    [deps.LinearOperators.extensions]
    LinearOperatorsAMDGPUExt = "AMDGPU"
    LinearOperatorsCUDAExt = "CUDA"
    LinearOperatorsChainRulesCoreExt = "ChainRulesCore"
    LinearOperatorsJLArraysExt = "JLArrays"
    LinearOperatorsLDLFactorizationsExt = "LDLFactorizations"
    LinearOperatorsMetalExt = "Metal"

    [deps.LinearOperators.weakdeps]
    AMDGPU = "21141c5a-9bdb-4563-92ae-f87d6854732e"
    CUDA = "052768ef-5323-5732-b1bb-66c8b64840ba"
    ChainRulesCore = "d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4"
    JLArrays = "27aeb0d3-9eb9-45fb-866b-73c2ecf80fcb"
    LDLFactorizations = "40e66cde-538c-5869-a4ad-c39174c6795b"
    Metal = "dde4c033-4e86-420c-a63e-0dd931031962"

[[deps.LinearSolve]]
deps = ["ArrayInterface", "ChainRulesCore", "ConcreteStructs", "DocStringExtensions", "EnumX", "GPUArraysCore", "InteractiveUtils", "Krylov", "LazyArrays", "Libdl", "LinearAlgebra", "MKL_jll", "Markdown", "OpenBLAS_jll", "PrecompileTools", "Preferences", "RecursiveArrayTools", "Reexport", "SciMLBase", "SciMLLogging", "SciMLOperators", "Setfield", "StaticArraysCore"]
git-tree-sha1 = "fe25df690740529dfc5f007aa68696e038f36c55"
uuid = "7ed4a6bd-45f5-4d41-b270-4a48e9bafcae"
version = "3.54.0"

    [deps.LinearSolve.extensions]
    LinearSolveAMDGPUExt = "AMDGPU"
    LinearSolveBLISExt = ["blis_jll", "LAPACK_jll"]
    LinearSolveBandedMatricesExt = "BandedMatrices"
    LinearSolveBlockDiagonalsExt = "BlockDiagonals"
    LinearSolveCUDAExt = "CUDA"
    LinearSolveCUDSSExt = "CUDSS"
    LinearSolveCUSOLVERRFExt = ["CUSOLVERRF", "SparseArrays"]
    LinearSolveCliqueTreesExt = ["CliqueTrees", "SparseArrays"]
    LinearSolveEnzymeExt = "EnzymeCore"
    LinearSolveFastAlmostBandedMatricesExt = "FastAlmostBandedMatrices"
    LinearSolveFastLapackInterfaceExt = "FastLapackInterface"
    LinearSolveForwardDiffExt = "ForwardDiff"
    LinearSolveHYPREExt = "HYPRE"
    LinearSolveIterativeSolversExt = "IterativeSolvers"
    LinearSolveKernelAbstractionsExt = "KernelAbstractions"
    LinearSolveKrylovKitExt = "KrylovKit"
    LinearSolveMetalExt = "Metal"
    LinearSolveMooncakeExt = "Mooncake"
    LinearSolvePardisoExt = ["Pardiso", "SparseArrays"]
    LinearSolveRecursiveFactorizationExt = "RecursiveFactorization"
    LinearSolveSparseArraysExt = "SparseArrays"
    LinearSolveSparspakExt = ["SparseArrays", "Sparspak"]

    [deps.LinearSolve.weakdeps]
    AMDGPU = "21141c5a-9bdb-4563-92ae-f87d6854732e"
    BandedMatrices = "aae01518-5342-5314-be14-df237901396f"
    BlockDiagonals = "0a1fb500-61f7-11e9-3c65-f5ef3456f9f0"
    CUDA = "052768ef-5323-5732-b1bb-66c8b64840ba"
    CUDSS = "45b445bb-4962-46a0-9369-b4df9d0f772e"
    CUSOLVERRF = "a8cc9031-bad2-4722-94f5-40deabb4245c"
    CliqueTrees = "60701a23-6482-424a-84db-faee86b9b1f8"
    EnzymeCore = "f151be2c-9106-41f4-ab19-57ee4f262869"
    FastAlmostBandedMatrices = "9d29842c-ecb8-4973-b1e9-a27b1157504e"
    FastLapackInterface = "29a986be-02c6-4525-aec4-84b980013641"
    ForwardDiff = "f6369f11-7733-5829-9624-2563aa707210"
    HYPRE = "b5ffcf37-a2bd-41ab-a3da-4bd9bc8ad771"
    IterativeSolvers = "42fd0dbc-a981-5370-80f2-aaf504508153"
    KernelAbstractions = "63c18a36-062a-441e-b654-da1e3ab1ce7c"
    KrylovKit = "0b1a1467-8014-51b9-945f-bf0ae24f4b77"
    LAPACK_jll = "51474c39-65e3-53ba-86ba-03b1b862ec14"
    Metal = "dde4c033-4e86-420c-a63e-0dd931031962"
    Mooncake = "da2b9cff-9c12-43a0-ae48-6db2b0edb7d6"
    Pardiso = "46dd5b70-b6fb-5a00-ae2d-e8fea33afaf2"
    RecursiveFactorization = "f2c3362d-daeb-58d1-803e-2bc74f2840b4"
    SparseArrays = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"
    Sparspak = "e56a9233-b9d6-4f03-8d0f-1825330902ac"
    blis_jll = "6136c539-28a5-5bf0-87cc-b183200dce32"

[[deps.Logging]]
uuid = "56ddb016-857b-54e1-b83d-db4d58db5568"
version = "1.11.0"

[[deps.LoggingExtras]]
deps = ["Dates", "Logging"]
git-tree-sha1 = "f00544d95982ea270145636c181ceda21c4e2575"
uuid = "e6f89c97-d47a-5376-807f-9c37f3926c36"
version = "1.2.0"

[[deps.MKL_jll]]
deps = ["Artifacts", "IntelOpenMP_jll", "JLLWrappers", "LazyArtifacts", "Libdl", "oneTBB_jll"]
git-tree-sha1 = "282cadc186e7b2ae0eeadbd7a4dffed4196ae2aa"
uuid = "856f044c-d86e-5d09-b602-aeab76dc8ba7"
version = "2025.2.0+0"

[[deps.MacroTools]]
git-tree-sha1 = "1e0228a030642014fe5cfe68c2c0a818f9e3f522"
uuid = "1914dd2f-81c6-5fcd-8719-6d5c9610ff09"
version = "0.5.16"

[[deps.MarchingCubes]]
deps = ["PrecompileTools", "StaticArrays"]
git-tree-sha1 = "0e893025924b6becbae4109f8020ac0e12674b01"
uuid = "299715c1-40a9-479a-aaf9-4a633d36f717"
version = "0.1.11"

[[deps.Markdown]]
deps = ["Base64", "JuliaSyntaxHighlighting", "StyledStrings"]
uuid = "d6f4376e-aef5-505a-96c1-9c027394607a"
version = "1.11.0"

[[deps.Meshing]]
git-tree-sha1 = "5705d4f32545f7bcecdff75759a20d17812e5caf"
uuid = "e6723b4c-ebff-59f1-b4b7-d97aa5274f73"
version = "0.7.0"

[[deps.Missings]]
deps = ["DataAPI"]
git-tree-sha1 = "ec4f7fbeab05d7747bdf98eb74d130a2a2ed298d"
uuid = "e1d29d7a-bbdc-5cf2-9ac0-f12de2c33e28"
version = "1.2.0"

[[deps.Mmap]]
uuid = "a63ad114-7e13-5084-954f-fe012c677804"
version = "1.11.0"

[[deps.Moshi]]
deps = ["ExproniconLite", "Jieko"]
git-tree-sha1 = "53f817d3e84537d84545e0ad749e483412dd6b2a"
uuid = "2e0e35c7-a2e4-4343-998d-7ef72827ed2d"
version = "0.3.7"

[[deps.MozillaCACerts_jll]]
uuid = "14a3606d-f60d-562e-9121-12d972cd8159"
version = "2025.5.20"

[[deps.NVTX]]
deps = ["Colors", "JuliaNVTXCallbacks_jll", "Libdl", "NVTX_jll"]
git-tree-sha1 = "6b573a3e66decc7fc747afd1edbf083ff78c813a"
uuid = "5da4648a-3479-48b8-97b9-01cb529c0a1f"
version = "1.0.1"

[[deps.NVTX_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl"]
git-tree-sha1 = "af2232f69447494514c25742ba1503ec7e9877fe"
uuid = "e98f9f5b-d649-5603-91fd-7774390e6439"
version = "3.2.2+0"

[[deps.NetworkOptions]]
uuid = "ca575930-c2e3-43a9-ace4-1e988b2c1908"
version = "1.3.0"

[[deps.OpenBLAS_jll]]
deps = ["Artifacts", "CompilerSupportLibraries_jll", "Libdl"]
uuid = "4536629a-c528-5b80-bd46-f80d51c5b363"
version = "0.3.29+0"

[[deps.OpenSSL_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "458c3c95-2e84-50aa-8efc-19380b2a3a95"
version = "3.5.4+0"

[[deps.OrderedCollections]]
git-tree-sha1 = "05868e21324cede2207c6f0f466b4bfef6d5e7ee"
uuid = "bac558e1-5e72-5ebc-8fee-abe8a469f55d"
version = "1.8.1"

[[deps.Parsers]]
deps = ["Dates", "PrecompileTools", "UUIDs"]
git-tree-sha1 = "7d2f8f21da5db6a806faf7b9b292296da42b2810"
uuid = "69de0a69-1ddd-5017-9359-2bf0b02dc9f0"
version = "2.8.3"

[[deps.Pkg]]
deps = ["Artifacts", "Dates", "Downloads", "FileWatching", "LibGit2", "Libdl", "Logging", "Markdown", "Printf", "Random", "SHA", "TOML", "Tar", "UUIDs", "p7zip_jll"]
uuid = "44cfe95a-1eb2-52ea-b672-e2afdf69b78f"
version = "1.12.1"
weakdeps = ["REPL"]

    [deps.Pkg.extensions]
    REPLExt = "REPL"

[[deps.PooledArrays]]
deps = ["DataAPI", "Future"]
git-tree-sha1 = "36d8b4b899628fb92c2749eb488d884a926614d3"
uuid = "2dfb63ee-cc39-5dd5-95bd-886bf059d720"
version = "1.4.3"

[[deps.PreallocationTools]]
deps = ["Adapt", "ArrayInterface", "PrecompileTools"]
git-tree-sha1 = "c05b4c6325262152483a1ecb6c69846d2e01727b"
uuid = "d236fae5-4411-538c-8e31-a6e3d9e00b46"
version = "0.4.34"

    [deps.PreallocationTools.extensions]
    PreallocationToolsForwardDiffExt = "ForwardDiff"
    PreallocationToolsReverseDiffExt = "ReverseDiff"
    PreallocationToolsSparseConnectivityTracerExt = "SparseConnectivityTracer"

    [deps.PreallocationTools.weakdeps]
    ForwardDiff = "f6369f11-7733-5829-9624-2563aa707210"
    ReverseDiff = "37e2e3b7-166d-5795-8a7a-e32c996b4267"
    SparseConnectivityTracer = "9f842d2f-2579-4b1d-911e-f412cf18a3f5"

[[deps.PrecompileTools]]
deps = ["Preferences"]
git-tree-sha1 = "5aa36f7049a63a1528fe8f7c3f2113413ffd4e1f"
uuid = "aea7be01-6a6a-4083-8856-8a6e6704d82a"
version = "1.2.1"

[[deps.Preferences]]
deps = ["TOML"]
git-tree-sha1 = "522f093a29b31a93e34eaea17ba055d850edea28"
uuid = "21216c6a-2e73-6563-6e65-726566657250"
version = "1.5.1"

[[deps.PrettyTables]]
deps = ["Crayons", "LaTeXStrings", "Markdown", "PrecompileTools", "Printf", "REPL", "Reexport", "StringManipulation", "Tables"]
git-tree-sha1 = "c5a07210bd060d6a8491b0ccdee2fa0235fc00bf"
uuid = "08abe8d2-0d0c-5749-adfa-8a2ac140af0d"
version = "3.1.2"

[[deps.Printf]]
deps = ["Unicode"]
uuid = "de0858da-6303-5e67-8744-51eddeeeb8d7"
version = "1.11.0"

[[deps.REPL]]
deps = ["InteractiveUtils", "JuliaSyntaxHighlighting", "Markdown", "Sockets", "StyledStrings", "Unicode"]
uuid = "3fa0cd96-eef1-5676-8a61-b3b8758bbffb"
version = "1.11.0"

[[deps.Random]]
deps = ["SHA"]
uuid = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"
version = "1.11.0"

[[deps.Random123]]
deps = ["Random", "RandomNumbers"]
git-tree-sha1 = "dbe5fd0b334694e905cb9fda73cd8554333c46e2"
uuid = "74087812-796a-5b5d-8853-05524746bad3"
version = "1.7.1"

[[deps.RandomNumbers]]
deps = ["Random"]
git-tree-sha1 = "c6ec94d2aaba1ab2ff983052cf6a606ca5985902"
uuid = "e6cf234a-135c-5ec9-84dd-332b85af5143"
version = "1.6.0"

[[deps.RecipesBase]]
deps = ["PrecompileTools"]
git-tree-sha1 = "5c3d09cc4f31f5fc6af001c250bf1278733100ff"
uuid = "3cdcf5f2-1ef4-517c-9805-6587b60abb01"
version = "1.3.4"

[[deps.RecursiveArrayTools]]
deps = ["Adapt", "ArrayInterface", "DocStringExtensions", "GPUArraysCore", "LinearAlgebra", "RecipesBase", "StaticArraysCore", "Statistics", "SymbolicIndexingInterface"]
git-tree-sha1 = "d7c53a81b0ab7f62842ff79d9e74e34562d5834e"
uuid = "731186ca-8d62-57ce-b412-fbd966d074cd"
version = "3.42.0"

    [deps.RecursiveArrayTools.extensions]
    RecursiveArrayToolsFastBroadcastExt = "FastBroadcast"
    RecursiveArrayToolsForwardDiffExt = "ForwardDiff"
    RecursiveArrayToolsKernelAbstractionsExt = "KernelAbstractions"
    RecursiveArrayToolsMeasurementsExt = "Measurements"
    RecursiveArrayToolsMonteCarloMeasurementsExt = "MonteCarloMeasurements"
    RecursiveArrayToolsReverseDiffExt = ["ReverseDiff", "Zygote"]
    RecursiveArrayToolsSparseArraysExt = ["SparseArrays"]
    RecursiveArrayToolsStructArraysExt = "StructArrays"
    RecursiveArrayToolsTablesExt = ["Tables"]
    RecursiveArrayToolsTrackerExt = "Tracker"
    RecursiveArrayToolsZygoteExt = "Zygote"

    [deps.RecursiveArrayTools.weakdeps]
    FastBroadcast = "7034ab61-46d4-4ed7-9d0f-46aef9175898"
    ForwardDiff = "f6369f11-7733-5829-9624-2563aa707210"
    KernelAbstractions = "63c18a36-062a-441e-b654-da1e3ab1ce7c"
    Measurements = "eff96d63-e80a-5855-80a2-b1b0885c5ab7"
    MonteCarloMeasurements = "0987c9cc-fe09-11e8-30f0-b96dd679fdca"
    ReverseDiff = "37e2e3b7-166d-5795-8a7a-e32c996b4267"
    SparseArrays = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"
    StructArrays = "09ab397b-f2b6-538f-b94a-2f83cf4a842a"
    Tables = "bd369af6-aec1-5ad0-b16a-f7cc5008161c"
    Tracker = "9f7883ad-71c0-57eb-9f7f-b5c9e6d3789c"
    Zygote = "e88e6eb3-aa80-5325-afca-941959d7151f"

[[deps.Reexport]]
git-tree-sha1 = "45e428421666073eab6f2da5c9d310d99bb12f9b"
uuid = "189a3867-3050-52da-a836-e630ba90ab69"
version = "1.2.2"

[[deps.Requires]]
deps = ["UUIDs"]
git-tree-sha1 = "62389eeff14780bfe55195b7204c0d8738436d64"
uuid = "ae029012-a4dd-5104-9daa-d747884805df"
version = "1.3.1"

[[deps.RuntimeGeneratedFunctions]]
deps = ["ExprTools", "SHA", "Serialization"]
git-tree-sha1 = "2f609ec2295c452685d3142bc4df202686e555d2"
uuid = "7e49a35a-f44a-4d26-94aa-eba1b4ca6b47"
version = "0.5.16"

[[deps.SHA]]
uuid = "ea8e919c-243c-51af-8825-aaa63cd721ce"
version = "0.7.0"

[[deps.SciMLBase]]
deps = ["ADTypes", "Accessors", "Adapt", "ArrayInterface", "CommonSolve", "ConstructionBase", "Distributed", "DocStringExtensions", "EnumX", "FunctionWrappersWrappers", "IteratorInterfaceExtensions", "LinearAlgebra", "Logging", "Markdown", "Moshi", "PreallocationTools", "PrecompileTools", "Preferences", "Printf", "RecipesBase", "RecursiveArrayTools", "Reexport", "RuntimeGeneratedFunctions", "SciMLLogging", "SciMLOperators", "SciMLPublic", "SciMLStructures", "StaticArraysCore", "Statistics", "SymbolicIndexingInterface"]
git-tree-sha1 = "b06382e2f1ff0c9aff4f88f560673c800df6099f"
uuid = "0bca4576-84f4-4d90-8ffe-ffa030f20462"
version = "2.128.0"

    [deps.SciMLBase.extensions]
    SciMLBaseChainRulesCoreExt = "ChainRulesCore"
    SciMLBaseDifferentiationInterfaceExt = "DifferentiationInterface"
    SciMLBaseDistributionsExt = "Distributions"
    SciMLBaseEnzymeExt = "Enzyme"
    SciMLBaseForwardDiffExt = "ForwardDiff"
    SciMLBaseMLStyleExt = "MLStyle"
    SciMLBaseMakieExt = "Makie"
    SciMLBaseMeasurementsExt = "Measurements"
    SciMLBaseMonteCarloMeasurementsExt = "MonteCarloMeasurements"
    SciMLBaseMooncakeExt = "Mooncake"
    SciMLBasePartialFunctionsExt = "PartialFunctions"
    SciMLBasePyCallExt = "PyCall"
    SciMLBasePythonCallExt = "PythonCall"
    SciMLBaseRCallExt = "RCall"
    SciMLBaseReverseDiffExt = "ReverseDiff"
    SciMLBaseTrackerExt = "Tracker"
    SciMLBaseZygoteExt = ["Zygote", "ChainRulesCore"]

    [deps.SciMLBase.weakdeps]
    ChainRules = "082447d4-558c-5d27-93f4-14fc19e9eca2"
    ChainRulesCore = "d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4"
    DifferentiationInterface = "a0c0ee7d-e4b9-4e03-894e-1c5f64a51d63"
    Distributions = "31c24e10-a181-5473-b8eb-7969acd0382f"
    Enzyme = "7da242da-08ed-463a-9acd-ee780be4f1d9"
    ForwardDiff = "f6369f11-7733-5829-9624-2563aa707210"
    MLStyle = "d8e11817-5142-5d16-987a-aa16d5891078"
    Makie = "ee78f7c6-11fb-53f2-987a-cfe4a2b5a57a"
    Measurements = "eff96d63-e80a-5855-80a2-b1b0885c5ab7"
    MonteCarloMeasurements = "0987c9cc-fe09-11e8-30f0-b96dd679fdca"
    Mooncake = "da2b9cff-9c12-43a0-ae48-6db2b0edb7d6"
    PartialFunctions = "570af359-4316-4cb7-8c74-252c00c2016b"
    PyCall = "438e738f-606a-5dbb-bf0a-cddfbfd45ab0"
    PythonCall = "6099a3de-0909-46bc-b1f4-468b9a2dfc0d"
    RCall = "6f49c342-dc21-5d91-9882-a32aef131414"
    ReverseDiff = "37e2e3b7-166d-5795-8a7a-e32c996b4267"
    Tracker = "9f7883ad-71c0-57eb-9f7f-b5c9e6d3789c"
    Zygote = "e88e6eb3-aa80-5325-afca-941959d7151f"

[[deps.SciMLLogging]]
deps = ["Logging", "LoggingExtras", "Preferences"]
git-tree-sha1 = "39b1b0a70b5625f6d2fb7d4bb6d53b8875350964"
uuid = "a6db7da4-7206-11f0-1eab-35f2a5dbe1d1"
version = "1.7.1"

[[deps.SciMLOperators]]
deps = ["Accessors", "ArrayInterface", "DocStringExtensions", "LinearAlgebra", "MacroTools"]
git-tree-sha1 = "d1d14b15bbebf48dc80e8a7cfe640e2d835e22ea"
uuid = "c0aeaf25-5076-4817-a8d5-81caf7dfa961"
version = "1.14.1"
weakdeps = ["SparseArrays", "StaticArraysCore"]

    [deps.SciMLOperators.extensions]
    SciMLOperatorsSparseArraysExt = "SparseArrays"
    SciMLOperatorsStaticArraysCoreExt = "StaticArraysCore"

[[deps.SciMLPublic]]
git-tree-sha1 = "ed647f161e8b3f2973f24979ec074e8d084f1bee"
uuid = "431bcebd-1456-4ced-9d72-93c2757fff0b"
version = "1.0.0"

[[deps.SciMLStructures]]
deps = ["ArrayInterface"]
git-tree-sha1 = "566c4ed301ccb2a44cbd5a27da5f885e0ed1d5df"
uuid = "53ae85a6-f571-4167-b2af-e1d143709226"
version = "1.7.0"

[[deps.ScopedValues]]
deps = ["HashArrayMappedTries", "Logging"]
git-tree-sha1 = "c3b2323466378a2ba15bea4b2f73b081e022f473"
uuid = "7e506255-f358-4e82-b7e4-beb19740aa63"
version = "1.5.0"

[[deps.Scratch]]
deps = ["Dates"]
git-tree-sha1 = "9b81b8393e50b7d4e6d0a9f14e192294d3b7c109"
uuid = "6c6a2e73-6563-6170-7368-637461726353"
version = "1.3.0"

[[deps.SentinelArrays]]
deps = ["Dates", "Random"]
git-tree-sha1 = "712fb0231ee6f9120e005ccd56297abbc053e7e0"
uuid = "91c51154-3ec4-41a3-a24f-3f23e20d615c"
version = "1.4.8"

[[deps.Serialization]]
uuid = "9e88b42a-f829-5b0c-bbe9-9e923198166b"
version = "1.11.0"

[[deps.Setfield]]
deps = ["ConstructionBase", "Future", "MacroTools", "StaticArraysCore"]
git-tree-sha1 = "c5391c6ace3bc430ca630251d02ea9687169ca68"
uuid = "efcf1570-3423-57d1-acb7-fd33fddbac46"
version = "1.1.2"

[[deps.Sockets]]
uuid = "6462fe0b-24de-5631-8697-dd941f90decc"
version = "1.11.0"

[[deps.SortingAlgorithms]]
deps = ["DataStructures"]
git-tree-sha1 = "64d974c2e6fdf07f8155b5b2ca2ffa9069b608d9"
uuid = "a2af1166-a08f-5f64-846c-94a0d3cef48c"
version = "1.2.2"

[[deps.SparseArrays]]
deps = ["Libdl", "LinearAlgebra", "Random", "Serialization", "SuiteSparse_jll"]
uuid = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"
version = "1.12.0"

[[deps.StaticArrays]]
deps = ["LinearAlgebra", "PrecompileTools", "Random", "StaticArraysCore"]
git-tree-sha1 = "b8693004b385c842357406e3af647701fe783f98"
uuid = "90137ffa-7385-5640-81b9-e52037218182"
version = "1.9.15"
weakdeps = ["ChainRulesCore", "Statistics"]

    [deps.StaticArrays.extensions]
    StaticArraysChainRulesCoreExt = "ChainRulesCore"
    StaticArraysStatisticsExt = "Statistics"

[[deps.StaticArraysCore]]
git-tree-sha1 = "6ab403037779dae8c514bad259f32a447262455a"
uuid = "1e83bf80-4336-4d27-bf5d-d5a4f845583c"
version = "1.4.4"

[[deps.Statistics]]
deps = ["LinearAlgebra"]
git-tree-sha1 = "ae3bb1eb3bba077cd276bc5cfc337cc65c3075c0"
uuid = "10745b16-79ce-11e8-11f9-7d13ad32a3b2"
version = "1.11.1"
weakdeps = ["SparseArrays"]

    [deps.Statistics.extensions]
    SparseArraysExt = ["SparseArrays"]

[[deps.StringEncodings]]
deps = ["Libiconv_jll"]
git-tree-sha1 = "b765e46ba27ecf6b44faf70df40c57aa3a547dcb"
uuid = "69024149-9ee7-55f6-a4c4-859efe599b68"
version = "0.3.7"

[[deps.StringManipulation]]
deps = ["PrecompileTools"]
git-tree-sha1 = "a3c1536470bf8c5e02096ad4853606d7c8f62721"
uuid = "892a3eda-7b42-436c-8928-eab12a02cf0e"
version = "0.4.2"

[[deps.StructTypes]]
deps = ["Dates", "UUIDs"]
git-tree-sha1 = "159331b30e94d7b11379037feeb9b690950cace8"
uuid = "856f2bd8-1eba-4b0a-8007-ebc267875bd4"
version = "1.11.0"

[[deps.StyledStrings]]
uuid = "f489334b-da3d-4c2e-b8f0-e476e12c162b"
version = "1.11.0"

[[deps.SuiteSparse]]
deps = ["Libdl", "LinearAlgebra", "Serialization", "SparseArrays"]
uuid = "4607b0f0-06f3-5cda-b6b1-a6196a1729e9"

[[deps.SuiteSparse_jll]]
deps = ["Artifacts", "Libdl", "libblastrampoline_jll"]
uuid = "bea87d4a-7f5b-5778-9afe-8cc45184846c"
version = "7.8.3+2"

[[deps.SymbolicIndexingInterface]]
deps = ["Accessors", "ArrayInterface", "RuntimeGeneratedFunctions", "StaticArraysCore"]
git-tree-sha1 = "94c58884e013efff548002e8dc2fdd1cb74dfce5"
uuid = "2efcf032-c050-4f8e-a9bb-153293bab1f5"
version = "0.3.46"
weakdeps = ["PrettyTables"]

    [deps.SymbolicIndexingInterface.extensions]
    SymbolicIndexingInterfacePrettyTablesExt = "PrettyTables"

[[deps.TOML]]
deps = ["Dates"]
uuid = "fa267f1f-6049-4f14-aa54-33bafae1ed76"
version = "1.0.3"

[[deps.TableTraits]]
deps = ["IteratorInterfaceExtensions"]
git-tree-sha1 = "c06b2f539df1c6efa794486abfb6ed2022561a39"
uuid = "3783bdb8-4a98-5b6b-af9a-565f29a5fe9c"
version = "1.0.1"

[[deps.Tables]]
deps = ["DataAPI", "DataValueInterfaces", "IteratorInterfaceExtensions", "OrderedCollections", "TableTraits"]
git-tree-sha1 = "f2c1efbc8f3a609aadf318094f8fc5204bdaf344"
uuid = "bd369af6-aec1-5ad0-b16a-f7cc5008161c"
version = "1.12.1"

[[deps.Tar]]
deps = ["ArgTools", "SHA"]
uuid = "a4e569a6-e804-4fa4-b0f3-eef7a1d5b13e"
version = "1.10.0"

[[deps.TextWrap]]
git-tree-sha1 = "43044b737fa70bc12f6105061d3da38f881a3e3c"
uuid = "b718987f-49a8-5099-9789-dcd902bef87d"
version = "1.0.2"

[[deps.TimerOutputs]]
deps = ["ExprTools", "Printf"]
git-tree-sha1 = "3748bd928e68c7c346b52125cf41fff0de6937d0"
uuid = "a759f4b9-e2f1-59dc-863e-4aeb61b1ea8f"
version = "0.5.29"

    [deps.TimerOutputs.extensions]
    FlameGraphsExt = "FlameGraphs"

    [deps.TimerOutputs.weakdeps]
    FlameGraphs = "08572546-2f56-4bcf-ba4e-bab62c3a3f89"

[[deps.Tracy]]
deps = ["ExprTools", "LibTracyClient_jll", "Libdl"]
git-tree-sha1 = "73e3ff50fd3990874c59fef0f35d10644a1487bc"
uuid = "e689c965-62c8-4b79-b2c5-8359227902fd"
version = "0.1.6"

    [deps.Tracy.extensions]
    TracyProfilerExt = "TracyProfiler_jll"

    [deps.Tracy.weakdeps]
    TracyProfiler_jll = "0c351ed6-8a68-550e-8b79-de6f926da83c"

[[deps.UUIDs]]
deps = ["Random", "SHA"]
uuid = "cf7118a7-6976-5b1a-9a39-7adc72f591a4"
version = "1.11.0"

[[deps.Unicode]]
uuid = "4ec0a83e-493e-50e2-b9ac-8f72acf5a8f5"
version = "1.11.0"

[[deps.UnsafeAtomics]]
git-tree-sha1 = "b13c4edda90890e5b04ba24e20a310fbe6f249ff"
uuid = "013be700-e6cd-48c3-b4a1-df204f14c38f"
version = "0.3.0"
weakdeps = ["LLVM"]

    [deps.UnsafeAtomics.extensions]
    UnsafeAtomicsLLVM = ["LLVM"]

[[deps.YAML]]
deps = ["Base64", "Dates", "Printf", "StringEncodings"]
git-tree-sha1 = "a1c0c7585346251353cddede21f180b96388c403"
uuid = "ddb6d928-2868-570f-bddf-ab3f9cf99eb6"
version = "0.4.16"

[[deps.Zlib_jll]]
deps = ["Libdl"]
uuid = "83775a58-1f1d-513f-b197-d71354ab007a"
version = "1.3.1+2"

[[deps.demumble_jll]]
deps = ["Artifacts", "JLLWrappers", "Libdl"]
git-tree-sha1 = "6498e3581023f8e530f34760d18f75a69e3a4ea8"
uuid = "1e29f10c-031c-5a83-9565-69cddfc27673"
version = "1.3.0+0"

[[deps.libblastrampoline_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "8e850b90-86db-534c-a0d3-1478176c7d93"
version = "5.15.0+0"

[[deps.nghttp2_jll]]
deps = ["Artifacts", "Libdl"]
uuid = "8e850ede-7688-5339-a07c-302acd2aaf8d"
version = "1.64.0+1"

[[deps.oneTBB_jll]]
deps = ["Artifacts", "JLLWrappers", "LazyArtifacts", "Libdl"]
git-tree-sha1 = "1350188a69a6e46f799d3945beef36435ed7262f"
uuid = "1317d2d5-d96f-522e-a858-c73665f53c3e"
version = "2022.0.0+1"

[[deps.p7zip_jll]]
deps = ["Artifacts", "CompilerSupportLibraries_jll", "Libdl"]
uuid = "3f19e933-33d8-53b3-aaab-bd5110c3b7a0"
version = "17.7.0+0"
"// # FILE: .\Project.toml";
name = "HEXA_TopOpt"
uuid = "ca0ed32d-1ad4-4b7a-9919-fa42dfec13a8"
version = "1.0.0"
authors = ["User"]

[deps]
AMGX = "c963dde9-0319-47f5-bf0c-b07d3c80ffa6"
AlgebraicMultigrid = "2169fc97-5a83-5252-b627-83903c6c433c"
ArgParse = "c7e460c6-2fb9-53a9-8c5b-16f535851c63"
CUDA = "052768ef-5323-5732-b1bb-66c8b64840ba"
Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"
FilePathsBase = "48062228-2e41-5def-b9a4-89aafe57970f"
GeometryBasics = "5c1252a2-5f33-56bf-86c9-59e7332b4326"
JSON = "682c06a0-de6a-54ab-a142-c8b1cf79cde6"
JSON3 = "0f8b85d8-7281-11e9-16c2-39a750bddbf1"
Krylov = "ba0b0d4f-ebba-5204-a429-3ac8c609bfb7"
LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
LinearOperators = "5c8ed15e-5a4c-59e4-a42b-c7e8811fb125"
MarchingCubes = "299715c1-40a9-479a-aaf9-4a633d36f717"
Meshing = "e6723b4c-ebff-59f1-b4b7-d97aa5274f73"
Printf = "de0858da-6303-5e67-8744-51eddeeeb8d7"
SparseArrays = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"
Statistics = "10745b16-79ce-11e8-11f9-7d13ad32a3b2"
SuiteSparse = "4607b0f0-06f3-5cda-b6b1-a6196a1729e9"
YAML = "ddb6d928-2868-570f-bddf-ab3f9cf99eb6"

[compat]
AMGX = "0.2.0"
AlgebraicMultigrid = "1.1.0"
ArgParse = "1.2.0"
CUDA = "5.9.5"
Dates = "1.11.0"
FilePathsBase = "0.9.24"
GeometryBasics = "0.5.10"
JSON = "0.21.4"
JSON3 = "1.14.3"
Krylov = "0.10.3"
LinearAlgebra = "1.11.0"
LinearOperators = "2.11.0"
MarchingCubes = "0.1.11"
Meshing = "0.7.0"
Printf = "1.11.0"
SparseArrays = "1.11.0"
Statistics = "1.11.1"
YAML = "0.4.16"
julia = "1.9"
"// # FILE: .\Run.jl";


using Pkg
using Dates

const C_RESET   = "\u001b[0m"
const C_BOLD    = "\u001b[1m"
const C_CYAN    = "\u001b[36m"
const C_GREEN   = "\u001b[32m"
const C_YELLOW  = "\u001b[33m"
const C_RED     = "\u001b[31m"
const C_MAGENTA = "\u001b[35m"

const REQUIRED_PACKAGES = [
    "CUDA",             # GPU acceleration
    "JSON",             # Input/Output data formatting
    "YAML",             # Configuration file parsing
    "MarchingCubes"     # Original STL generation package
]

function setup_robust_environment()
    println("\n" * C_CYAN * "="^60 * C_RESET)
    println(C_CYAN * C_BOLD * ">>> [LAUNCHER] HEXA TopOpt: Robust Environment Setup" * C_RESET)
    println(C_CYAN * ">>> [INFO] Time: $(Dates.now()) | Julia Version: $VERSION" * C_RESET)
    println(C_CYAN * "="^60 * C_RESET)

    project_dir = @__DIR__
    println(">>> [ENV] Activating project at: " * C_BOLD * "$project_dir" * C_RESET)
    Pkg.activate(project_dir)

    manifest_path = joinpath(project_dir, "Manifest.toml")
    project_path = joinpath(project_dir, "Project.toml")
    
    if !isfile(project_path)
        println(C_YELLOW * ">>> [ENV] No Project.toml found. Initializing new project context..." * C_RESET)
    end
    
    try
        print(">>> [ENV] Attempting to instantiate environment... ")
        Pkg.instantiate()
        println(C_GREEN * "[OK]" * C_RESET)
    catch e
        println(C_RED * "\n!!! [ENV] Instantiation failed." * C_RESET)
        println(C_YELLOW * "!!! [ENV] performing SELF-HEALING: Deleting Manifest.toml and Re-resolving..." * C_RESET)
        
        if isfile(manifest_path)
            rm(manifest_path, force=true)
            println(">>> [ENV] Deleted incompatible Manifest.toml.")
        end

        try
            Pkg.resolve()
            Pkg.instantiate()
            println(C_GREEN * ">>> [ENV] Self-healing successful. Environment instantiated." * C_RESET)
        catch e_heal
            println(C_RED * "!!! [FATAL] Self-healing failed. Critical dependency error." * C_RESET)
            println(C_RED * "!!! [FATAL] Error: $e_heal" * C_RESET)
            exit(1)
        end
    end

    print(">>> [ENV] Verifying core package list... ")
    try
        deps = Pkg.dependencies()
        missing_pkgs = String[]
        for pkg in REQUIRED_PACKAGES
            is_present = false
            for (uuid, info) in deps
                if info.name == pkg
                    is_present = true
                    break
                end
            end
            if !is_present
                push!(missing_pkgs, pkg)
            end
        end

        if !isempty(missing_pkgs)
            error("Missing packages: $missing_pkgs")
        end

        println(C_GREEN * "[OK]" * C_RESET)
    catch
        println(C_YELLOW * "\n>>> [ENV] Core dependencies missing or broken. Re-adding packages..." * C_RESET)
        try
            Pkg.add(REQUIRED_PACKAGES)
            println(C_GREEN * ">>> [ENV] Packages added successfully." * C_RESET)
        catch e_add
            println(C_RED * "!!! [FATAL] Could not install core packages: $e_add" * C_RESET)
            exit(1)
        end
    end
    
    println(">>> [ENV] Precompiling project...")
    try
        Pkg.precompile()
    catch
        println(C_YELLOW * "!!! [WARN] Precompilation had warnings (safe to ignore if code runs)." * C_RESET)
    end

    println(C_GREEN * ">>> [ENV] Environment Ready." * C_RESET)
    println(C_CYAN * "-"^60 * C_RESET)
end


setup_robust_environment()


using CUDA




function generate_machine_limits()
    config_dir = joinpath(@__DIR__, "configs")
    if !isdir(config_dir); mkpath(config_dir); end
    limit_file = joinpath(config_dir, "_machine_limits.jl")

    if isfile(limit_file)
        println(">>> [HARDWARE] Limits file found: $limit_file")
        println(">>> [HARDWARE] Skipping stress test. Delete file to re-run.")
        return
    end

    if !CUDA.functional()
        println(C_YELLOW * ">>> [HARDWARE] No GPU detected. Skipping VRAM stress test." * C_RESET)
        return
    end

    println("\n" * C_MAGENTA * "="^60 * C_RESET)
    println(C_MAGENTA * C_BOLD * ">>> [HARDWARE] RUNNING VRAM STRESS TEST (GMG SOLVER)" * C_RESET)
    println(C_MAGENTA * ">>> determining maximum safe element count for this machine..." * C_RESET)
    println(C_MAGENTA * "="^60 * C_RESET)

    function attempt_allocation(nElem_target)
        GC.gc()
        CUDA.reclaim()
        
        n = round(Int, cbrt(nElem_target))
        nx, ny, nz = n, n, n
        
        nNodes_f = (nx+1)*(ny+1)*(nz+1)
        nElem_f = nx*ny*nz
        
        try
            
            v1 = CUDA.zeros(Float32, nNodes_f * 3) 
            v2 = CUDA.zeros(Float32, nNodes_f * 3) 
            v3 = CUDA.zeros(Float32, nNodes_f * 3) 
            v4 = CUDA.zeros(Float32, nNodes_f * 3) 
            v5 = CUDA.zeros(Float32, nNodes_f * 3) 
            v6 = CUDA.zeros(Float32, nNodes_f * 3) 
            
            conn = CUDA.zeros(Int32, nElem_f * 8)
            factors = CUDA.zeros(Float32, nElem_f)
            
            
            buffers = []
            current_nx, current_ny, current_nz = nx, ny, nz
            for level in 2:4
                current_nx = max(1, div(current_nx, 2))
                current_ny = max(1, div(current_ny, 2))
                current_nz = max(1, div(current_nz, 2))
                
                nNodes_c = (current_nx+1)*(current_ny+1)*(current_nz+1)
                nElem_c  = current_nx*current_ny*current_nz
                
                push!(buffers, CUDA.zeros(Float32, nNodes_c * 3)) 
                push!(buffers, CUDA.zeros(Float32, nNodes_c * 3)) 
                push!(buffers, CUDA.zeros(Float32, nNodes_c * 3)) 
                push!(buffers, CUDA.zeros(Float32, nElem_c))      
                push!(buffers, CUDA.zeros(Int32, nElem_c * 8))    
            end
            
            CUDA.synchronize()
            
            return true
        catch e
            return false
        end
    end

    
    safe_limit = 500_000 
    
    start_elems = 1_000_000
    step_elems  = 2_000_000
    
    total_mem = CUDA.total_memory()
    est_max = total_mem / 800 
    
    end_elems = min(150_000_000, floor(Int, est_max * 1.5)) 

    println(">>> [TEST] Searching range: $(Base.format_bytes(start_elems)) to $(Base.format_bytes(end_elems)) elements...")

    for count in start_elems:step_elems:end_elems
        print("    Testing $(Base.format_bytes(count)) elements... ")
        if attempt_allocation(count)
            print(C_GREEN * "[PASS]" * C_RESET * "\r")
            safe_limit = count
        else
            println(C_RED * "[FAIL]" * C_RESET)
            println(">>> [TEST] Crash point found. Safe limit: $(Base.format_bytes(safe_limit))")
            break
        end
    end

    
    final_limit = floor(Int, safe_limit * 0.90)
    
    println(">>> [HARDWARE] Writing limits to $limit_file")
    open(limit_file, "w") do io
        write(io, "# MACHINE SPECIFIC LIMITS - GENERATED AUTOMATICALLY\n")
        write(io, "module MachineLimits\n")
        write(io, "    const MAX_GMG_ELEMENTS = $final_limit\n")
        write(io, "    const MAX_JACOBI_ELEMENTS = $(final_limit * 2) # Jacobi uses much less RAM\n")
        write(io, "end\n")
    end
    println(C_GREEN * ">>> [HARDWARE] Setup Complete. Max GMG Elements: $final_limit" * C_RESET)
    println(C_CYAN * "-"^60 * C_RESET)
end



Base.invokelatest(generate_machine_limits)

const MAIN_SCRIPT = joinpath(@__DIR__, "src", "Main.jl")

if !isfile(MAIN_SCRIPT)
    println(C_RED * "!!! [ERROR] Could not find Main.jl at: $MAIN_SCRIPT" * C_RESET)
    exit(1)
end

if length(ARGS) == 0
    println(">>> [LAUNCHER] No arguments provided. Defaulting to 'configs/optimization_cases.yaml'.")
    push!(ARGS, joinpath(@__DIR__, "configs", "optimization_cases.yaml"))
end

println(">>> [LAUNCHER] Handing off to Main.jl...\n")
include(MAIN_SCRIPT)
"// # FILE: .\configs\_machine_limits.jl";

module MachineLimits
    const MAX_GMG_ELEMENTS = 17100000
    const MAX_JACOBI_ELEMENTS = 34200000 
end
"// # FILE: .\configs\domain_definitions.yaml";
# FILE: .\configs\domain_definitions.yaml
# ==============================================================================
# PART 1: PHYSICAL PROBLEM DEFINITION
# ==============================================================================
# This file contains the "What": Geometry, Loads, BCs, and Materials.

# ------------------------------------------------------------------------------
# GEOMETRY DEFINITION
# ------------------------------------------------------------------------------
geometry:
  # Physical dimensions (meters)
  length_x: 60
  length_y: 20
  length_z: 20
  
  # Geometric primitives (Design/Non-Design regions)
  # Stiffness Ratio: 0=Void, >0=Solid/Stiffer, <0=Passive Thermal
  sphere1:
    type: sphere
    center: [12.51, 28.49, 50]
    diameter: 8
    stiffness_ratio: 0   # Hole
    
  sphere2:
    type: sphere
    center: [60.38, -0.07, 50]
    diameter: 4
    stiffness_ratio: 10  # Stiff inclusion
    
  sphere3:
    type: sphere
    center: [34.29, 5, 50]
    diameter: 4
    stiffness_ratio: -10 # Passive thermal
      
  box1:
    type: box
    center: [28, 15, 50]
    size: [1, 2, 3]
    stiffness_ratio: 5
      
  box2:
    type: box
    center: [45.06, 8.95, 50]
    size: [1, 4, 2]
    stiffness_ratio: 0   # Void box

# ------------------------------------------------------------------------------
# BOUNDARY CONDITIONS
# ------------------------------------------------------------------------------
boundary_conditions:
  - location: [0, ':', ':'] # Fix X=0 face
    DoFs: [1, 2, 3]         # Fully fixed

# ------------------------------------------------------------------------------
# EXTERNAL FORCES
# ------------------------------------------------------------------------------
external_forces:
  - name: Y10
    location: [100%, 0, 0]
    F: [0, 10, 0]
    
  - name: Z-10
    location: [100%, 0, 50%]
    F: [0, 0, -10]
    
  - name: Y20
    location: [100%, 0, 100%]
    F: [0, 20, 0]
    
  - name: Mid_Y20
    location: [50%, 0, 50%]
    F: [0, 15, 0]

# ------------------------------------------------------------------------------
# MATERIAL PROPERTIES
# ------------------------------------------------------------------------------
material:
  E: 1                      # Young's Modulus
  nu: 0.3                   # Poisson's Ratio
  material_density: 0.001   # For self-weight
  gravity_acceleration: 9.81
  delta_temperature: 0.0
  l1_stress_allowable: 1.5  # Target stress limit (Moved here)
"// # FILE: .\configs\optimization_cases.yaml";
# FILE: .\configs\optimization_cases.yaml
# ==============================================================================
# OPTIMIZATION CASES ORCHESTRATOR
# ==============================================================================
# This file defines a sequence of simulations to run. 
# It merges a physics definition with a solver definition for each run.

batch_queue:
  # ----------------------------------------------------------------------------
  # Run 1: Standard RTX configuration
  # ----------------------------------------------------------------------------
  - job_name: "Baseline_RTX"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    
    # Overrides (Optional): Modify specific keys after merging
    overrides:
      output_settings:
        log_filename: "log_run1_baseline.txt"

  # ----------------------------------------------------------------------------
  # Run 2: High Precision Test
  # ----------------------------------------------------------------------------
  - job_name: "HighPrecision_Double"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    
    overrides:
      gpu_profile: "V100" # Forces Double Precision
      solver_parameters:
        tolerance: 1.0e-9
      output_settings:
        log_filename: "log_run2_high_precision.txt"

  # ----------------------------------------------------------------------------
  # Run 3: Parameter Sweep - Stricter Stress Constraint
  # ----------------------------------------------------------------------------
  - job_name: "Strict_Stress_Limit"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    
    overrides:
      # Material properties now house the stress limit
      material:
        l1_stress_allowable: 0.5 
      output_settings:
        log_filename: "log_run3_strict_stress.txt"
"// # FILE: .\configs\optimization_cases_EXAMPLE.yaml";
# FILE: .\configs\optimization_cases.yaml
# ==============================================================================
# OPTIMIZATION CASES ORCHESTRATOR
# ==============================================================================
# This file defines a sequence of simulations to run. 
# It merges a physics definition with a solver definition for each run.

batch_queue:
  # ----------------------------------------------------------------------------
  # Run 1: Standard RTX configuration
  # ----------------------------------------------------------------------------
  - job_name: "Baseline_RTX"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    
    # Overrides (Optional): Modify specific keys after merging
    overrides:
      output_settings:
        log_filename: "log_run1_baseline.txt"

  # ----------------------------------------------------------------------------
  # Run 2: High Precision Test
  # ----------------------------------------------------------------------------
  - job_name: "HighPrecision_Double"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    
    overrides:
      gpu_profile: "V100" # Forces Double Precision
      solver_parameters:
        tolerance: 1.0e-9
      output_settings:
        log_filename: "log_run2_high_precision.txt"

  # ----------------------------------------------------------------------------
  # Run 3: Parameter Sweep - Stricter Stress Constraint
  # ----------------------------------------------------------------------------
  - job_name: "Strict_Stress_Limit"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    
    overrides:
      # Material properties now house the stress limit
      material:
        l1_stress_allowable: 0.5 
      output_settings:
        log_filename: "log_run3_strict_stress.txt"
"// # FILE: .\configs\solver_settings.yaml";
# FILE: .\configs\solver_settings.yaml
# ==============================================================================
# PART 2: NUMERICAL SOLVER & OPTIMIZATION SETTINGS
# ==============================================================================
# This file contains the "How": Solver precision, filtering, optimization loop.

# ------------------------------------------------------------------------------
# HARDWARE PROFILE
# ------------------------------------------------------------------------------
gpu_profile: "RTX" # Options: RTX, V100, A100, H100, AUTO

# ------------------------------------------------------------------------------
# RESTART CONFIGURATION
# ------------------------------------------------------------------------------
restart_configuration:
  enable_restart: false
  file_path: ""

# ------------------------------------------------------------------------------
# MESH & ADAPTIVITY SETTINGS
# ------------------------------------------------------------------------------
mesh_settings:
  # Initial background grid resolution (RENAMED)
  initial_ground_mesh_size: 500_000

  # Adaptive Mesh Refinement (AMR) targets (RENAMED)
  final_target_of_active_elements: 60_000
  
  max_growth_rate: 1.1
  nominal_refinement_threshold: 0.9
  exponent_for_refinement_schedule: 2.0
  max_background_elements: 500_000_000
  gpu_solver_safety_factor: 0.95

# ------------------------------------------------------------------------------
# OPTIMIZATION LOOP
# ------------------------------------------------------------------------------
number_of_iterations: 4
hard_stop_after_iteration: 250

optimization_parameters:
  density_update_method: "hard"
  min_density: 0.0001
  density_clamp_max: 1
  
  # Culling schedule
  final_density_threshold: 0.90
  exponent_for_cutoff_schedule: 1.5 
  max_culling_ratio: 0.2

  # Filter Radius Parameters
  minimum_feature_size_physical: 0.1
  minimum_feature_size_elements: 1.0
  radius_max_multiplier: 1.0
  radius_min_multiplier: 1
  radius_decay_exponent: 1.8
  constraint_constant: 0.25

# ------------------------------------------------------------------------------
# SOLVER PARAMETERS
# ------------------------------------------------------------------------------
solver_parameters:
  solver_type: gpu              
  preconditioner: "multigrid"
  tolerance: 1.e-6 
  max_iterations: 30000 
  diagonal_shift_factor: 1.e-7 
  stagnation_tolerance: 1.0e-3
  max_shift_attempts: 7
  shift_multiplier: 10.0
  gpu_method: krylov        
  krylov_solver: cg              

# ------------------------------------------------------------------------------
# OUTPUT SETTINGS
# ------------------------------------------------------------------------------
output_settings:
  export_frequency: 1       
  save_bin_frequency: 1     
  save_STL_frequency: 10     
  save_VTK_frequency: 1     
  save_principal_stress_vectors: no
  log_filename: simulation_log.txt
  iso_surface_threshold: 0.01
  stl_subdivision_level: 2       
  stl_smoothing_passes: 2        
  stl_mesh_smoothing_iters: 6    
  maximum_cells_in_binary_output: 25_000_000
  stl_target_triangle_count: 95000
"// # FILE: .\src\Main.jl";
// 

using Pkg
using LinearAlgebra
using SparseArrays
using Printf
using Base.Threads
using JSON
using Dates
using Statistics
using CUDA
using YAML

println("\n>>> SCRIPT START: Loading Modules...")
flush(stdout)

module HEXA
    using LinearAlgebra
    using SparseArrays
    using Printf
    using Base.Threads
    using JSON
    using Dates
    using Statistics
    using CUDA
    using YAML

    const PROJECT_ROOT = abspath(joinpath(@__DIR__, ".."))
    
    
    const LIMITS_FILE = joinpath(PROJECT_ROOT, "configs", "_machine_limits.jl")
    if isfile(LIMITS_FILE)
        include(LIMITS_FILE)
        using .MachineLimits
        println(">>> [HEXA] Loaded Machine Limits: GMG Max = $(MachineLimits.MAX_GMG_ELEMENTS)")
    else
        # Fallback defaults if test didn't run
        module MachineLimits
            const MAX_GMG_ELEMENTS = 5_000_000
            const MAX_JACOBI_ELEMENTS = 10_000_000
        end
        println(">>> [HEXA] No machine limits found. Using safe defaults.")
    end

    include("Utils/Diagnostics.jl")
    include("Utils/Helpers.jl")
    using .Diagnostics
    using .Helpers

    include("Core/Element.jl")
    include("Core/Boundary.jl")
    include("Core/Stress.jl")
    using .Element
    using .Boundary
    using .Stress

    include("Mesh/Mesh.jl")
    include("Mesh/MeshUtilities.jl")
    include("Mesh/MeshPruner.jl")
    include("Mesh/MeshRefiner.jl")
    include("Mesh/MeshShapeProcessing.jl")
    using .Mesh
    using .MeshUtilities
    using .MeshPruner
    using .MeshRefiner
    using .MeshShapeProcessing

    include("Solvers/CPUSolver.jl")
    include("Solvers/GPUGeometricMultigrid.jl")
    include("Solvers/GPUSolver.jl")
    include("Solvers/DirectSolver.jl")
    include("Solvers/IterativeSolver.jl")
    include("Solvers/Solver.jl")
    
    using .CPUSolver
    using .GPUGeometricMultigrid
    using .GPUSolver
    using .DirectSolver
    using .IterativeSolver
    using .Solver

    include("IO/Configuration.jl")
    include("IO/ExportVTK.jl")
    include("IO/Postprocessing.jl")
    
    include("Optimization/GPUExplicitFilter.jl")
    include("Optimization/TopOpt.jl")
    
    using .Configuration
    using .ExportVTK
    using .Postprocessing
    using .GPUExplicitFilter
    using .TopologyOptimization

    function __init__()
        Diagnostics.print_success("HEXA Finite Element Solver initialized")
        Helpers.clear_gpu_memory()
        flush(stdout)
    end
    
    function apply_hardware_profile!(config::Dict)
        gpu_type = get(config, "gpu_profile", "RTX")
        if gpu_type == "AUTO" && CUDA.functional()
            dev_name = CUDA.name(CUDA.device())
            if occursin("V100", dev_name); gpu_type = "V100"; end
            if occursin("A100", dev_name) || occursin("H100", dev_name); gpu_type = "H200"; end
            Diagnostics.print_info("Auto-Detected GPU: $dev_name -> Profile: $gpu_type")
        else
            Diagnostics.print_info("Using Configured Profile: $gpu_type")
        end
        
        mesh_conf = get(config, "mesh_settings", Dict())
        solver = get(config, "solver_parameters", Dict())
        
        config["force_float64"] = false
        if uppercase(gpu_type) in ["H", "H200", "H100", "A100"]
            Diagnostics.print_substep("High-Performance Data Center GPU (H/A-Series). Precision: Float64.")
            solver["tolerance"] = get(solver, "tolerance", 1.0e-12)
            solver["diagonal_shift_factor"] = 1.0e-10
            solver["solver_type"] = "gpu"
            config["force_float64"] = true
        elseif uppercase(gpu_type) == "V100"
            Diagnostics.print_substep("Legacy Data Center GPU (Tesla V100). Precision: Float64.")
            solver["tolerance"] = get(solver, "tolerance", 1.0e-10)
            solver["diagonal_shift_factor"] = 1.0e-9
            solver["solver_type"] = "gpu"
            config["force_float64"] = true
        else 
            Diagnostics.print_substep("Consumer/Workstation GPU (RTX-Series). Precision: Float32.")
            solver["tolerance"] = get(solver, "tolerance", 1.0e-6)
            solver["solver_type"] = "gpu"
            config["force_float64"] = false
        end
        config["mesh_settings"] = mesh_conf
        config["solver_parameters"] = solver
        config["hardware_profile_applied"] = gpu_type
        
        
        config["machine_limits"] = Dict(
            "MAX_GMG_ELEMENTS" => MachineLimits.MAX_GMG_ELEMENTS,
            "MAX_JACOBI_ELEMENTS" => MachineLimits.MAX_JACOBI_ELEMENTS
        )
    end

    function run_main(input_file=nothing)
        try
            if input_file === nothing
                input_file = joinpath(PROJECT_ROOT, "configs", "optimization_cases.yaml")
            end
            
            if !isfile(input_file)
                error("Input file not found: $input_file")
            end

            raw_config = Configuration.load_configuration(input_file)

            if haskey(raw_config, "batch_queue")
                queue = raw_config["batch_queue"]
                Diagnostics.print_banner("BATCH EXECUTION STARTED: $(length(queue)) Runs")
                
                for (i, run_def) in enumerate(queue)
                    job_name = get(run_def, "job_name", "Run_$i")
                    Diagnostics.print_banner("BATCH RUN $i/$((length(queue))): $job_name", color="\u001b[35m")
                    
                    domain_file = get(run_def, "domain_config", "")
                    solver_file = get(run_def, "solver_config", "")
                    overrides = get(run_def, "overrides", Dict())

                    if isempty(domain_file) || isempty(solver_file)
                        Diagnostics.print_error("Skipping $job_name: Missing config file paths.")
                        continue
                    end

                    if !isabspath(domain_file); domain_file = joinpath(PROJECT_ROOT, domain_file); end
                    if !isabspath(solver_file); solver_file = joinpath(PROJECT_ROOT, solver_file); end

                    try
                        merged_config = Configuration.load_and_merge_configurations(domain_file, solver_file, overrides)
                        _run_safe(merged_config, job_name)
                    catch e_run
                        Diagnostics.print_error("Job $job_name Failed: $e_run")
                        showerror(stdout, e_run, catch_backtrace())
                    end
                    
                    Diagnostics.print_success("Finished Batch Run: $job_name")
                    GC.gc()
                    if CUDA.functional(); CUDA.reclaim(); end
                end
                Diagnostics.print_banner("BATCH QUEUE COMPLETE")

            else
                base_job_name = get(raw_config, "job_name", splitext(basename(input_file))[1])
                _run_safe(raw_config, base_job_name)
            end

        catch e
            if isa(e, InterruptException)
                Diagnostics.print_banner("USER INTERRUPT", color="\u001b[33m")
                println(">>> Simulation stopped by user.")
            else
                Diagnostics.print_banner("FATAL ERROR DETECTED", color="\u001b[31m")
                showerror(stderr, e, catch_backtrace())
            end
            flush(stdout)
        finally
            if CUDA.functional()
                Diagnostics.print_info("Finalizing: Cleaning up GPU Memory...")
                Helpers.clear_gpu_memory()
                Diagnostics.print_success("GPU Memory Released.")
                flush(stdout)
            end
        end
    end

    function _run_safe(current_config::Dict, run_name::String="Simulation")
        Diagnostics.print_banner("HEXA TOPOLOGY OPTIMIZER: $run_name")
        Diagnostics.print_info("Clearing GPU Memory from previous runs...")
        
        if CUDA.functional()
            Helpers.clear_gpu_memory()
            CUDA.device!(0) 
            dev = CUDA.device()
            name = CUDA.name(dev)
            total_mem = CUDA.total_memory()
            
            if CUDA.runtime_version() >= v"11.2"
                threshold = min(total_mem * 0.10, 5 * 1024^3) 
                try
                    pool = CUDA.memory_pool(dev)
                    CUDA.attribute!(pool, CUDA.MEMPOOL_ATTR_RELEASE_THRESHOLD, UInt64(threshold))
                    Diagnostics.print_success("CUDA memory pool configured successfully")
                catch e
                    Diagnostics.print_warn("Memory pool configuration failed (non-critical): $e")
                end
            end
            
            mem_gb = total_mem / 1024^3
            Diagnostics.print_success("GPU Detected: $name ($(round(mem_gb, digits=2)) GB)")
        else
            Diagnostics.print_warn("No CUDA GPU detected. Running in CPU Mode (Slow).")
        end
        GC.gc()
        
        apply_hardware_profile!(current_config)
        
        restart_conf = get(current_config, "restart_configuration", Dict())
        enable_restart = get(restart_conf, "enable_restart", false)
        restart_path = get(restart_conf, "file_path", "")
        
        config = Dict{Any,Any}()
        density = Float32[]
        start_iter = 1
        restart_radius = 0.0f0
        restart_threshold = 0.0f0
        is_restart_active = false

        if enable_restart
             if isfile(restart_path)
                Diagnostics.print_banner("RESTART MODE ACTIVE", color="\u001b[35m")
                Diagnostics.print_info("Loading checkpoint: $restart_path")
                saved_config, density, saved_iter, restart_radius, restart_threshold = Configuration.load_checkpoint(restart_path)
                config = merge(saved_config, current_config)
                apply_hardware_profile!(config)
                start_iter = saved_iter + 1
                is_restart_active = true
            else
                Diagnostics.print_warn("Restart requested but file not found: '$restart_path'")
                Diagnostics.print_warn("Falling back to FRESH START.")
                config = current_config
                is_restart_active = false
            end
        else
            Diagnostics.print_info("Starting Fresh Simulation")
            config = current_config
            is_restart_active = false
        end
        
        hard_stop_iter = get(config, "hard_stop_after_iteration", -1)
        if hard_stop_iter > -1
            Diagnostics.print_info("HARD STOP ENABLED: Execution will stop after iteration $hard_stop_iter.")
        end

        out_settings = get(config, "output_settings", Dict())
        default_freq = get(out_settings, "export_frequency", 5)
        save_bin_freq = get(out_settings, "save_bin_frequency", default_freq)
        save_stl_freq = get(out_settings, "save_STL_frequency", default_freq)
        save_vtk_freq = get(out_settings, "save_VTK_frequency", default_freq)

        save_vec_val = get(out_settings, "save_principal_stress_vectors", "no")
        save_vectors_bool = (lowercase(string(save_vec_val)) == "yes" || save_vec_val == true)
        
        RESULTS_DIR = joinpath(PROJECT_ROOT, "RESULTS", run_name)
        if !isdir(RESULTS_DIR); mkpath(RESULTS_DIR); end
        Diagnostics.print_info("Output Directory: $RESULTS_DIR")

        raw_log_name = get(out_settings, "log_filename", "simulation_log.txt")
        log_base, log_ext = splitext(basename(raw_log_name))
        log_filename = joinpath(RESULTS_DIR, "$(log_base)_$(run_name)$(log_ext)")
        crash_log_filename = joinpath(RESULTS_DIR, "crash_report_$(run_name).txt")

        iso_threshold_val = get(out_settings, "iso_surface_threshold", 0.8)
        iso_threshold = Float32(iso_threshold_val)
        
        if !is_restart_active
            Diagnostics.init_log_file(log_filename, config)
        else
            Diagnostics.log_status("--- RESTARTING SIMULATION (Iter $start_iter) ---")
        end
        
        geom = Configuration.setup_geometry(config)
        nodes, elements, dims = generate_mesh(geom.nElem_x, geom.nElem_y, geom.nElem_z; dx = geom.dx, dy = geom.dy, dz = geom.dz)
        initial_target_count = size(elements, 1)
        
        if is_restart_active && length(density) != initial_target_count
            error("Restart Mismatch: Checkpoint density size ($(length(density))) != Generated Mesh size ($initial_target_count).")
        end
        
        domain_bounds = (min_pt=[0.0f0,0.0f0,0.0f0], len_x=geom.dx*geom.nElem_x, len_y=geom.dy*geom.nElem_y, len_z=geom.dz*geom.nElem_z)
        config["geometry"]["nElem_x_computed"] = geom.nElem_x
        config["geometry"]["nElem_y_computed"] = geom.nElem_y
        config["geometry"]["nElem_z_computed"] = geom.nElem_z
        config["geometry"]["dx_computed"] = geom.dx
        config["geometry"]["dy_computed"] = geom.dy
        config["geometry"]["dz_computed"] = geom.dz
        config["geometry"]["max_domain_dim"] = geom.max_domain_dim
        
        nNodes = size(nodes, 1)
        ndof = nNodes * 3
        bc_data = config["boundary_conditions"]
        forces_data = config["external_forces"]
        
        bc_indicator = Boundary.get_bc_indicator(nNodes, nodes, Vector{Any}(bc_data))
        F_external = zeros(Float32, ndof)
        Boundary.apply_external_forces!(F_external, Vector{Any}(forces_data), nodes, elements)
        Diagnostics.print_success("Boundary Conditions & External Forces Mapped.")

        E = Float32(config["material"]["E"])
        nu = Float32(config["material"]["nu"])
        material_density = Float32(get(config["material"], "material_density", 0.0))
        gravity_accel = Float32(get(config["material"], "gravity_acceleration", 9.81))
        delta_T = Float32(get(config["material"], "delta_temperature", 0.0))
        if abs(delta_T) > 1e-6; Diagnostics.print_info("THERMOELASTICITY ENABLED: Delta T = $delta_T"); end

        original_density = ones(Float32, size(elements, 1)) 
        protected_elements_mask = falses(size(elements, 1)) 
        alpha_field = zeros(Float32, size(elements, 1))

        if !is_restart_active
            density, original_density, protected_elements_mask, alpha_field = Configuration.initialize_density_field(nodes, elements, geom.shapes, config)
        else
            _, original_density, protected_elements_mask, alpha_field = Configuration.initialize_density_field(nodes, elements, geom.shapes, config)
        end
        
        opt_params = config["optimization_parameters"]
        min_density = Float32(get(opt_params, "min_density", 1.0e-3))
        max_density_clamp = Float32(get(opt_params, "density_clamp_max", 1.0))
        base_name = run_name 
        
        mesh_conf = get(config, "mesh_settings", Dict())
        
        nominal_iterations = get(config, "number_of_iterations", 30)
        annealing_iterations = round(Int, nominal_iterations * 0.30)
        total_iterations = nominal_iterations + annealing_iterations

        Diagnostics.print_banner("OPTIMIZATION SCHEDULE")
        println("    Nominal Phase:    Iterations 1 to $nominal_iterations")
        println("    Annealing Phase: Iterations $(nominal_iterations + 1) to $total_iterations")

        raw_active_target = get(mesh_conf, "final_target_of_active_elements", initial_target_count)
        final_target_active = isa(raw_active_target, String) ? parse(Int, replace(raw_active_target, "_" => "")) : Int(raw_active_target)
        max_growth_rate = Float64(get(mesh_conf, "max_growth_rate", 1.2))
        raw_bg_limit = get(mesh_conf, "max_background_elements", 800_000_000)
        hard_elem_limit = isa(raw_bg_limit, String) ? parse(Int, replace(raw_bg_limit, "_" => "")) : Int(raw_bg_limit)
        Diagnostics.print_info("Hard Element Limit: $(Base.format_bytes(hard_elem_limit * 100)) approx ($hard_elem_limit elems)")

        l1_stress_allowable = Float32(get(config["material"], "l1_stress_allowable", 1.0))
        if l1_stress_allowable == 0.0f0; l1_stress_allowable = 1.0f0; end
        
        internal_l1_allowable = l1_stress_allowable 
        U_full = zeros(Float32, ndof)
        density_change_metric = 1.0f0 
        filter_R = is_restart_active ? restart_radius : 0.0f0
        curr_threshold = is_restart_active ? restart_threshold : 0.0f0
        
        iter = start_iter
        keep_running = true
        is_annealing = false
        prev_compliance = 0.0f0
        convergence_streak = 0
        CONVERGENCE_TOL = 0.005 
        CONVERGENCE_DENSITY_TOL = 0.001 
        CONVERGENCE_REQUIRED_STREAK = 5 
        
        Diagnostics.print_banner("STARTING MAIN LOOP")
        Diagnostics.print_info("Log File: $log_filename")
        
        flush(stdout) 

        while keep_running
            iter_start_time = time()
            status_msg = "Nominal"
            current_target_active = final_target_active
            phase_refinement_needed = false
            gravity_scale = 0.0f0
            
            if iter <= nominal_iterations
                status_msg = "Nominal"
                is_annealing = false
                progress = (iter - 1) / Float64(nominal_iterations)
                
                growth_exponent = Float64(get(mesh_conf, "exponent_for_refinement_schedule", 2.0))
                growth_factor = progress ^ growth_exponent 
                
                target_interpolated = initial_target_count + (final_target_active - initial_target_count) * growth_factor
                current_target_active = round(Int, target_interpolated)
                current_active = count(d -> d > 0.01, density)
                nominal_ref_thresh = Float64(get(mesh_conf, "nominal_refinement_threshold", 0.8))
                if current_active < (current_target_active * nominal_ref_thresh)
                    phase_refinement_needed = true
                end
                gravity_scale = 0.0f0
            else
                status_msg = "Annealing"
                is_annealing = true 
                current_target_active = final_target_active
                current_active = count(d -> d > 0.01, density)
                if current_active < (final_target_active * 0.95)
                    phase_refinement_needed = true
                end
                gravity_scale = 1.0f0 
            end
            
            if phase_refinement_needed
                 prev_elem_count = size(elements, 1)
                 nodes, elements, density, alpha_field, dims = MeshRefiner.refine_mesh_and_fields(
                    nodes, elements, density, alpha_field, dims, current_target_active, domain_bounds;
                    max_growth_rate = max_growth_rate, hard_element_limit = hard_elem_limit
                )
                GC.gc()
                
                if size(elements, 1) > prev_elem_count
                    status_msg = "Refined"
                    
                    convergence_streak = 0
                    nElem_x_new, nElem_y_new, nElem_z_new = dims[1]-1, dims[2]-1, dims[3]-1
                    current_dx = domain_bounds.len_x / nElem_x_new
                    current_dy = domain_bounds.len_y / nElem_y_new
                    current_dz = domain_bounds.len_z / nElem_z_new
                    
                    config["geometry"]["nElem_x_computed"] = nElem_x_new
                    config["geometry"]["nElem_y_computed"] = nElem_y_new
                    config["geometry"]["nElem_z_computed"] = nElem_z_new
                    config["geometry"]["dx_computed"] = current_dx
                    config["geometry"]["dy_computed"] = current_dy
                    config["geometry"]["dz_computed"] = current_dz
                    
                    geom = (nElem_x=nElem_x_new, nElem_y=nElem_y_new, nElem_z=nElem_z_new, dx=current_dx, dy=current_dy, dz=current_dz, shapes=geom.shapes, actual_elem_count=size(elements, 1), max_domain_dim=geom.max_domain_dim)

                    Diagnostics.print_substep("[Refinement] Re-mapping Boundary Conditions & Forces...")
                    nNodes = size(nodes, 1)
                    ndof = nNodes * 3
                    bc_indicator = Boundary.get_bc_indicator(nNodes, nodes, Vector{Any}(bc_data))
                    F_external = zeros(Float32, ndof)
                    Boundary.apply_external_forces!(F_external, Vector{Any}(forces_data), nodes, elements)
                    _, original_density, protected_elements_mask, _ = Configuration.initialize_density_field(nodes, elements, geom.shapes, config)
                    Diagnostics.print_substep("[Refinement] Resetting solution guess.")
                    U_full = zeros(Float32, ndof)
                    TopologyOptimization.reset_filter_cache!()
                else
                    status_msg = "Skip"
                end
            end

            if iter > 1
                Threads.@threads for e in 1:size(elements, 1)
                    if protected_elements_mask[e]; density[e] = original_density[e]; end
                end
            end
            
            config["current_outer_iter"] = iter
            F_total = copy(F_external)
            
            if gravity_scale > 1e-4 && material_density > 1e-9
                 dx_curr = Float32(config["geometry"]["dx_computed"]); dy_curr = Float32(config["geometry"]["dy_computed"]); dz_curr = Float32(config["geometry"]["dz_computed"])
                 Boundary.add_self_weight!(F_total, density, material_density, gravity_scale, elements, dx_curr, dy_curr, dz_curr, gravity_accel)
            end
            if abs(delta_T) > 1e-6
                 Boundary.compute_global_thermal_forces!(F_total, nodes, elements, alpha_field, delta_T, E, nu, density)
            end
            
            Diagnostics.print_substep("FEA Solve (Iter $iter)")
            sol_tuple = Solver.solve_system(
                nodes, elements, E, nu, bc_indicator, F_total;
                density=density, config=config, min_stiffness_threshold=min_density, 
                prune_voids=true, u_prev=U_full 
            )
            U_new = sol_tuple[1]
            last_residual = sol_tuple[2]
            prec_used = sol_tuple[3]
            U_full = U_new
            
            if CUDA.functional(); GC.gc(); CUDA.reclaim(); end
            
            compliance = dot(F_total, U_full)
            strain_energy = 0.5 * compliance
            
            Diagnostics.print_substep("Calculating Stress Field...")
            t_stress = time()
            
            principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field = Stress.compute_stress_field(nodes, elements, U_full, E, nu, density; return_voigt=false)
            
            try
                if iter == 1
                    Diagnostics.print_info("Exporting INITIAL REFERENCE STATE (Iter 0)...")
                    do_bin_init = (save_bin_freq > 0); do_stl_init = (save_stl_freq > 0); do_vtk_init = (save_vtk_freq > 0)
                    if do_bin_init || do_stl_init || do_vtk_init
                        
                        Postprocessing.export_iteration_results(0, base_name, RESULTS_DIR, nodes, elements, U_full, F_total, bc_indicator, 
                                                                principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, 
                                                                principal_max_dir_field, principal_min_dir_field, 
                                                                density, E, geom; iso_threshold=Float32(iso_threshold), current_radius=Float32(filter_R), config=config, 
                                                                save_bin=do_bin_init, save_stl=do_stl_init, save_vtk=do_vtk_init)
                    end
                    if hard_stop_iter == 0; println(">>> HARD STOP: Stopping after background analysis (Iter 0)."); keep_running = false; break; end
                end
            catch e_export
                Diagnostics.print_warn("Initial export failed ($e_export). Proceeding with optimization.")
                Diagnostics.write_crash_log(crash_log_filename, "INITIAL_EXPORT", e_export, stacktrace(catch_backtrace()), iter, config, density)
            end
            
            active_stress_indices = findall(d -> d > 0.1f0, density)
            avg_l1_stress = isempty(active_stress_indices) ? 0.0f0 : Float32(mean(view(l1_stress_norm_field, active_stress_indices)))
            vol_total = length(density); active_non_soft = count(d -> d > min_density, density); vol_frac = sum(density) / vol_total
            
            target_avg_stress = l1_stress_allowable * 1.10f0
            
            if is_annealing && status_msg != "Refined"
                stress_ratio = avg_l1_stress / (target_avg_stress + Float32(1.0e-9))
                damping = (stress_ratio > 1.0f0) ? 0.5f0 : 0.1f0
                correction_factor = (1.0f0 / stress_ratio) ^ damping
                internal_l1_allowable *= correction_factor
                internal_l1_allowable = max(internal_l1_allowable, l1_stress_allowable * 0.05f0)
                internal_l1_allowable = min(internal_l1_allowable, l1_stress_allowable * 5.0f0)
                internal_l1_allowable = Float32(internal_l1_allowable)
                Diagnostics.print_substep("Adaptive Stress Control: Avg=$(round(avg_l1_stress, digits=3)) (Target $(round(target_avg_stress, digits=3))) -> Ratio $(round(stress_ratio, digits=2)) -> Adj. Allowable: $(round(internal_l1_allowable, digits=3))")
            end
            
            Diagnostics.print_substep("Topology Update & Filtering...")
            t_filter = time()
            
            res_tuple = TopologyOptimization.update_density!(
                density, l1_stress_norm_field, protected_elements_mask, E, internal_l1_allowable, 
                iter, nominal_iterations, 
                original_density, min_density, max_density_clamp, config, elements, is_annealing;
                force_no_cull = false 
            )
            
            density_change_metric, filter_R, curr_threshold = res_tuple
            
            if iter > 5 && status_msg != "Refined"
                rel_comp_change = abs(compliance - prev_compliance) / (prev_compliance + 1e-9)
                if rel_comp_change < CONVERGENCE_TOL && density_change_metric < CONVERGENCE_DENSITY_TOL
                    convergence_streak += 1
                    Diagnostics.print_info("Convergence Streak: $convergence_streak/$CONVERGENCE_REQUIRED_STREAK (Comp: $(round(rel_comp_change*100, digits=3))%, Rho: $(round(density_change_metric*100, digits=4))%)")
                else
                    convergence_streak = 0
                end
                
                if convergence_streak >= CONVERGENCE_REQUIRED_STREAK
                    if iter <= nominal_iterations
                        Diagnostics.print_info("Nominal Phase converged. Continuing...")
                    elseif iter < total_iterations
                        Diagnostics.print_info("Annealing Phase converged. Continuing...")
                    else
                          Diagnostics.print_success("Fully Converged. Stopping.")
                          keep_running = false
                    end
                end
            else
                convergence_streak = 0
            end
            prev_compliance = compliance
            
            iter_time = time() - iter_start_time
            cur_dims_str = "$(config["geometry"]["nElem_x_computed"])x$(config["geometry"]["nElem_y_computed"])x$(config["geometry"]["nElem_z_computed"])"
            
            Diagnostics.write_iteration_log(
                log_filename, iter, cur_dims_str, vol_total, active_non_soft, 
                filter_R, curr_threshold, compliance, strain_energy, avg_l1_stress, vol_frac, density_change_metric, 
                status_msg, iter_time, last_residual, prec_used
            )

            is_last_iter = (!keep_running) || (hard_stop_iter > 0 && iter >= hard_stop_iter) || (iter >= total_iterations)
            
            do_bin = (save_bin_freq > 0) && (iter % save_bin_freq == 0)
            do_stl = ((save_stl_freq > 0) && (iter % save_stl_freq == 0)) || is_last_iter
            do_vtk = (save_vtk_freq > 0) && (iter % save_vtk_freq == 0)
            
            should_export = do_bin || do_stl || do_vtk || is_last_iter 

            if should_export
                Diagnostics.print_substep("Exporting results...")
                try
                    Postprocessing.export_iteration_results(iter, base_name, RESULTS_DIR, nodes, elements, U_full, F_total, bc_indicator, 
                                                            principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, 
                                                            principal_max_dir_field, principal_min_dir_field, 
                                                            density, E, geom; iso_threshold=Float32(iso_threshold), current_radius=Float32(filter_R), config=config, save_bin=do_bin, save_stl=do_stl, save_vtk=do_vtk)
                catch e_export
                    Diagnostics.print_error("Post-processing failed at Iter $iter. Logged to crash_report. Continuing simulation.")
                    Diagnostics.write_crash_log(crash_log_filename, "ITER_EXPORT", e_export, stacktrace(catch_backtrace()), iter, config, density)
                end
            end
            
            if hard_stop_iter > 0 && iter >= hard_stop_iter; println(">>> HARD STOP: Reached target iteration $hard_stop_iter."); keep_running = false; break; end
            
            if iter >= total_iterations
                Diagnostics.print_success("Reached total iteration limit ($total_iterations).")
                keep_running = false
            end
            
            if CUDA.functional(); Helpers.clear_gpu_memory(); end
            iter += 1
            GC.gc()
            flush(stdout) 
        end
        Diagnostics.log_status("Finished.")
    end

end

function bootstrap()
    println(">>> [BOOTSTRAP] Parsing arguments and launching module...")
    flush(stdout)
    
    
    config_file = nothing
    if length(ARGS) >= 1
        config_file = ARGS[1]
    end

    HEXA.run_main(config_file)
end

bootstrap()
"// # FILE: .\src\Core\Boundary.jl";
// 
module Boundary 

using JSON 
using SparseArrays 
using LinearAlgebra 
using Base.Threads
using ..Element

export get_bc_indicator, reduce_system, apply_external_forces!, add_self_weight!, compute_global_thermal_forces!

""" 
    get_affected_nodes(spec, nodes) 

Returns an array of *final* node indices affected by this BC specification `spec`. 
""" 
function get_affected_nodes(spec::AbstractDict, nodes::Matrix{Float32}) 
      
    nNodes = size(nodes, 1) 

    # 1) If user gave "node" 
    if haskey(spec, "node") 
        raw = spec["node"] 
        if isa(raw, Integer) 
            idx = clamp(raw, 1, nNodes) 
            return [idx] 
        elseif isa(raw, AbstractVector) 
            node_list = Int[] 
            for r in raw 
                push!(node_list, clamp(r, 1, nNodes)) 
            end 
            return unique(node_list) 
        else 
            error("'node' must be an integer or an array of integers") 
        end 
    end 

    # 2) If user gave "location" 
    if haskey(spec, "location") 
        loc_array = spec["location"] 
        if length(loc_array) < 3 
            error("Location specification must have at least 3 components (x,y,z)") 
        end 
        return get_nodes_by_location(loc_array, nodes) 
    end 

    error("Specification must include either 'node' or 'location'") 
end 

""" 
    get_nodes_by_location(loc_array, nodes) 

Find nodes whose (x,y,z) coordinates match the "location" pattern. 
""" 
function get_nodes_by_location(loc_array::AbstractVector, nodes::Matrix{Float32}) 
    xvals = @view nodes[:, 1] 
    yvals = @view nodes[:, 2] 
    zvals = @view nodes[:, 3] 

    xmin, xmax = extrema(xvals) 
    ymin, ymax = extrema(yvals) 
    zmin, zmax = extrema(zvals) 

    xspec = loc_array[1] 
    yspec = loc_array[2] 
    zspec = loc_array[3] 

    xmask = interpret_location_component(xspec, xvals, xmin, xmax) 
    ymask = interpret_location_component(yspec, yvals, ymin, ymax) 
    zmask = interpret_location_component(zspec, zvals, zmin, zmax) 

    return findall(xmask .& ymask .& zmask) 
end 

""" 
    interpret_location_component(spec, coords, cmin, cmax) 
""" 
function interpret_location_component(spec, 
                                      coords::AbstractVector{Float32}, 
                                      cmin::Float32, cmax::Float32) 
    nNodes = length(coords) 
    mask = falses(nNodes) 
      
    tol = Float32(1e-4) * max(Float32(1.0), abs(cmax - cmin)) 

    if spec == ":" 
        return trues(nNodes) 
          
    elseif isa(spec, Number) 
        val = resolve_coordinate_value(spec, cmin, cmax) 
          
        @inbounds for i in 1:nNodes 
            if abs(coords[i] - val) <= tol 
                mask[i] = true 
            end 
        end 

    elseif isa(spec, String) && endswith(spec, "%") 
        frac = parse(Float32, replace(spec, "%"=>"")) / Float32(100.0) 
        frac = clamp(frac, Float32(0.0), Float32(1.0)) 
        val = Float32(cmin + frac*(cmax - cmin)) 
          
        @inbounds for i in 1:nNodes 
            if abs(coords[i] - val) <= tol 
                mask[i] = true 
            end 
        end 
          
    else 
        error("Invalid location component: $spec") 
    end 

    return mask 
end 

function resolve_coordinate_value(spec, cmin::Float32, cmax::Float32)
    if isa(spec, Number)
        if spec >= Float32(0.0) && spec <= Float32(1.0) 
            return Float32(cmin + spec*(cmax - cmin)) 
        else 
            return Float32(spec) 
        end
    elseif isa(spec, String) && endswith(spec, "%")
        frac = parse(Float32, replace(spec, "%"=>"")) / Float32(100.0) 
        frac = clamp(frac, Float32(0.0), Float32(1.0)) 
        return Float32(cmin + frac*(cmax - cmin))
    end
    return Float32(cmin) 
end

""" 
    get_bc_indicator(nNodes, nodes, bc_data; T=Float32) 
""" 
function get_bc_indicator(nNodes::Int, 
                          nodes::Matrix{Float32}, 
                          bc_data::Vector{Any};  
                          T::Type{<:AbstractFloat} = Float32) 

    bc_indicator = zeros(T, nNodes, 3) 
      
    for bc in bc_data 
        dofs = bc["DoFs"] 
          
        for dof in dofs 
            if dof < 1 || dof > 3 
                error("Invalid DoF index: $dof (must be 1..3).") 
            end 
        end 

        affected = get_affected_nodes(bc, nodes) 
        for nd in affected 
            for d in dofs 
                bc_indicator[nd, d] = one(T) 
            end 
        end 
    end 

    return bc_indicator 
end 

""" 
    reduce_system(K, F, bc_data, nodes, elements) 
""" 
function reduce_system(K::SparseMatrixCSC{Float32,Int}, 
                       F::Vector{Float32}, 
                       bc_data::Vector{Any},  
                       nodes::Matrix{Float32}, 
                       elements::Matrix{Int}) 

    nNodes = size(nodes, 1) 
    ndof    = 3*nNodes 
    constrained = falses(ndof) 

    for bc in bc_data 
        dofs = bc["DoFs"] 
        affected = get_affected_nodes(bc, nodes) 
          
        for nd in affected 
            for d in dofs 
                gdof = 3*(nd-1) + d 
                constrained[gdof] = true 
                F[gdof] = Float32(0.0)  
            end 
        end 
    end 

    free_indices = findall(!, constrained) 
    K_reduced = K[free_indices, free_indices] 
    F_reduced = F[free_indices] 
      
    return K_reduced, F_reduced, free_indices 
end 

function find_nearest_node(target_coords::Vector{Float32}, nodes::Matrix{Float32})
    nNodes = size(nodes, 1)
    best_idx = -1
    min_dist_sq = Inf32

    @inbounds for i in 1:nNodes
        dx = nodes[i, 1] - target_coords[1]
        dy = nodes[i, 2] - target_coords[2]
        dz = nodes[i, 3] - target_coords[3]
        dist_sq = dx*dx + dy*dy + dz*dz

        if dist_sq < (min_dist_sq - 1e-9)
            min_dist_sq = dist_sq
            best_idx = i
        elseif abs(dist_sq - min_dist_sq) <= 1e-9
            if nodes[i, 1] > nodes[best_idx, 1]
                best_idx = i
            elseif nodes[i, 1] == nodes[best_idx, 1]
                if nodes[i, 2] > nodes[best_idx, 2]
                    best_idx = i
                elseif nodes[i, 2] == nodes[best_idx, 2]
                    if nodes[i, 3] > nodes[best_idx, 3]
                        best_idx = i
                    end
                end
            end
        end
    end
    return best_idx
end

""" 
    apply_external_forces!(F, forces_data, nodes, elements) 

Processes external forces.
""" 
function apply_external_forces!(F::Vector{T}, 
                                 forces_data::Vector{Any},  
                                 nodes::Matrix{Float32}, 
                                 elements::Matrix{Int}) where T<:AbstractFloat 

    x_bounds = extrema(view(nodes, :, 1))
    y_bounds = extrema(view(nodes, :, 2))
    z_bounds = extrema(view(nodes, :, 3))

    println("Processing $(length(forces_data)) external forces...")

    for force in forces_data 
        
        force_name = get(force, "name", "Unnamed Force")
        
        affected_nodes = get_affected_nodes(force, nodes) 

        
        if isempty(affected_nodes) && haskey(force, "location")
            loc = force["location"]
            is_point_spec = all(x -> x != ":", loc)
            
            if is_point_spec
                tx = resolve_coordinate_value(loc[1], x_bounds[1], x_bounds[2])
                ty = resolve_coordinate_value(loc[2], y_bounds[1], y_bounds[2])
                tz = resolve_coordinate_value(loc[3], z_bounds[1], z_bounds[2])
                target = Float32[tx, ty, tz]

                nearest_idx = find_nearest_node(target, nodes)
                if nearest_idx != -1
                    affected_nodes = [nearest_idx]
                    println("   -> Force '$force_name': mapped to nearest node #$nearest_idx")
                end
            end
        else
            println("   -> Force '$force_name': mapped to $(length(affected_nodes)) nodes")
        end
        
        if isempty(affected_nodes) 
            continue 
        end 
          
        f_raw = force["F"] 
        f_arr = zeros(T, 3) 
        len_to_copy = min(length(f_raw), 3) 
        f_arr[1:len_to_copy] = T.(f_raw[1:len_to_copy])  

        # If user gave "location", we spread the total force among the matched nodes 
        scale_factor = haskey(force, "location") ? (one(T) / length(affected_nodes)) : one(T) 

        for nd in affected_nodes 
            for i in 1:3 
                global_dof = 3*(nd-1) + i 
                F[global_dof] += scale_factor * f_arr[i] 
            end 
        end 
    end 

    return F 
end 

"""
    add_self_weight!(F, density, material_density, gravity_scale, elements, dx, dy, dz, g_accel)

Calculates the gravitational body force for each element and distributes it 
to the element nodes. 
    Force_elem = Volume * rho_material * rho_element * g_accel
    Direction = Negative Y
"""
function add_self_weight!(F::Vector{T}, 
                          density::Vector{T}, 
                          material_density::T, 
                          gravity_scale::T,
                          elements::Matrix{Int},
                          dx::T, dy::T, dz::T,
                          g_accel::T) where T<:AbstractFloat

    elem_vol = dx * dy * dz
    
    
    base_weight = elem_vol * material_density * g_accel * gravity_scale
    
    
    node_factor = base_weight / T(8.0)
    
    
    
    
    n_threads_safe = Threads.nthreads() + 16 
    ndof = length(F)
    F_local = [zeros(T, ndof) for _ in 1:n_threads_safe]

    nElem = length(density)

    Threads.@threads for e in 1:nElem
        rho = density[e]
        if rho > 1e-6 
            tid = Threads.threadid()
            
            
            if tid > n_threads_safe
                tid = 1 
            end
            
            
            fy_node = -1.0f0 * node_factor * rho
            
            conn = view(elements, e, :)
            for i in 1:8
                node_idx = conn[i]
                
                gdof_y = 3*(node_idx-1) + 2
                @inbounds F_local[tid][gdof_y] += fy_node
            end
        end
    end

    
    for t in 1:n_threads_safe
        F .+= F_local[t]
    end
end

"""
    compute_global_thermal_forces!(F_total, nodes, elements, alpha_field, delta_T, E, nu, density)

Calculates thermal forces for all elements and adds them to the total force vector.
"""
function compute_global_thermal_forces!(F_total::Vector{Float32}, 
                                        nodes::Matrix{Float32}, 
                                        elements::Matrix{Int},
                                        alpha_field::Vector{Float32},
                                        delta_T::Float32, 
                                        E::Float32, 
                                        nu::Float32, 
                                        density::Vector{Float32})

    if abs(delta_T) < 1e-6
        return
    end

    nElem = size(elements, 1)
    ndof = length(F_total)
    
    
    n_threads_safe = Threads.nthreads() + 16
    F_local = [zeros(Float32, ndof) for _ in 1:n_threads_safe]

    Threads.@threads for e in 1:nElem
        
        if density[e] > 1e-4 && abs(alpha_field[e]) > 1e-9
            tid = Threads.threadid()
            if tid > n_threads_safe; tid = 1; end
            
            conn = view(elements, e, :)
            el_nodes = nodes[conn, :]
            
            # Note: We scale Young's modulus by density (SIMP) for stiffness, 
            # but for thermal force f = B' D e_th, D scales with E.
            
            
            f_elem = Element.compute_element_thermal_force(el_nodes, E * density[e], nu, alpha_field[e], delta_T)
            
            
            for i in 1:8
                node_idx = conn[i]
                base_dof = 3 * (node_idx - 1)
                @inbounds F_local[tid][base_dof + 1] += f_elem[3*(i-1) + 1]
                @inbounds F_local[tid][base_dof + 2] += f_elem[3*(i-1) + 2]
                @inbounds F_local[tid][base_dof + 3] += f_elem[3*(i-1) + 3]
            end
        end
    end

    
    for t in 1:n_threads_safe
        F_total .+= F_local[t]
    end
end

end
"// # FILE: .\src\Core\Element.jl";
// 

module Element

using LinearAlgebra
export NAT_COORDS, shape_functions, material_matrix, hex_element_stiffness, get_canonical_stiffness, get_scalar_canonical_matrices, compute_element_thermal_force

const NAT_COORDS = Float32[
    -1 -1 -1;
     1 -1 -1;
     1  1 -1;
    -1  1 -1;
    -1 -1  1;
     1 -1  1;
     1  1  1;
    -1  1  1
]

"""
    shape_functions(xi, eta, zeta)
Computes the trilinear shape functions and their derivatives.
"""
function shape_functions(xi, eta, zeta)
    N  = zeros(Float32, 8)
    dN = zeros(Float32, 8, 3)
      
    p1 = Float32(0.125)
      
    @inbounds for i in 1:8
        xi_i, eta_i, zeta_i = NAT_COORDS[i,1], NAT_COORDS[i,2], NAT_COORDS[i,3]
        
        term_xi   = (1.0f0 + xi*xi_i)
        term_eta  = (1.0f0 + eta*eta_i)
        term_zeta = (1.0f0 + zeta*zeta_i)
        
        N[i] = p1 * term_xi * term_eta * term_zeta
        
        dN[i,1] = p1 * xi_i * term_eta * term_zeta
        dN[i,2] = p1 * term_xi * eta_i * term_zeta
        dN[i,3] = p1 * term_xi * term_eta * zeta_i
    end
    return N, dN
end

function material_matrix(E::Float32, nu::Float32)
    inv_den = 1.0f0 / ((1.0f0 + nu) * (1.0f0 - 2.0f0 * nu))
    factor = E * inv_den
      
    c1 = (1.0f0 - nu) * factor
    c2 = nu * factor
    
    
    c3_isotropic = ((1.0f0 - 2.0f0 * nu) / 2.0f0) * factor
    
    
    
    
    shear_reduction = 1.0f0 
    
    c3 = c3_isotropic * shear_reduction
      
    D = zeros(Float32, 6, 6)
    D[1,1] = c1; D[1,2] = c2; D[1,3] = c2
    D[2,1] = c2; D[2,2] = c1; D[2,3] = c2
    D[3,1] = c2; D[3,2] = c2; D[3,3] = c1
      
    D[4,4] = c3
    D[5,5] = c3
    D[6,6] = c3
    return D
end

function hex_element_stiffness(nodes::AbstractMatrix{Float32}, E::Float32, nu::Float32)
    D = material_matrix(E, nu)
    ke = zeros(Float32, 24, 24)
    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]
    B = zeros(Float32, 6, 24)

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        _, dN_dxi = shape_functions(xi, eta, zeta)
        J    = transpose(dN_dxi) * nodes
        detJ = det(J)
        if detJ <= 0.0f0 
            error("Non-positive Jacobian detected.")
        end
        invJ = inv(J)
        dN_dx = dN_dxi * transpose(invJ)

        fill!(B, 0.0f0)
        for i in 1:8
            idx = 3*(i-1)
            dN_i = view(dN_dx, i, :)
            B[1, idx+1] = dN_i[1]; B[2, idx+2] = dN_i[2]; B[3, idx+3] = dN_i[3]
            B[4, idx+1] = dN_i[2]; B[4, idx+2] = dN_i[1]
            B[5, idx+2] = dN_i[3]; B[5, idx+3] = dN_i[2]
            B[6, idx+1] = dN_i[3]; B[6, idx+3] = dN_i[1]
        end
        ke .+= transpose(B) * D * B * detJ
    end
    return ke
end

function get_canonical_stiffness(dx::Float32, dy::Float32, dz::Float32, nu::Float32)
    nodes = Float32[
        0.0 0.0 0.0; dx  0.0 0.0; dx  dy  0.0; 0.0 dy  0.0;
        0.0 0.0 dz;  dx  0.0 dz;  dx  dy  dz;  0.0 dy  dz
    ]
    nodes .-= [dx/2 dy/2 dz/2]
    return hex_element_stiffness(nodes, 1.0f0, nu)
end

function get_scalar_canonical_matrices(dx::Float32, dy::Float32, dz::Float32)
    nodes = Float32[
        -dx/2 -dy/2 -dz/2; dx/2 -dy/2 -dz/2; dx/2  dy/2 -dz/2; -dx/2  dy/2 -dz/2;
        -dx/2 -dy/2  dz; dx/2 -dy/2  dz; dx/2  dy/2  dz; -dx/2  dy/2  dz
    ]
    Ke = zeros(Float32, 8, 8)
    Me = zeros(Float32, 8, 8)
    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        N, dN_dxi = shape_functions(xi, eta, zeta)
        J = transpose(dN_dxi) * nodes
        detJ = det(J)
        invJ = inv(J)
        dN_dx = dN_dxi * transpose(invJ)
        weight = detJ 
        Ke .+= (dN_dx * transpose(dN_dx)) .* weight
        Me .+= (N * transpose(N)) .* weight
    end
    return Ke, Me
end

function compute_element_thermal_force(nodes::AbstractMatrix{Float32}, E::Float32, nu::Float32, alpha::Float32, delta_T::Float32)
    f_th = zeros(Float32, 24)
    
    if abs(alpha) < 1e-9 || abs(delta_T) < 1e-9
        return f_th
    end

    D = material_matrix(E, nu)
    
    thermal_strain = zeros(Float32, 6)
    epsilon_mag = alpha * delta_T
    thermal_strain[1] = epsilon_mag
    thermal_strain[2] = epsilon_mag
    thermal_strain[3] = epsilon_mag
    
    sigma_th = D * thermal_strain

    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]
    B = zeros(Float32, 6, 24)

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        _, dN_dxi = shape_functions(xi, eta, zeta)
        J    = transpose(dN_dxi) * nodes
        detJ = det(J)
        invJ = inv(J)
        dN_dx = dN_dxi * transpose(invJ)

        fill!(B, 0.0f0)
        for i in 1:8
            idx = 3*(i-1)
            dN_i = view(dN_dx, i, :)
            B[1, idx+1] = dN_i[1]; B[2, idx+2] = dN_i[2]; B[3, idx+3] = dN_i[3]
            B[4, idx+1] = dN_i[2]; B[4, idx+2] = dN_i[1]
            B[5, idx+2] = dN_i[3]; B[5, idx+3] = dN_i[2]
            B[6, idx+1] = dN_i[3]; B[6, idx+3] = dN_i[1]
        end
        
        f_th .+= transpose(B) * sigma_th * detJ
    end
    
    return f_th
end

end
"// # FILE: .\src\Core\Stress.jl";
module Stress 

using LinearAlgebra 
using Base.Threads
using CUDA
using Printf
using ..Element 

export compute_stress_field 

const GAUSS_VAL = 0.577350269f0 

"""
    estimate_stress_vram_required(nNodes, nElem, use_voigt)

Estimates total VRAM needed for stress calculation in bytes.
"""
function estimate_stress_vram_required(nNodes::Int, nElem::Int, use_voigt::Bool)
    bytes_per_float32 = 4
    
    
    nodes_mem = nNodes * 3 * bytes_per_float32
    elements_mem = nElem * 8 * 4  
    U_mem = nNodes * 3 * bytes_per_float32
    density_mem = nElem * bytes_per_float32
    
    
    principal_mem = nElem * 3 * bytes_per_float32
    vonmises_mem = nElem * bytes_per_float32
    l1_mem = nElem * bytes_per_float32
    dir_max_mem = nElem * 3 * bytes_per_float32
    dir_min_mem = nElem * 3 * bytes_per_float32
    voigt_mem = use_voigt ? (nElem * 6 * bytes_per_float32) : 0
    
    
    workspace_mem = nNodes * 3 * bytes_per_float32
    
    total = nodes_mem + elements_mem + U_mem + density_mem +
            principal_mem + vonmises_mem + l1_mem + 
            dir_max_mem + dir_min_mem + voigt_mem + workspace_mem
    
    return total
end

"""
    compute_element_stress(element_nodes, element_disp, E, nu)

CPU implementation - computes stress tensor for a single element.
"""
function compute_element_stress(element_nodes::Array{Float32,2}, 
                                element_disp::Array{Float32,1}, 
                                E::Float32, nu::Float32) 
    D = Element.material_matrix(E, nu) 
    
    xi, eta, zeta = 0.0f0, 0.0f0, 0.0f0 
    inv8 = 0.125f0 
    
    j11 = (-element_nodes[1,1] + element_nodes[2,1] + element_nodes[3,1] - element_nodes[4,1] - element_nodes[5,1] + element_nodes[6,1] + element_nodes[7,1] - element_nodes[8,1]) * inv8
    j12 = (-element_nodes[1,2] + element_nodes[2,2] + element_nodes[3,2] - element_nodes[4,2] - element_nodes[5,2] + element_nodes[6,2] + element_nodes[7,2] - element_nodes[8,2]) * inv8
    j13 = (-element_nodes[1,3] + element_nodes[2,3] + element_nodes[3,3] - element_nodes[4,3] - element_nodes[5,3] + element_nodes[6,3] + element_nodes[7,3] - element_nodes[8,3]) * inv8

    j21 = (-element_nodes[1,1] - element_nodes[2,1] + element_nodes[3,1] + element_nodes[4,1] - element_nodes[5,1] - element_nodes[6,1] + element_nodes[7,1] + element_nodes[8,1]) * inv8
    j22 = (-element_nodes[1,2] - element_nodes[2,2] + element_nodes[3,2] + element_nodes[4,2] - element_nodes[5,2] - element_nodes[6,2] + element_nodes[7,2] + element_nodes[8,2]) * inv8
    j23 = (-element_nodes[1,3] - element_nodes[2,3] + element_nodes[3,3] + element_nodes[4,3] - element_nodes[5,3] - element_nodes[6,3] + element_nodes[7,3] + element_nodes[8,3]) * inv8
    
    j31 = (-element_nodes[1,1] - element_nodes[2,1] - element_nodes[3,1] - element_nodes[4,1] + element_nodes[5,1] + element_nodes[6,1] + element_nodes[7,1] + element_nodes[8,1]) * inv8
    j32 = (-element_nodes[1,2] - element_nodes[2,2] - element_nodes[3,2] - element_nodes[4,2] + element_nodes[5,2] + element_nodes[6,2] + element_nodes[7,2] + element_nodes[8,2]) * inv8
    j33 = (-element_nodes[1,3] - element_nodes[2,3] - element_nodes[3,3] - element_nodes[4,3] + element_nodes[5,3] + element_nodes[6,3] + element_nodes[7,3] + element_nodes[8,3]) * inv8

    detJ = j11*(j22*j33 - j23*j32) - j12*(j21*j33 - j23*j31) + j13*(j21*j32 - j22*j31)
    if detJ <= 1.0e-9; detJ = 1.0f0; end
    invDet = 1.0f0 / detJ

    Jinv11 =  (j22*j33 - j23*j32) * invDet
    Jinv12 = -(j12*j33 - j13*j32) * invDet
    Jinv13 =  (j12*j23 - j13*j22) * invDet
    
    Jinv21 = -(j21*j33 - j23*j31) * invDet
    Jinv22 =  (j11*j33 - j13*j31) * invDet
    Jinv23 = -(j11*j23 - j13*j21) * invDet
    
    Jinv31 =  (j21*j32 - j22*j31) * invDet
    Jinv32 = -(j11*j32 - j12*j31) * invDet
    Jinv33 =  (j11*j22 - j12*j21) * invDet

    B = zeros(Float32, 6, 24)
    
    dNi_dxi  = Float32[-0.125,  0.125,  0.125, -0.125, -0.125,  0.125,  0.125, -0.125]
    dNi_deta = Float32[-0.125, -0.125,  0.125,  0.125, -0.125, -0.125,  0.125,  0.125]
    dNi_dzet = Float32[-0.125, -0.125, -0.125, -0.125,  0.125,  0.125,  0.125,  0.125]
    
    for i in 1:8
        dN_dx = dNi_dxi[i]*Jinv11 + dNi_deta[i]*Jinv21 + dNi_dzet[i]*Jinv31
        dN_dy = dNi_dxi[i]*Jinv12 + dNi_deta[i]*Jinv22 + dNi_dzet[i]*Jinv32
        dN_dz = dNi_dxi[i]*Jinv13 + dNi_deta[i]*Jinv23 + dNi_dzet[i]*Jinv33
        
        idx = 3*(i-1) + 1
        B[1, idx]   = dN_dx; B[2, idx+1] = dN_dy; B[3, idx+2] = dN_dz
        B[4, idx]   = dN_dy; B[4, idx+1] = dN_dx
        B[5, idx+1] = dN_dz; B[5, idx+2] = dN_dy
        B[6, idx]   = dN_dz; B[6, idx+2] = dN_dx
    end

    strain = B * element_disp 
    stress_voigt = D * strain 

     = zeros(Float32, 3, 3) 
    [1,1] = stress_voigt[1]; [2,2] = stress_voigt[2]; [3,3] = stress_voigt[3]       
    [1,2] = stress_voigt[4]; [2,1] = stress_voigt[4]       
    [2,3] = stress_voigt[5]; [3,2] = stress_voigt[5]       
    [1,3] = stress_voigt[6]; [3,1] = stress_voigt[6]       
    return  
end 

"""
    compute_principal_data()

CPU implementation - eigenvalue decomposition of stress tensor.
"""
function compute_principal_data(::Matrix{Float32}) 
    F = eigen()
    perm = sortperm(F.values, rev=true)
    principal_stresses = F.values[perm]
    principal_vectors  = F.vectors[:, perm]
    max_dir = principal_vectors[:, 1]
    min_dir = principal_vectors[:, 3] 

    xx, yy, zz = [1,1], [2,2], [3,3]
    xy, yz, xz = [1,2], [2,3], [1,3]
    vm = sqrt(0.5f0 * ((xx-yy)^2 + (yy-zz)^2 + (zz-xx)^2) + 3.0f0*(xy^2 + yz^2 + xz^2))  

    return principal_stresses, vm, max_dir, min_dir
end 


@inline function eigen3x3_device(s11, s22, s33, s12, s23, s13)
    v11, v12, v13 = 1.0f0, 0.0f0, 0.0f0
    v21, v22, v23 = 0.0f0, 1.0f0, 0.0f0
    v31, v32, v33 = 0.0f0, 0.0f0, 1.0f0
    
    @fastmath for iter in 1:12
        a12 = abs(s12); a23 = abs(s23); a13 = abs(s13)
        if max(a12, a23, a13) < 1.0e-9; break; end
        
        h = s12; g = 100.0f0 * abs(h)
        if abs(s11) + g != abs(s11) || abs(s22) + g != abs(s22)
            theta = 0.5f0 * (s22 - s11) / h
            t = 1.0f0 / (abs(theta) + sqrt(theta^2 + 1.0f0))
            if theta < 0.0f0; t = -t; end
            c = 1.0f0 / sqrt(t^2 + 1.0f0); s = t * c; tau = s / (1.0f0 + c)
            s11 -= t * s12; s22 += t * s12; s12 = 0.0f0
            tmp = s13; s13 -= s * (s23 + tau * s13); s23 += s * (tmp - tau * s23)
            tmp = v11; v11 -= s * (v12 + tau * v11); v12 += s * (tmp - tau * v12)
            tmp = v21; v21 -= s * (v22 + tau * v21); v22 += s * (tmp - tau * v22)
            tmp = v31; v31 -= s * (v32 + tau * v31); v32 += s * (tmp - tau * v32)
        end

        h = s13; g = 100.0f0 * abs(h)
        if abs(s11) + g != abs(s11) || abs(s33) + g != abs(s33)
            theta = 0.5f0 * (s33 - s11) / h
            t = 1.0f0 / (abs(theta) + sqrt(theta^2 + 1.0f0))
            if theta < 0.0f0; t = -t; end
            c = 1.0f0 / sqrt(t^2 + 1.0f0); s = t * c; tau = s / (1.0f0 + c)
            s11 -= t * s13; s33 += t * s13; s13 = 0.0f0
            tmp = s12; s12 -= s * (s23 + tau * s12); s23 += s * (tmp - tau * s23)
            tmp = v11; v11 -= s * (v13 + tau * v11); v13 += s * (tmp - tau * v13)
            tmp = v21; v21 -= s * (v23 + tau * v21); v23 += s * (tmp - tau * v23)
            tmp = v31; v31 -= s * (v33 + tau * v31); v33 += s * (tmp - tau * v33)
        end

        h = s23; g = 100.0f0 * abs(h)
        if abs(s22) + g != abs(s22) || abs(s33) + g != abs(s33)
            theta = 0.5f0 * (s33 - s22) / h
            t = 1.0f0 / (abs(theta) + sqrt(theta^2 + 1.0f0))
            if theta < 0.0f0; t = -t; end
            c = 1.0f0 / sqrt(t^2 + 1.0f0); s = t * c; tau = s / (1.0f0 + c)
            s22 -= t * s23; s33 += t * s23; s23 = 0.0f0
            tmp = s12; s12 -= s * (s13 + tau * s12); s13 += s * (tmp - tau * s13)
            tmp = v12; v12 -= s * (v13 + tau * v12); v13 += s * (tmp - tau * v13)
            tmp = v22; v22 -= s * (v23 + tau * v22); v23 += s * (tmp - tau * v23)
            tmp = v32; v32 -= s * (v33 + tau * v32); v33 += s * (tmp - tau * v33)
        end
    end
    
    if s11 < s22; t=s11; s11=s22; s22=t; t=v11; v11=v12; v12=t; t=v21; v21=v22; v22=t; t=v31; v31=v32; v32=t; end
    if s22 < s33; t=s22; s22=s33; s33=t; t=v12; v12=v13; v13=t; t=v22; v22=v23; v23=t; t=v32; v32=v33; v33=t; end
    if s11 < s22; t=s11; s11=s22; s22=t; t=v11; v11=v12; v12=t; t=v21; v21=v22; v22=t; t=v31; v31=v32; v32=t; end
    
    return s11, s22, s33, v11, v21, v31, v13, v23, v33
end

function stress_kernel!(principal_field, vonmises_field, voigt_field, l1_norm_field, dir_max_field, dir_min_field,
                        nodes, elements, U, density, E, nu, nElem, save_voigt)
    e = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if e > nElem; return; end

    dens = density[e]
    
    @fastmath if dens < 1.0e-6
        @inbounds begin
            principal_field[1, e] = 0.0f0
            principal_field[2, e] = 0.0f0
            principal_field[3, e] = 0.0f0
            vonmises_field[e] = 0.0f0
            l1_norm_field[e] = 0.0f0
            dir_max_field[1, e] = 0.0f0; dir_max_field[2, e] = 0.0f0; dir_max_field[3, e] = 0.0f0
            dir_min_field[1, e] = 0.0f0; dir_min_field[2, e] = 0.0f0; dir_min_field[3, e] = 0.0f0
            if save_voigt
                voigt_field[1,e]=0; voigt_field[2,e]=0; voigt_field[3,e]=0
                voigt_field[4,e]=0; voigt_field[5,e]=0; voigt_field[6,e]=0
            end
        end
        return
    end
    
    E_loc = @fastmath E * dens
    
    j11, j12, j13 = 0.0f0, 0.0f0, 0.0f0
    j21, j22, j23 = 0.0f0, 0.0f0, 0.0f0
    j31, j32, j33 = 0.0f0, 0.0f0, 0.0f0
    
    @inbounds for i in 1:8
        nid = elements[e, i]
        nx = nodes[nid, 1]; ny = nodes[nid, 2]; nz = nodes[nid, 3]
        
        xi_val = (i==2 || i==3 || i==6 || i==7) ? 0.125f0 : -0.125f0
        eta_val = (i==3 || i==4 || i==7 || i==8) ? 0.125f0 : -0.125f0
        zet_val = (i>=5) ? 0.125f0 : -0.125f0
        
        j11 += xi_val * nx; j12 += xi_val * ny; j13 += xi_val * nz
        j21 += eta_val * nx; j22 += eta_val * ny; j23 += eta_val * nz
        j31 += zet_val * nx; j32 += zet_val * ny; j33 += zet_val * nz
    end
    
    @fastmath begin
        detJ = j11*(j22*j33 - j23*j32) - j12*(j21*j33 - j23*j31) + j13*(j21*j32 - j22*j31)
        if detJ <= 1.0e-12; detJ = 1.0f0; end
        invDet = 1.0f0 / detJ
        
        Jinv11 =  (j22*j33 - j23*j32) * invDet; Jinv12 = -(j12*j33 - j13*j32) * invDet; Jinv13 =  (j12*j23 - j13*j22) * invDet
        Jinv21 = -(j21*j33 - j23*j31) * invDet; Jinv22 =  (j11*j33 - j13*j31) * invDet; Jinv23 = -(j11*j23 - j13*j21) * invDet
        Jinv31 =  (j21*j32 - j22*j31) * invDet; Jinv32 = -(j11*j32 - j12*j31) * invDet; Jinv33 =  (j11*j22 - j12*j21) * invDet
    end

    eps_xx, eps_yy, eps_zz = 0.0f0, 0.0f0, 0.0f0
    gam_xy, gam_yz, gam_xz = 0.0f0, 0.0f0, 0.0f0
    
    @inbounds for i in 1:8
        nid = elements[e, i]
        base = 3*(nid-1)
        ux = U[base+1]; uy = U[base+2]; uz = U[base+3]
        
        dN_dxi = (i==2 || i==3 || i==6 || i==7) ? 0.125f0 : -0.125f0
        dN_deta = (i==3 || i==4 || i==7 || i==8) ? 0.125f0 : -0.125f0
        dN_dzet = (i>=5) ? 0.125f0 : -0.125f0
        
        dN_dx = dN_dxi*Jinv11 + dN_deta*Jinv21 + dN_dzet*Jinv31
        dN_dy = dN_dxi*Jinv12 + dN_deta*Jinv22 + dN_dzet*Jinv32
        dN_dz = dN_dxi*Jinv13 + dN_deta*Jinv23 + dN_dzet*Jinv33
        
        eps_xx += dN_dx * ux
        eps_yy += dN_dy * uy
        eps_zz += dN_dz * uz
        gam_xy += dN_dy * ux + dN_dx * uy
        gam_yz += dN_dz * uy + dN_dy * uz
        gam_xz += dN_dz * ux + dN_dx * uz
    end
    
    @fastmath begin
        fact = E_loc / ((1.0f0 + nu) * (1.0f0 - 2.0f0 * nu))
        c1 = (1.0f0 - nu) * fact
        c2 = nu * fact
        c3 = (0.5f0 - nu) * fact 
        
        sig_xx = c1*eps_xx + c2*eps_yy + c2*eps_zz
        sig_yy = c2*eps_xx + c1*eps_yy + c2*eps_zz
        sig_zz = c2*eps_xx + c2*eps_yy + c1*eps_zz
        sig_xy = c3 * gam_xy 
        sig_yz = c3 * gam_yz
        sig_xz = c3 * gam_xz
    end
    
    if save_voigt
        @inbounds begin
            voigt_field[1, e] = sig_xx
            voigt_field[2, e] = sig_yy
            voigt_field[3, e] = sig_zz
            voigt_field[4, e] = sig_xy
            voigt_field[5, e] = sig_yz
            voigt_field[6, e] = sig_xz
        end
    end
    
    vm_sq = 0.5f0 * ((sig_xx-sig_yy)^2 + (sig_yy-sig_zz)^2 + (sig_zz-sig_xx)^2) + 3.0f0 * (sig_xy^2 + sig_yz^2 + sig_xz^2)
    vm = sqrt(max(0.0f0, vm_sq))
    @inbounds vonmises_field[e] = vm
    
    s11, s22, s33, v1x, v1y, v1z, v3x, v3y, v3z = eigen3x3_device(sig_xx, sig_yy, sig_zz, sig_xy, sig_yz, sig_xz)
    
    @inbounds begin
        principal_field[1, e] = s11
        principal_field[2, e] = s22
        principal_field[3, e] = s33
        
        dir_max_field[1, e] = v1x
        dir_max_field[2, e] = v1y
        dir_max_field[3, e] = v1z

        dir_min_field[1, e] = v3x
        dir_min_field[2, e] = v3y
        dir_min_field[3, e] = v3z
        
        l1_norm_field[e] = abs(s11) + abs(s22) + abs(s33)
    end
    return nothing
end

"""
    compute_stress_field_cpu(nodes, elements, U, E, nu, density; return_voigt)

CPU fallback implementation using multi-threading.
"""
function compute_stress_field_cpu(nodes::Matrix{Float32}, elements::Matrix{Int}, 
                                   U::AbstractVector, E::Float32, nu::Float32, 
                                   density::Vector{Float32}; return_voigt::Bool=true)
    
    nElem = size(elements, 1) 
    U_f32 = (eltype(U) == Float32) ? U : Float32.(U)

    principal_field          = zeros(Float32, 3, nElem) 
    vonmises_field           = zeros(Float32, nElem) 
    l1_stress_norm_field     = zeros(Float32, nElem)  
    principal_max_dir_field  = zeros(Float32, 3, nElem)
    principal_min_dir_field  = zeros(Float32, 3, nElem)
    full_stress_voigt = return_voigt ? zeros(Float32, 6, nElem) : zeros(Float32, 0, 0)

    Threads.@threads for e in 1:nElem 
        if density[e] > 1e-6
            conn = elements[e, :] 
            element_nodes = nodes[conn, :] 
            
            element_disp = zeros(Float32, 24) 
            for i in 1:8 
                base_idx = 3*(conn[i]-1)
                element_disp[3*(i-1)+1] = U_f32[base_idx+1]
                element_disp[3*(i-1)+2] = U_f32[base_idx+2]
                element_disp[3*(i-1)+3] = U_f32[base_idx+3]
            end 

            E_local = E * density[e] 
             = compute_element_stress(element_nodes, element_disp, E_local, nu) 
            
            (principal, vm, max_dir, min_dir) = compute_principal_data() 
        
            l1_norm = abs(principal[1]) + abs(principal[2]) + abs(principal[3]) 
                
            principal_field[:, e] = principal 
            vonmises_field[e]        = vm 
            l1_stress_norm_field[e] = l1_norm  
            principal_max_dir_field[:, e] = max_dir
            principal_min_dir_field[:, e] = min_dir

            if return_voigt
                full_stress_voigt[:, e] .= ([1,1], [2,2], [3,3], [1,2], [2,3], [1,3]) 
            end
        end
    end 
    
    return principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field
end

"""
    compute_stress_field(nodes, elements, U, E, nu, density; return_voigt)

**HYBRID IMPLEMENTATION**
Automatically selects GPU or CPU based on available VRAM.
"""
function compute_stress_field(nodes::Matrix{Float32}, elements::Matrix{Int}, 
                              U::AbstractVector, E::Float32, nu::Float32, 
                              density::Vector{Float32}; return_voigt::Bool=true) 
    
    nElem = size(elements, 1) 
    nNodes = size(nodes, 1)
    
    
    required_vram = estimate_stress_vram_required(nNodes, nElem, return_voigt)
    
    use_gpu = false
    if CUDA.functional()
        available_vram = CUDA.available_memory()
        vram_threshold = available_vram * 0.75  
        
        req_gb = required_vram / 1024^3
        avail_gb = available_vram / 1024^3
        
        if required_vram < vram_threshold
            use_gpu = true
            println(@sprintf("   [Stress] GPU Mode: %.2f GB required / %.2f GB available", req_gb, avail_gb))
        else
            println(@sprintf("   [Stress] CPU Mode: %.2f GB required > %.2f GB available (%.0f%% threshold)", 
                           req_gb, avail_gb, 75.0))
        end
    else
        println("   [Stress] CPU Mode: CUDA not functional")
    end
    
    
    if use_gpu
        
        U_f32 = (eltype(U) == Float32) ? U : Float32.(U)
        
        principal_field          = zeros(Float32, 3, nElem) 
        vonmises_field           = zeros(Float32, nElem) 
        l1_stress_norm_field     = zeros(Float32, nElem)  
        principal_max_dir_field  = zeros(Float32, 3, nElem)
        principal_min_dir_field  = zeros(Float32, 3, nElem)
        full_stress_voigt = return_voigt ? zeros(Float32, 6, nElem) : zeros(Float32, 0, 0)
        
        
        nodes_gpu    = CuArray(nodes)
        elements_gpu = CuArray(Int32.(elements)) 
        U_gpu        = CuArray(U_f32)
        density_gpu  = CuArray(density)
        
        principal_gpu = CUDA.zeros(Float32, 3, nElem)
        vonmises_gpu  = CUDA.zeros(Float32, nElem)
        l1_gpu        = CUDA.zeros(Float32, nElem)
        dir_max_gpu   = CUDA.zeros(Float32, 3, nElem)
        dir_min_gpu   = CUDA.zeros(Float32, 3, nElem)
        voigt_gpu     = return_voigt ? CUDA.zeros(Float32, 6, nElem) : CUDA.zeros(Float32, 1, 1)
        
        threads = 256
        blocks = cld(nElem, threads)
        
        @cuda threads=threads blocks=blocks stress_kernel!(
            principal_gpu, vonmises_gpu, voigt_gpu, l1_gpu, dir_max_gpu, dir_min_gpu,
            nodes_gpu, elements_gpu, U_gpu, density_gpu, E, nu, nElem, return_voigt
        )
        CUDA.synchronize()
        
        
        copyto!(principal_field, principal_gpu)
        copyto!(vonmises_field, vonmises_gpu)
        copyto!(l1_stress_norm_field, l1_gpu)
        copyto!(principal_max_dir_field, dir_max_gpu)
        copyto!(principal_min_dir_field, dir_min_gpu)
        
        if return_voigt
            copyto!(full_stress_voigt, voigt_gpu)
        end
        
        
        CUDA.unsafe_free!(nodes_gpu); CUDA.unsafe_free!(elements_gpu)
        CUDA.unsafe_free!(U_gpu); CUDA.unsafe_free!(density_gpu)
        CUDA.unsafe_free!(principal_gpu); CUDA.unsafe_free!(vonmises_gpu)
        CUDA.unsafe_free!(voigt_gpu); CUDA.unsafe_free!(l1_gpu)
        CUDA.unsafe_free!(dir_max_gpu); CUDA.unsafe_free!(dir_min_gpu)
        
        GC.gc(); CUDA.reclaim()
        
        return principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field
        
    else
        
        return compute_stress_field_cpu(nodes, elements, U, E, nu, density; return_voigt=return_voigt)
    end
end 
 
end
"// # FILE: .\src\IO\Configuration.jl";
// 
module Configuration 
 
using YAML  
using JSON
using ..Mesh  
using ..Helpers 
using ..MeshShapeProcessing 
 
export load_configuration, load_and_merge_configurations, setup_geometry, initialize_density_field, load_checkpoint
export validate_configuration, print_configuration_summary, export_configuration, compare_configurations
export get_config_value, set_config_value!, apply_preset!
 
""" 
    load_configuration(filename::String) 
 
Load and parse a JSON/YAML configuration file. 
""" 
function load_configuration(filename::String) 
    if !isfile(filename) 
        error("Configuration file '$(filename)' not found") 
    end 
      
    return YAML.load_file(filename) 
end 

"""
    recursive_merge(d1, d2)

Recursively merges dictionary d2 into d1.
"""
function recursive_merge(d1::Dict, d2::Dict)
    result = copy(d1)
    for (k, v) in d2
        if haskey(result, k) && isa(result[k], Dict) && isa(v, Dict)
            result[k] = recursive_merge(result[k], v)
        else
            result[k] = v
        end
    end
    return result
end

"""
    load_and_merge_configurations(domain_file, solver_file, overrides)

Loads two configuration files and merges them into a single dictionary.
Applies `overrides` on top.
"""
function load_and_merge_configurations(domain_file::String, solver_file::String, overrides::Dict)
    println(">>> [CONFIG] Loading Domain: $domain_file")
    domain_config = load_configuration(domain_file)
    
    println(">>> [CONFIG] Loading Solver: $solver_file")
    solver_config = load_configuration(solver_file)
    
    
    merged = merge(domain_config, solver_config)
    
    if !isempty(overrides)
        println(">>> [CONFIG] Applying $(length(overrides)) override(s)...")
        merged = recursive_merge(merged, overrides)
    end
    
    return merged
end

"""
    load_checkpoint(filename::String)

Reads a .bintop checkpoint file. 
Returns: (config, density, restart_iter, restart_radius, restart_threshold)
"""
function load_checkpoint(filename::String)
    println(">>> [Checkpoint] Reading restart data from: $filename")
    
    if !isfile(filename); error("Checkpoint file not found."); end

    data = open(filename, "r") do io
        
        magic = read(io, UInt32) # 0x48455841 "HEXA"
        version = read(io, UInt32)
        
        if magic != 0x48455841
            error("Invalid file format. Not a HEXA checkpoint.")
        end

        iter = Int(read(io, Int32))
        radius = Float32(read(io, Float32))
        threshold = Float32(read(io, Float32))
        
        count = Int(read(io, UInt32))
        dx = read(io, Float32)
        dy = read(io, Float32)
        dz = read(io, Float32)

        seek(io, position(io) + (count * 3 * 4))

        density = Vector{Float32}(undef, count)
        read!(io, density)

        seek(io, position(io) + (count * 4))

        json_len = Int(read(io, UInt32))
        json_bytes = Vector{UInt8}(undef, json_len)
        read!(io, json_bytes)
        
        config_str = String(json_bytes)
        config = JSON.parse(config_str)

        println("    Restarting at Iteration: $iter")
        println("    Filter Radius: $radius")
        println("    Threshold: $threshold")
        println("    Elements: $count")

        return (config, density, iter, radius, threshold)
    end

    return data
end
 
""" 
    setup_geometry(config) 
 
Process the geometry configuration and return parameters for mesh generation. 
""" 
function setup_geometry(config) 
      
    length_x = config["geometry"]["length_x"] 
    length_y = config["geometry"]["length_y"] 
    length_z = config["geometry"]["length_z"] 
     
    
    mesh_conf = get(config, "mesh_settings", Dict())
    raw_count = get(mesh_conf, "initial_ground_mesh_size", 500_000)
    
    target_elem_count = if isa(raw_count, String)
        parse(Int, replace(raw_count, "_" => ""))
    else
        Int(raw_count)
    end
      
    println("Domain dimensions:") 
    println("  X: 0 to $(length_x)") 
    println("  Y: 0 to $(length_y)") 
    println("  Z: 0 to $(length_z)") 
      
    shapes = Any[] 
     
    for (key, shape) in config["geometry"] 
        if key in ["length_x", "length_y", "length_z", 
                   "nElem_x_computed", "nElem_y_computed", "nElem_z_computed", 
                   "dx_computed", "dy_computed", "dz_computed", "max_domain_dim"] 
            continue 
        end 
          
        if haskey(shape, "type") 
            push!(shapes, shape)
        end 
    end 
 
    println("Found $(length(shapes)) geometric modification shapes.") 
      
    nElem_x, nElem_y, nElem_z, dx, dy, dz, actual_elem_count = 
        Helpers.calculate_element_distribution(length_x, length_y, length_z, target_elem_count) 
      
    println("Mesh parameters:") 
    println("  Domain: $(length_x) x $(length_y) x $(length_z) meters") 
    println("  Elements: $(nElem_x) x $(nElem_y) x $(nElem_z) = $(actual_elem_count)") 
    println("  Element sizes: $(dx) x $(dy) x $(dz)") 
      
    max_domain_dim = max(length_x, length_y, length_z) 
 
    return ( 
        nElem_x = nElem_x,  
        nElem_y = nElem_y,  
        nElem_z = nElem_z, 
        dx = dx, 
        dy = dy, 
        dz = dz, 
        shapes = shapes, 
        actual_elem_count = actual_elem_count, 
        max_domain_dim = Float32(max_domain_dim)  
    ) 
end 
 
""" 
    initialize_density_field(nodes, elements, shapes, config)
 
Processes geometric shapes to set the initial density array AND the alpha (thermal expansion) field.
""" 
function initialize_density_field(nodes::Matrix{Float32}, 
                                  elements::Matrix{Int}, 
                                  shapes::Vector{Any}, 
                                  config::Dict) 
      
    min_density = Float32(get(config["optimization_parameters"], "min_density", 1e-3)) 
 
    nElem = size(elements, 1) 
    
    println("\n" * "="^80)
    println(">>> [GEOMETRY] Initializing Density Field")
    println("="^80)
    println("  Total Elements: $(nElem)")
    println("  Number of Shapes: $(length(shapes))")
    println("  Min Density Floor: $(min_density)")
    
    t_init = time()
    density = ones(Float32, nElem) 
    alpha_field = zeros(Float32, nElem)
    println("  [Timing] Field allocation: $(round((time()-t_init)*1000, digits=2))ms")
    
    t_geom = time()
    MeshShapeProcessing.apply_geometric_modifiers!(density, alpha_field, nodes, elements, shapes, min_density)
    geom_time = time() - t_geom
    
    println("  [Timing] Geometric processing: $(round(geom_time, digits=2))s")
    println("           Throughput: $(round(nElem/geom_time/1e6, digits=2))M elements/sec")
      
    t_stats = time()
    original_density = copy(density) 
    protected_elements_mask = (original_density .!= 1.0f0) 
    num_protected = sum(protected_elements_mask)
    
    num_voids = count(d -> d < 0.01f0, density)
    num_stiff = count(d -> d > 1.01f0, density)
    num_passive = count(i -> protected_elements_mask[i] && density[i] >= 0.01f0 && density[i] <= 1.01f0, 1:nElem)
    num_designable = nElem - num_protected
    
    println("  [Timing] Statistics computation: $(round((time()-t_stats)*1000, digits=2))ms")
    println("\n  Element Classification:")
    println("    Designable:        $(num_designable) ($(round(100*num_designable/nElem, digits=2))%)")
    println("    Protected Total:   $(num_protected) ($(round(100*num_protected/nElem, digits=2))%)")
    println("       Voids:         $(num_voids)")
    println("       Stiff:         $(num_stiff)")
    println("       Passive:       $(num_passive)")
    
    println("="^80 * "\n")
 
    return density, original_density, protected_elements_mask, alpha_field
end 

"""
    validate_configuration(config)

Validates configuration parameters and warns about potential issues.
Obsolete parameters (e.g. filter_R_final_perc) have been removed.
"""
function validate_configuration(config::Dict)
    warnings = String[]
    
    opt_params = get(config, "optimization_parameters", Dict())
    
    max_culling = Float32(get(opt_params, "max_culling_ratio", 0.15))
    if max_culling > 0.3
        push!(warnings, "max_culling_ratio is high ($(max_culling)). Values >0.3 may cause instability.")
    end
    
    final_threshold = Float32(get(opt_params, "final_density_threshold", 0.85))
    if final_threshold > 0.95
        push!(warnings, "final_density_threshold is high ($(final_threshold)). Values >0.95 may trigger collapse.")
    end
    
    
    
    solver_params = get(config, "solver_parameters", Dict())
    
    max_iter = Int(get(solver_params, "max_iterations", 40000))
    if max_iter < 1000
        push!(warnings, "max_iterations is low ($max_iter). May not converge for large problems.")
    end
    
    geom = get(config, "geometry", Dict())
    
    lx = get(geom, "length_x", 1.0)
    ly = get(geom, "length_y", 1.0)
    lz = get(geom, "length_z", 1.0)
    
    aspect_ratio = max(lx, ly, lz) / min(lx, ly, lz)
    if aspect_ratio > 10.0
        push!(warnings, "Domain aspect ratio is extreme ($(round(aspect_ratio, digits=1))). May cause solver issues.")
    end
    
    if !isempty(warnings)
        println("\n" * ""^80)
        println(">>> [CONFIG VALIDATION] Warnings:")
        for (i, w) in enumerate(warnings)
            println("  $i. $w")
        end
        println(""^80 * "\n")
    else
        println(">>> [CONFIG VALIDATION] No issues detected.")
    end
    
    return length(warnings) == 0
end

"""
    print_configuration_summary(config)

Prints a formatted summary of the configuration.
Updated to use new variable names.
"""
function print_configuration_summary(config::Dict)
    println("\n" * "="^80)
    println(">>> [CONFIGURATION SUMMARY]")
    println("="^80)
    
    hw_profile = get(config, "hardware_profile_applied", get(config, "gpu_profile", "Unknown"))
    println("  Hardware Profile: $hw_profile")
    
    geom = get(config, "geometry", Dict())
    lx = get(geom, "length_x", 0)
    ly = get(geom, "length_y", 0)
    lz = get(geom, "length_z", 0)
    println("  Domain: $(lx)  $(ly)  $(lz)")
    
    n_iter = get(config, "number_of_iterations", 30)
    println("  Iterations: $n_iter")
    
    solver = get(config, "solver_parameters", Dict())
    solver_type = get(solver, "solver_type", "unknown")
    precond = get(solver, "preconditioner", "unknown")
    tol = get(solver, "tolerance", 0.0)
    println("  Solver: $solver_type")
    println("  Preconditioner: $precond")
    println("  Tolerance: $tol")
    
    opt = get(config, "optimization_parameters", Dict())
    max_cull = get(opt, "max_culling_ratio", 0.0)
    final_thresh = get(opt, "final_density_threshold", 0.0)
    println("  Max Culling Ratio: $max_cull")
    println("  Final Density Threshold: $final_thresh")
    
    
    mesh_conf = get(config, "mesh_settings", Dict())
    target_active = get(mesh_conf, "final_target_of_active_elements", 0)
    max_growth = get(mesh_conf, "max_growth_rate", 0.0)
    println("  Target Active Elements: $target_active")
    println("  Max Growth Rate: $max_growth")
    
    println("="^80 * "\n")
end

"""
    export_configuration(config, filename)

Exports the current configuration to a YAML file.
Useful for reproducibility and debugging.
"""
function export_configuration(config::Dict, filename::String)
    try
        YAML.write_file(filename, config)
        println(">>> [CONFIG] Exported configuration to: $filename")
        return true
    catch e
        @warn "Failed to export configuration: $e"
        return false
    end
end

"""
    compare_configurations(config1, config2)

Compares two configurations and highlights differences.
"""
function compare_configurations(config1::Dict, config2::Dict)
    println("\n" * "="^80)
    println(">>> [CONFIG COMPARISON]")
    println("="^80)
    
    all_keys = union(keys(config1), keys(config2))
    differences = 0
    
    for key in all_keys
        if !haskey(config1, key)
            println("  ADDED: $key = $(config2[key])")
            differences += 1
        elseif !haskey(config2, key)
            println("  REMOVED: $key = $(config1[key])")
            differences += 1
        elseif config1[key] != config2[key]
            println("  CHANGED: $key")
            println("    From: $(config1[key])")
            println("    To:   $(config2[key])")
            differences += 1
        end
    end
    
    if differences == 0
        println("  No differences found.")
    else
        println("\n  Total differences: $differences")
    end
    
    println("="^80 * "\n")
end

"""
    get_config_value(config, path, default)

Safely retrieves nested configuration values.
Example: get_config_value(config, "solver_parameters.tolerance", 1e-6)
"""
function get_config_value(config::Dict, path::String, default)
    keys_list = split(path, '.')
    current = config
    
    for key in keys_list
        if !haskey(current, key)
            return default
        end
        current = current[key]
    end
    
    return current
end

"""
    set_config_value!(config, path, value)

Safely sets nested configuration values.
Example: set_config_value!(config, "solver_parameters.tolerance", 1e-8)
"""
function set_config_value!(config::Dict, path::String, value)
    keys_list = split(path, '.')
    current = config
    
    for (i, key) in enumerate(keys_list)
        if i == length(keys_list)
            current[key] = value
        else
            if !haskey(current, key) || !isa(current[key], Dict)
                current[key] = Dict()
            end
            current = current[key]
        end
    end
end

"""
    apply_preset!(config, preset_name)

Applies predefined configuration presets.
"""
function apply_preset!(config::Dict, preset_name::String)
    presets = Dict(
        "conservative" => Dict(
            "optimization_parameters" => Dict(
                "max_culling_ratio" => 0.05,
                "final_density_threshold" => 0.75
            ),
            "solver_parameters" => Dict(
                "tolerance" => 1.0e-7
            )
        ),
        "aggressive" => Dict(
            "optimization_parameters" => Dict(
                "max_culling_ratio" => 0.25,
                "final_density_threshold" => 0.90
            ),
            "solver_parameters" => Dict(
                "tolerance" => 1.0e-5
            )
        ),
        "balanced" => Dict(
            "optimization_parameters" => Dict(
                "max_culling_ratio" => 0.15,
                "final_density_threshold" => 0.85
            ),
            "solver_parameters" => Dict(
                "tolerance" => 1.0e-6
            )
        )
    )
    
    if !haskey(presets, preset_name)
        @warn "Unknown preset: $preset_name. Available: $(keys(presets))"
        return false
    end
    
    preset = presets[preset_name]
    
    for (section, values) in preset
        if !haskey(config, section)
            config[section] = Dict()
        end
        
        for (key, value) in values
            config[section][key] = value
        end
    end
    
    println(">>> [CONFIG] Applied preset: '$preset_name'")
    return true
end

end
"// # FILE: .\src\IO\ExportVTK.jl";


module ExportVTK 

using Printf 
using Base64 

export export_solution_vti, export_solution_legacy

"""
    export_solution_vti(...)

Writes the simulation results to a VTK XML Image Data file (.vti).
Optimized to optionally include Principal Stresses and Directions based on config.
"""
function export_solution_vti(dims::Tuple{Int,Int,Int}, 
                             spacing::Tuple{Float32,Float32,Float32}, 
                             origin::Tuple{Float32,Float32,Float32},
                             density::Vector{Float32}, 
                             l1_stress::Vector{Float32},
                             von_mises::Vector{Float32},
                             principal_vals::Matrix{Float32},
                             principal_max_dirs::Matrix{Float32},
                             principal_min_dirs::Matrix{Float32},
                             config::Dict,
                             filename::String)

    nx, ny, nz = dims
    n_cells = length(density)
    
    if !endswith(filename, ".vti"); filename *= ".vti"; end

    
    out_settings = get(config, "output_settings", Dict())
    save_vec_val = get(out_settings, "save_principal_stress_vectors", "no")
    write_vectors = (lowercase(string(save_vec_val)) == "yes" || save_vec_val == true)

    open(filename, "w") do io
        write(io, "<?xml version=\"1.0\"?>\n")
        write(io, "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"LittleEndian\">\n")
        
        # WholeExtent="x1 x2 y1 y2 z1 z2" (0-based node indices, so dims are cell counts)
        extent = "0 $nx 0 $ny 0 $nz"
        dx, dy, dz = spacing
        ox, oy, oz = origin
        
        write(io, "  <ImageData WholeExtent=\"$extent\" Origin=\"$ox $oy $oz\" Spacing=\"$dx $dy $dz\">\n")
        write(io, "    <Piece Extent=\"$extent\">\n")
        write(io, "      <CellData Scalars=\"Density\" Vectors=\"MaxPrincipalDirection\">\n")
        
        
        current_offset = 0
        
        
        write(io, "        <DataArray type=\"Float32\" Name=\"Density\" format=\"appended\" offset=\"$current_offset\"/>\n")
        current_offset += sizeof(UInt32) + n_cells * sizeof(Float32)
        
        
        write(io, "        <DataArray type=\"Float32\" Name=\"L1_Stress\" format=\"appended\" offset=\"$current_offset\"/>\n")
        current_offset += sizeof(UInt32) + n_cells * sizeof(Float32)
        
        
        write(io, "        <DataArray type=\"Float32\" Name=\"VonMises\" format=\"appended\" offset=\"$current_offset\"/>\n")
        current_offset += sizeof(UInt32) + n_cells * sizeof(Float32)

        if write_vectors
            
            write(io, "        <DataArray type=\"Float32\" Name=\"PrincipalValues\" NumberOfComponents=\"3\" format=\"appended\" offset=\"$current_offset\"/>\n")
            current_offset += sizeof(UInt32) + (n_cells * 3) * sizeof(Float32)

            
            write(io, "        <DataArray type=\"Float32\" Name=\"MaxPrincipalDirection\" NumberOfComponents=\"3\" format=\"appended\" offset=\"$current_offset\"/>\n")
            current_offset += sizeof(UInt32) + (n_cells * 3) * sizeof(Float32)

            
            write(io, "        <DataArray type=\"Float32\" Name=\"MinPrincipalDirection\" NumberOfComponents=\"3\" format=\"appended\" offset=\"$current_offset\"/>\n")
            current_offset += sizeof(UInt32) + (n_cells * 3) * sizeof(Float32)
        end

        write(io, "      </CellData>\n")
        write(io, "    </Piece>\n")
        write(io, "  </ImageData>\n")
        
        
        write(io, "  <AppendedData encoding=\"raw\">\n")
        write(io, "_") 
        
        
        function write_array(arr)
            n_bytes = UInt32(length(arr) * sizeof(Float32))
            write(io, n_bytes)
            write(io, arr)
        end

        write_array(density)
        write_array(l1_stress)
        write_array(von_mises)

        if write_vectors
            
            write_array(vec(principal_vals)) 
            
            write_array(vec(principal_max_dirs))
            
            write_array(vec(principal_min_dirs))
        end
        
        write(io, "\n  </AppendedData>\n")
        write(io, "</VTKFile>\n")
    end
end

function export_solution_legacy(nodes::Matrix{Float32}, 
                                elements::Matrix{Int}, 
                                U_full::Vector{Float32}, 
                                F::Vector{Float32}, 
                                bc_indicator::Matrix{Float32}, 
                                principal_field::Matrix{Float32}, 
                                vonmises_field::Vector{Float32}, 
                                full_stress_voigt::Matrix{Float32}, 
                                l1_stress_norm_field::Vector{Float32},
                                principal_max_dir_field::Matrix{Float32}; 
                                density::Vector{Float32}=Float32[],
                                filename::String="solution.vtk",
                                kwargs...)
    
    println("Legacy exporter triggered (not updated for vectors).")
end

function export_solution(nodes, elements, U, F, bc, p_field, vm, voigt, l1, p_max_dir, p_min_dir; 
                         density=nothing, filename="out.vtk", config=nothing, kwargs...)
                          
    # If we have config and it's a structured grid, USE VTI (Fastest)
    if config !== nothing
        geom = config["geometry"]
        nx = Int(geom["nElem_x_computed"])
        ny = Int(geom["nElem_y_computed"])
        nz = Int(geom["nElem_z_computed"])
        dx = Float32(geom["dx_computed"])
        dy = Float32(geom["dy_computed"])
        dz = Float32(geom["dz_computed"])
        
        
        export_solution_vti((nx, ny, nz), (dx, dy, dz), (0f0, 0f0, 0f0), 
                            density, l1, vm, p_field, p_max_dir, p_min_dir, config, filename)
    else
        export_solution_legacy(nodes, elements, U, F, bc, p_field, vm, voigt, l1, p_max_dir; 
                               density=density, filename=filename, kwargs...)
    end
end

end
"// # FILE: .\src\IO\Postprocessing.jl";
// 
module Postprocessing

using JSON, Printf
using Base.Threads
using CUDA
using LinearAlgebra
using Logging 
using ..Mesh
using ..MeshUtilities 
using ..ExportVTK
using ..Diagnostics 
import MarchingCubes: MC, march

export export_iteration_results, export_smooth_watertight_stl

function suppress_specific_warnings(f::Function, module_to_suppress::Module)
    current_logger = global_logger()
    filtered_logger = EarlyFilteredLogger(current_logger) do args
        if args.level == Logging.Warn && args._module == module_to_suppress
            return false 
        end
        return true 
    end
    with_logger(f, filtered_logger)
end

function safe_parse_int(val, default::Int)
    if val === nothing; return default; end
    if isa(val, Number); return Int(val); end
    if isa(val, String)
        clean_val = replace(val, "_" => "")
        return try parse(Int, clean_val) catch; default end
    end
    return default
end

function get_smooth_nodal_densities(density::Vector{Float32}, elements::Matrix{Int}, nNodes::Int)
    node_sums = zeros(Float32, nNodes)
    node_counts = zeros(Int, nNodes)
    nElem = length(density)
    
    @inbounds for e in 1:nElem
        rho = density[e]
        for i in 1:8
            node_idx = elements[e, i]
            if node_idx > 0 && node_idx <= nNodes
                node_sums[node_idx] += rho
                node_counts[node_idx] += 1
            end
        end
    end
    nodal_density = zeros(Float32, nNodes)
    @inbounds for i in 1:nNodes
        if node_counts[i] > 0
            nodal_density[i] = node_sums[i] / Float32(node_counts[i])
        end
    end
    return nodal_density
end

function smooth_grid!(grid::Array{Float32, 3}, passes::Int)
    if passes <= 0; return; end
    nx, ny, nz = size(grid)
    temp_grid = copy(grid)
    
    for _ in 1:passes
        Threads.@threads for k in 2:(nz-1)
            for j in 2:(ny-1)
                for i in 2:(nx-1)
                    sum_neighbors = grid[i-1,j,k] + grid[i+1,j,k] +
                                    grid[i,j-1,k] + grid[i,j+1,k] +
                                    grid[i,j,k-1] + grid[i,j,k+1]
                    temp_grid[i,j,k] = (grid[i,j,k] * 4.0f0 + sum_neighbors) * 0.1f0
                end
            end
        end
        grid[2:end-1, 2:end-1, 2:end-1] .= temp_grid[2:end-1, 2:end-1, 2:end-1]
    end
end

function trilinear_interpolate(vals, xd::Float32, yd::Float32, zd::Float32)
    c00 = vals[1]*(1f0-xd) + vals[2]*xd
    c01 = vals[4]*(1f0-xd) + vals[3]*xd
    c10 = vals[5]*(1f0-xd) + vals[6]*xd
    c11 = vals[8]*(1f0-xd) + vals[7]*xd
    c0 = c00*(1f0-yd) + c01*yd
    c1 = c10*(1f0-yd) + c11*yd
    return c0*(1f0-zd) + c1*zd
end

function decimate_mesh!(vertices::Vector{Tuple{Float64, Float64, Float64}}, 
                        triangles::AbstractVector, 
                        target_triangle_count::Int)
    current_count = length(triangles)
    
    if current_count > 2_000_000 
        Diagnostics.print_warn("Mesh too large for decimation ($current_count tris). Skipping to preserve performance.")
        return triangles
    end

    if target_triangle_count <= 0 || current_count <= target_triangle_count
        return triangles
    end

    Diagnostics.print_info("Decimating mesh: $current_count -> $target_triangle_count triangles...")
    
    mutable_tris = Vector{Vector{Int}}(undef, current_count)
    for i in 1:current_count
        t = triangles[i]
        mutable_tris[i] = [Int(t[1]), Int(t[2]), Int(t[3])]
    end

    max_passes = 15
    for pass in 1:max_passes
        if length(mutable_tris) <= target_triangle_count; break; end

        edges = Vector{Tuple{Float64, Int, Int}}()
        sizehint!(edges, length(mutable_tris) * 3)

        for t in mutable_tris
            v1, v2, v3 = t[1], t[2], t[3]
            d12 = (vertices[v1][1]-vertices[v2][1])^2 + (vertices[v1][2]-vertices[v2][2])^2 + (vertices[v1][3]-vertices[v2][3])^2
            d23 = (vertices[v2][1]-vertices[v3][1])^2 + (vertices[v2][2]-vertices[v3][2])^2 + (vertices[v2][3]-vertices[v3][3])^2
            d31 = (vertices[v3][1]-vertices[v1][1])^2 + (vertices[v3][2]-vertices[v1][2])^2 + (vertices[v3][3]-vertices[v1][3])^2
            push!(edges, (d12, min(v1,v2), max(v1,v2)))
            push!(edges, (d23, min(v2,v3), max(v2,v3)))
            push!(edges, (d31, min(v3,v1), max(v3,v1)))
        end

        sort!(edges, by = x -> x[1])
        
        replacements = collect(1:length(vertices))
        collapsed_nodes = falses(length(vertices))
        n_collapsed = 0
        
        tris_to_remove = length(mutable_tris) - target_triangle_count
        limit_collapses = max(100, tris_to_remove) 

        for (dist, u, v) in edges
            if n_collapsed >= limit_collapses; break; end
            if !collapsed_nodes[u] && !collapsed_nodes[v]
                replacements[v] = u
                mx = (vertices[u][1] + vertices[v][1]) * 0.5
                my = (vertices[u][2] + vertices[v][2]) * 0.5
                mz = (vertices[u][3] + vertices[v][3]) * 0.5
                vertices[u] = (mx, my, mz)
                collapsed_nodes[u] = true 
                collapsed_nodes[v] = true
                n_collapsed += 1
            end
        end

        if n_collapsed == 0; break; end

        new_triangles = Vector{Vector{Int}}()
        sizehint!(new_triangles, length(mutable_tris))

        for t in mutable_tris
            v1 = replacements[t[1]]
            v2 = replacements[t[2]]
            v3 = replacements[t[3]]
            if v1 != v2 && v1 != v3 && v2 != v3
                push!(new_triangles, [v1, v2, v3])
            end
        end
        mutable_tris = new_triangles
    end
    return mutable_tris
end

function laplacian_smooth_mesh!(vertices::Vector{Tuple{Float64, Float64, Float64}}, 
                                triangles::AbstractVector, 
                                iterations::Int=3, lambda::Float64=0.5)
    if iterations <= 0; return; end
    nv = length(vertices)
    new_pos = Vector{Tuple{Float64, Float64, Float64}}(undef, nv)
    neighbor_counts = zeros(Int, nv)
    neighbor_sums_x = zeros(Float64, nv)
    neighbor_sums_y = zeros(Float64, nv)
    neighbor_sums_z = zeros(Float64, nv)

    for _ in 1:iterations
        fill!(neighbor_counts, 0)
        fill!(neighbor_sums_x, 0.0); fill!(neighbor_sums_y, 0.0); fill!(neighbor_sums_z, 0.0)

        for tri in triangles
            i1, i2, i3 = tri[1], tri[2], tri[3]
            if i1 < 1 || i1 > nv || i2 < 1 || i2 > nv || i3 < 1 || i3 > nv; continue; end
            v1 = vertices[i1]; v2 = vertices[i2]; v3 = vertices[i3]
            neighbor_sums_x[i1] += v2[1]; neighbor_sums_y[i1] += v2[2]; neighbor_sums_z[i1] += v2[3]; neighbor_counts[i1] += 1
            neighbor_sums_x[i1] += v3[1]; neighbor_sums_y[i1] += v3[2]; neighbor_sums_z[i1] += v3[3]; neighbor_counts[i1] += 1
            neighbor_sums_x[i2] += v1[1]; neighbor_sums_y[i2] += v1[2]; neighbor_sums_z[i2] += v1[3]; neighbor_counts[i2] += 1
            neighbor_sums_x[i2] += v3[1]; neighbor_sums_y[i2] += v3[2]; neighbor_sums_z[i2] += v3[3]; neighbor_counts[i2] += 1
            neighbor_sums_x[i3] += v1[1]; neighbor_sums_y[i3] += v1[2]; neighbor_sums_z[i3] += v1[3]; neighbor_counts[i3] += 1
            neighbor_sums_x[i3] += v2[1]; neighbor_sums_y[i3] += v2[2]; neighbor_sums_z[i3] += v2[3]; neighbor_counts[i3] += 1
        end
        
        Threads.@threads for i in 1:nv
            cnt = neighbor_counts[i]
            if cnt > 0
                old_x, old_y, old_z = vertices[i]
                avg_x, avg_y, avg_z = neighbor_sums_x[i]/cnt, neighbor_sums_y[i]/cnt, neighbor_sums_z[i]/cnt
                nx = old_x + lambda * (avg_x - old_x)
                ny = old_y + lambda * (avg_y - old_y)
                nz = old_z + lambda * (avg_z - old_z)
                new_pos[i] = (nx, ny, nz)
            else
                new_pos[i] = vertices[i]
            end
        end
        copyto!(vertices, new_pos)
    end
end

"""
    write_stl_chunked(filename, triangles, vertices)

OPTIMIZED: Uses batched multi-threading to eliminate false sharing and 
chunks output to minimize RAM spikes.
"""
function write_stl_chunked(filename::String, 
                           triangles::AbstractVector, 
                           vertices::Vector{Tuple{Float64, Float64, Float64}})
    
    n_tri = length(triangles)
    
    open(filename, "w") do io
        
        header_str = "HEXA TopOpt Optimized Binary STL"
        header = zeros(UInt8, 80)
        copyto!(header, 1, codeunits(header_str), 1, min(length(header_str), 80))
        write(io, header)
        write(io, UInt32(n_tri))

        
        
        CHUNK_SIZE = 1_000_000 
        buffer = Vector{UInt8}(undef, CHUNK_SIZE * 50)
        
        n_chunks = cld(n_tri, CHUNK_SIZE)
        
        for c in 1:n_chunks
            start_idx = (c - 1) * CHUNK_SIZE + 1
            end_idx = min(c * CHUNK_SIZE, n_tri)
            n_in_chunk = end_idx - start_idx + 1
            
            
            
            
            
            
            n_threads = Threads.nthreads()
            batch_size = cld(n_in_chunk, n_threads)
            
            Threads.@threads for t in 1:n_threads
                t_start = start_idx + (t - 1) * batch_size
                t_end = min(start_idx + t * batch_size - 1, end_idx)
                
                if t_start <= t_end
                    
                    for i in t_start:t_end
                        
                        local_i = i - start_idx
                        offset = local_i * 50
                        
                        tri = triangles[i]
                        
                        
                        if tri[1] < 1 || tri[1] > length(vertices) ||
                           tri[2] < 1 || tri[2] > length(vertices) ||
                           tri[3] < 1 || tri[3] > length(vertices)
                            continue
                        end

                        v1 = vertices[tri[1]]
                        v2 = vertices[tri[2]]
                        v3 = vertices[tri[3]]
                        
                        
                        e1x, e1y, e1z = v2[1]-v1[1], v2[2]-v1[2], v2[3]-v1[3]
                        e2x, e2y, e2z = v3[1]-v1[1], v3[2]-v1[2], v3[3]-v1[3]
                        nx, ny, nz = e1y*e2z - e1z*e2y, e1z*e2x - e1x*e2z, e1x*e2y - e1y*e2x
                        mag = sqrt(nx*nx + ny*ny + nz*nz)
                        if mag > 1e-12; nx/=mag; ny/=mag; nz/=mag; else; nx=0.0; ny=0.0; nz=0.0; end
                        
                        
                        ptr = pointer(buffer, offset + 1)
                        p_f32 = reinterpret(Ptr{Float32}, ptr)
                        
                        unsafe_store!(p_f32, Float32(nx), 1)
                        unsafe_store!(p_f32, Float32(ny), 2)
                        unsafe_store!(p_f32, Float32(nz), 3)
                        
                        unsafe_store!(p_f32, Float32(v1[1]), 4)
                        unsafe_store!(p_f32, Float32(v1[2]), 5)
                        unsafe_store!(p_f32, Float32(v1[3]), 6)
                        
                        unsafe_store!(p_f32, Float32(v2[1]), 7)
                        unsafe_store!(p_f32, Float32(v2[2]), 8)
                        unsafe_store!(p_f32, Float32(v2[3]), 9)
                        
                        unsafe_store!(p_f32, Float32(v3[1]), 10)
                        unsafe_store!(p_f32, Float32(v3[2]), 11)
                        unsafe_store!(p_f32, Float32(v3[3]), 12)
                        
                        p_u16 = reinterpret(Ptr{UInt16}, ptr + 48)
                        unsafe_store!(p_u16, UInt16(0), 1)
                    end
                end
            end
            
            
            
            bytes_to_write = n_in_chunk * 50
            write(io, view(buffer, 1:bytes_to_write))
        end
    end
end

function export_smooth_watertight_stl(density::Vector{Float32}, geom, threshold::Float32, filename::String; 
                                      subdivision_level::Int=2, smoothing_passes::Int=2, 
                                      mesh_smoothing_iters::Int=3, target_triangle_count::Int=0) 
    
    min_d, max_d = extrema(density)
    if max_d < threshold
        Diagnostics.print_info("Skipping STL: Max density ($max_d) < threshold ($threshold). No surface exists.")
        return
    end

    try
        dir_path = dirname(filename)
        if !isempty(dir_path) && !isdir(dir_path); mkpath(dir_path); end

        NX, NY, NZ = geom.nElem_x, geom.nElem_y, geom.nElem_z
        dx, dy, dz = geom.dx, geom.dy, geom.dz
        
        
        
        actual_subdivision = subdivision_level
        if length(density) > 5_000_000
             actual_subdivision = 1
        end

        nodes_coarse, elements_coarse, _ = Mesh.generate_mesh(NX, NY, NZ; dx=dx, dy=dy, dz=dz)
        nNodes_coarse = size(nodes_coarse, 1)
        if length(density) != size(elements_coarse, 1); return; end
        
        nodal_density_coarse = get_smooth_nodal_densities(density, elements_coarse, nNodes_coarse)
        grid_coarse = reshape(nodal_density_coarse, (NX+1, NY+1, NZ+1))
        smooth_grid!(grid_coarse, smoothing_passes)

        sub_NX, sub_NY, sub_NZ = NX * actual_subdivision, NY * actual_subdivision, NZ * actual_subdivision
        pad = 1 
        fine_dim_x, fine_dim_y, fine_dim_z = sub_NX+1+2*pad, sub_NY+1+2*pad, sub_NZ+1+2*pad
        sub_dx, sub_dy, sub_dz = dx/Float32(actual_subdivision), dy/Float32(actual_subdivision), dz/Float32(actual_subdivision)

        fine_grid = zeros(Float32, fine_dim_x, fine_dim_y, fine_dim_z)
        x_coords = collect(Float32, range(-pad*sub_dx, step=sub_dx, length=fine_dim_x))
        y_coords = collect(Float32, range(-pad*sub_dy, step=sub_dy, length=fine_dim_y))
        z_coords = collect(Float32, range(-pad*sub_dz, step=sub_dz, length=fine_dim_z))

        Threads.@threads for k_f in (1+pad):(fine_dim_z-pad)
            for j_f in (1+pad):(fine_dim_y-pad)
                for i_f in (1+pad):(fine_dim_x-pad)
                    ix, iy, iz = i_f-(1+pad), j_f-(1+pad), k_f-(1+pad)
                    idx_x, idx_y, idx_z = div(ix, actual_subdivision), div(iy, actual_subdivision), div(iz, actual_subdivision)
                    if idx_x >= NX; idx_x = NX - 1; end
                    if idx_y >= NY; idx_y = NY - 1; end
                    if idx_z >= NZ; idx_z = NZ - 1; end
                    c_i, c_j, c_k = idx_x + 1, idx_y + 1, idx_z + 1
                    rem_x, rem_y, rem_z = ix - idx_x*actual_subdivision, iy - idx_y*actual_subdivision, iz - idx_z*actual_subdivision
                    xd, yd, zd = Float32(rem_x)/actual_subdivision, Float32(rem_y)/actual_subdivision, Float32(rem_z)/actual_subdivision
                    vals = (grid_coarse[c_i,c_j,c_k], grid_coarse[c_i+1,c_j,c_k], grid_coarse[c_i+1,c_j+1,c_k], grid_coarse[c_i,c_j+1,c_k],
                            grid_coarse[c_i,c_j,c_k+1], grid_coarse[c_i+1,c_j,c_k+1], grid_coarse[c_i+1,c_j+1,c_k+1], grid_coarse[c_i,c_j+1,c_k+1])
                    fine_grid[i_f, j_f, k_f] = trilinear_interpolate(vals, xd, yd, zd)
                end
            end
        end

        mc_struct = MC(fine_grid, Int; normal_sign=1, x=x_coords, y=y_coords, z=z_coords)
        march(mc_struct, threshold)
        
        if length(mc_struct.vertices) == 0
            Diagnostics.print_warn("STL generation produced 0 vertices (Empty).")
            return
        end

        final_triangles = collect(mc_struct.triangles) 
        final_vertices = [(Float64(v[1]), Float64(v[2]), Float64(v[3])) for v in mc_struct.vertices]

        if mesh_smoothing_iters > 0
            try
                verts_tuple = copy(final_vertices)
                laplacian_smooth_mesh!(verts_tuple, final_triangles, mesh_smoothing_iters, 0.5)
                final_vertices = verts_tuple
            catch e
                Diagnostics.print_warn("Mesh smoothing failed: $e")
            end
        end

        if target_triangle_count > 0 && length(final_triangles) > target_triangle_count
             try
                 final_triangles = decimate_mesh!(final_vertices, final_triangles, target_triangle_count)
             catch e
                 Diagnostics.print_error("Mesh decimation failed ($e). Exporting un-decimated mesh.")
             end
        end

        
        write_stl_chunked(filename, final_triangles, final_vertices)

    catch e
        Diagnostics.print_error("STL Export crashed: $e")
        Diagnostics.write_crash_log("crash_log.txt", "STL_EXPORT", e, stacktrace(catch_backtrace()), 0, Dict(), Float32[])
    end
end

function export_binary_for_web(filename::String, 
                               nodes::Matrix{Float32}, 
                               elements::Matrix{Int}, 
                               density::Vector{Float32}, 
                               l1_stress::Vector{Float32}, 
                               principal_field::Matrix{Float32}, 
                               geom, 
                               threshold::Float32, 
                               iter::Int, 
                               current_radius::Float32, 
                               config::Dict; 
                               max_export_cells::Int=0) 
    
    all_active_indices = findall(x -> x >= threshold, density)
    n_active = length(all_active_indices)
    if n_active == 0; return; end

    if max_export_cells > 0 && n_active > max_export_cells
        step_val = n_active / max_export_cells
        indices_to_export = Int[]
        sizehint!(indices_to_export, max_export_cells)
        curr_float_idx = 1.0
        while curr_float_idx <= n_active
            idx_int = floor(Int, curr_float_idx)
            if idx_int <= n_active
                push!(indices_to_export, all_active_indices[idx_int])
            end
            curr_float_idx += step_val
        end
        valid_indices = indices_to_export
    else
        valid_indices = all_active_indices
    end

    count = length(valid_indices)

    meta = deepcopy(config)
    meta["iteration"] = iter
    meta["radius"] = current_radius
    meta["threshold"] = threshold
    if haskey(meta, "geometry") && isa(meta["geometry"], Dict)
        for (key, shape) in meta["geometry"]
            if isa(shape, Dict) && haskey(shape, "type")
                if !haskey(shape, "action") && haskey(shape, "stiffness_ratio")
                    ratio = Float32(shape["stiffness_ratio"])
                    shape["action"] = ratio > 0 ? "add" : "remove"
                end
            end
        end
    end
    meta["loads"] = get(config, "external_forces", [])
    meta["bcs"] = get(config, "boundary_conditions", [])
    meta["settings"] = get(config, "optimization_parameters", Dict())
    
    json_str = JSON.json(meta)
    json_bytes = Vector{UInt8}(json_str)
    json_len = UInt32(length(json_bytes))

    try
        open(filename, "w") do io
            write(io, 0x48455841) # Magic "HEXA"
            write(io, UInt32(2))  
            write(io, Int32(iter))
            write(io, Float32(current_radius))
            write(io, Float32(threshold))
            write(io, UInt32(count))
            write(io, Float32(geom.dx))
            write(io, Float32(geom.dy))
            write(io, Float32(geom.dz))

            centroids = zeros(Float32, count * 3)
            densities = zeros(Float32, count)
            signed_l1 = zeros(Float32, count)

            Threads.@threads for i in 1:count
                idx = valid_indices[i]
                c = MeshUtilities.element_centroid(idx, nodes, elements)
                centroids[3*(i-1)+1] = c[1]
                centroids[3*(i-1)+2] = c[2]
                centroids[3*(i-1)+3] = c[3]

                densities[i] = density[idx]

                s1 = principal_field[1, idx]
                s2 = principal_field[2, idx]
                s3 = principal_field[3, idx]
                abs_max = abs(s1); sign_val = sign(s1)
                if abs(s2) > abs_max; abs_max = abs(s2); sign_val = sign(s2); end
                if abs(s3) > abs_max; abs_max = abs(s3); sign_val = sign(s3); end
                signed_l1[i] = l1_stress[idx] * sign_val
            end

            write(io, centroids)
            write(io, densities)
            write(io, signed_l1)
            write(io, json_len)
            write(io, json_bytes)
        end
    catch e
        Diagnostics.print_error("[Binary Export] Failed to write file: $e")
    end
end

function export_iteration_results(iter::Int, base_name::String, RESULTS_DIR::String, 
                                  nodes::Matrix{Float32}, elements::Matrix{Int}, 
                                  U_full::AbstractVector, F::AbstractVector, 
                                  bc_indicator::Matrix{Float32}, principal_field::Matrix{Float32}, 
                                  vonmises_field::Vector{Float32}, full_stress_voigt::Matrix{Float32}, 
                                  l1_stress_norm_field::Vector{Float32}, principal_max_dir_field::Matrix{Float32}, principal_min_dir_field::Matrix{Float32}, 
                                  density::Vector{Float32}, E::Float32, geom; 
                                  iso_threshold::Float32=0.8f0, 
                                  current_radius::Float32=0.0f0, 
                                  config::Dict=Dict(), 
                                  save_bin::Bool=true, 
                                  save_stl::Bool=true, 
                                  save_vtk::Bool=true)
      
    U_f32 = (eltype(U_full) == Float32) ? U_full : Float32.(U_full)
    F_f32 = (eltype(F) == Float32) ? F : Float32.(F)

    iter_prefix = "iter_$(iter)_"

    out_settings = get(config, "output_settings", Dict())
    
    raw_max_cells = get(out_settings, "maximum_cells_in_binary_output", 25_000_000)
    max_export_cells = safe_parse_int(raw_max_cells, 25_000_000)

    raw_stl_target = get(out_settings, "stl_target_triangle_count", 0)
    target_triangles = safe_parse_int(raw_stl_target, 0)

    if save_bin
        try
            print("      > Writing Checkpoint/Web Binary...")
            t_web = time()
            
            bin_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_webdata.bintop")
            export_binary_for_web(
                bin_filename, nodes, elements, density, l1_stress_norm_field, 
                principal_field, geom, iso_threshold, iter, current_radius, 
                config; max_export_cells=max_export_cells
            )
            @printf(" done (%.3fs)\n", time() - t_web)
        catch e
            Diagnostics.print_warn("Web binary export failed. Continuing.")
            Diagnostics.write_crash_log("crash_log.txt", "WEB_EXPORT", e, stacktrace(catch_backtrace()), iter, config, density)
        end
    end

    if save_vtk
        try
            print("      > Writing VTK (Paraview)...")
            t_vtk = time()
            solution_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_solution") 
            
            
            ExportVTK.export_solution(nodes, elements, U_f32, F_f32, bc_indicator, 
                                    principal_field, vonmises_field, full_stress_voigt, 
                                    l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field; 
                                    density=density, threshold=iso_threshold, scale=Float32(1.0), 
                                    filename=solution_filename,
                                    config=config, 
                                    max_cells=0)

            @printf(" done (%.3fs)\n", time() - t_vtk)
        catch e
            Diagnostics.print_warn("VTK export failed. Continuing.")
            Diagnostics.write_crash_log("crash_log.txt", "VTK_EXPORT", e, stacktrace(catch_backtrace()), iter, config, density)
        end
    end

    if save_stl && iter > 0 
        print("      > Writing Isosurface STL...")
        t_stl = time()
        stl_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_isosurface.stl")
        
        subdiv = get(out_settings, "stl_subdivision_level", 2)
        smooth = get(out_settings, "stl_smoothing_passes", 2)
        mesh_smooth = get(out_settings, "stl_mesh_smoothing_iters", 3)
        
        export_smooth_watertight_stl(density, geom, iso_threshold, stl_filename; 
                                     subdivision_level=subdiv, 
                                     smoothing_passes=smooth,
                                     mesh_smoothing_iters=mesh_smooth,
                                     target_triangle_count=target_triangles)
        @printf(" done (%.3fs)\n", time() - t_stl)
    end
end 

end
"// # FILE: .\src\Mesh\Mesh.jl";
module Mesh 
 
export node_index, generate_mesh 

 
using LinearAlgebra, Printf 
 
""" 
    node_index(i, j, k, nNodes_x, nNodes_y) 
 
Converts 3D indices (i, j, k) into a linear node index (columnmajor ordering). 
""" 
function node_index(i, j, k, nNodes_x, nNodes_y) 
    return i + (j-1)*nNodes_x + (k-1)*nNodes_x*nNodes_y 
end 
 
""" 
    generate_mesh(nElem_x, nElem_y, nElem_z; 
                  dx=1.0f0, dy=1.0f0, dz=1.0f0) 
 
Generates a structured (prismatic) hexahedral mesh. 
""" 
function generate_mesh(nElem_x::Int, nElem_y::Int, nElem_z::Int; 
                       dx::Float32=Float32(1.0),  
                       dy::Float32=Float32(1.0),  
                       dz::Float32=Float32(1.0))  
      
    nNodes_x = nElem_x + 1 
    nNodes_y = nElem_y + 1 
    nNodes_z = nElem_z + 1 
    dims = (nNodes_x, nNodes_y, nNodes_z) 
        
    nNodes = nNodes_x * nNodes_y * nNodes_z 
    nodes = zeros(Float32, nNodes, 3) 
    idx = 1 
    for k in 1:nNodes_z, j in 1:nNodes_y, i in 1:nNodes_x 
        nodes[idx, :] = [(i-1)*dx, (j-1)*dy, (k-1)*dz] 
        idx += 1 
    end 
      
    nElem = (nNodes_x - 1) * (nNodes_y - 1) * (nNodes_z - 1) 
    elements = Matrix{Int}(undef, nElem, 8) 
    elem_idx = 1 
    for k in 1:(nNodes_z-1), j in 1:(nNodes_y-1), i in 1:(nNodes_x-1) 
        n1 = node_index(i, j, k, nNodes_x, nNodes_y) 
        n2 = node_index(i+1, j, k, nNodes_x, nNodes_y) 
        n3 = node_index(i+1, j+1, k, nNodes_x, nNodes_y) 
        n4 = node_index(i, j+1, k, nNodes_x, nNodes_y) 
        n5 = node_index(i, j, k+1, nNodes_x, nNodes_y) 
        n6 = node_index(i+1, j, k+1, nNodes_x, nNodes_y) 
        n7 = node_index(i+1, j+1, k+1, nNodes_x, nNodes_y) 
        n8 = node_index(i, j+1, k+1, nNodes_x, nNodes_y) 
        elements[elem_idx, :] = [n1, n2, n3, n4, n5, n6, n7, n8] 
        elem_idx += 1 
    end 
 
    println("Generated structured mesh: $(nElem) elements, $(nNodes) nodes.") 
 
    return nodes, elements, dims 
end 
 
end
"// # FILE: .\src\Mesh\MeshPruner.jl";


module MeshPruner

using LinearAlgebra
using SparseArrays

export prune_system, reconstruct_full_solution

function prune_system(nodes::Matrix{Float32}, 
                      elements::Matrix{Int}, 
                      density::Vector{Float32}, 
                      threshold::Float32, 
                      bc_indicator::Matrix{Float32}, 
                      F::Vector{Float32})

    nElem = size(elements, 1)
    nNodes = size(nodes, 1)

    active_mask = density .> threshold
    active_element_indices = findall(active_mask)
    nActiveElem = length(active_element_indices)

    if nActiveElem == 0
        error("MeshPruner: No active elements found (Threshold: $threshold). System is empty.")
    end

    active_nodes_mask = falses(nNodes)
    
    for e in active_element_indices
        for i in 1:8
            node_idx = elements[e, i]
            active_nodes_mask[node_idx] = true
        end
    end

    old_to_new_node_map = zeros(Int, nNodes)
    new_to_old_node_map = Int[]
    
    current_new_id = 1
    for i in 1:nNodes
        if active_nodes_mask[i]
            old_to_new_node_map[i] = current_new_id
            push!(new_to_old_node_map, i)
            current_new_id += 1
        end
    end
    
    nActiveNodes = length(new_to_old_node_map)
    reduced_nodes = nodes[new_to_old_node_map, :]

    reduced_elements = Matrix{Int}(undef, nActiveElem, 8)
    for (i, old_e_idx) in enumerate(active_element_indices)
        for j in 1:8
            old_node = elements[old_e_idx, j]
            new_node = old_to_new_node_map[old_node]
            reduced_elements[i, j] = new_node
        end
    end

    reduced_bc = bc_indicator[new_to_old_node_map, :]
    reduced_ndof = nActiveNodes * 3
    reduced_F = zeros(Float32, reduced_ndof)
    
    for (new_idx, old_idx) in enumerate(new_to_old_node_map)
        base_old = 3 * (old_idx - 1)
        base_new = 3 * (new_idx - 1)
        reduced_F[base_new+1] = F[base_old+1]
        reduced_F[base_new+2] = F[base_old+2]
        reduced_F[base_new+3] = F[base_old+3]
    end

    reduced_density = density[active_element_indices]

    return (
        nodes = reduced_nodes,
        elements = reduced_elements,
        bc_indicator = reduced_bc,
        F = reduced_F,
        density = reduced_density,
        old_to_new_node_map = old_to_new_node_map,
        new_to_old_node_map = new_to_old_node_map,
        active_element_indices = active_element_indices,
        n_original_nodes = nNodes,
        n_original_elems = nElem
    )
end

function reconstruct_full_solution(u_reduced::AbstractVector, 
                                   new_to_old_node_map::Vector{Int}, 
                                   n_full_nodes::Int)
    
    T = eltype(u_reduced)
    ndof_full = n_full_nodes * 3
    u_full = zeros(T, ndof_full)

    for (new_node_idx, old_node_idx) in enumerate(new_to_old_node_map)
        base_new = 3 * (new_node_idx - 1)
        base_old = 3 * (old_node_idx - 1)

        u_full[base_old+1] = u_reduced[base_new+1]
        u_full[base_old+2] = u_reduced[base_new+2]
        u_full[base_old+3] = u_reduced[base_new+3]
    end

    return u_full
end

end
"// # FILE: .\src\Mesh\MeshRefiner.jl";

module MeshRefiner

using LinearAlgebra
using Printf
using Base.Threads
using ..Mesh
using ..Helpers

export refine_mesh_and_fields

function estimate_element_memory_cost_bytes(hard_element_limit::Int)
    if hard_element_limit > 500_000_000 
        return 180 
    else
        return 220 
    end
end

"""
    sample_nearest_neighbor(grid, nx, ny, nz, tx, ty, tz)

Robust Piecewise Constant (Nearest Neighbor) sampling.
Preserves sharp boundaries (Solid vs Void) and avoids creating artificial "gray" elements
that the optimizer would immediately cull.
"""
@inline function sample_nearest_neighbor(grid::Vector{Float32}, nx::Int, ny::Int, nz::Int, 
                                         tx::Float32, ty::Float32, tz::Float32)
    
    
    ix = clamp(floor(Int, tx * nx), 0, nx - 1)
    iy = clamp(floor(Int, ty * ny), 0, ny - 1)
    iz = clamp(floor(Int, tz * nz), 0, nz - 1)

    
    idx = (ix + 1) + (iy * nx) + (iz * nx * ny)
    
    return @inbounds grid[idx]
end

function refine_mesh_and_fields(nodes::Matrix{Float32}, 
                                elements::Matrix{Int}, 
                                density::Vector{Float32}, 
                                alpha_field::Vector{Float32}, 
                                current_dims::Tuple{Int, Int, Int},
                                target_active_count::Int, 
                                domain_bounds::NamedTuple; 
                                max_growth_rate::Float64=1.2, 
                                hard_element_limit::Int=800_000_000,
                                update_method::String="hard") 

    C_RESET = "\u001b[0m"
    C_BOLD = "\u001b[1m"
    C_CYAN = "\u001b[36m"
    C_GREEN = "\u001b[32m"
    C_YELLOW = "\u001b[33m"

    println("\n" * C_CYAN * "="^60 * C_RESET)
    println(C_CYAN * C_BOLD * ">>> [MESH REFINER] Evaluating Refinement (Conservative Voxel Split)" * C_RESET)

    n_total_old = length(density)
    n_active_old = count(d -> d > 0.001f0, density) 
    active_ratio = max(0.0001, n_active_old / n_total_old) 
    
    println("    Current Total Elements:  $(n_total_old)")
    println("    Current Active Elements: $(n_active_old) ($(round(active_ratio*100, digits=2))%)")
    println("    Target Active Limit:     $(target_active_count)")

    ideal_total_from_target = round(Int, (target_active_count / active_ratio) * 0.90)
    rate_limit_elements = round(Int, n_total_old * max_growth_rate)
    
    final_new_total = n_total_old

    if n_active_old >= target_active_count
        println(C_GREEN * "    [OK] Target active count reached. Maintaining mesh resolution." * C_RESET)
        final_new_total = n_total_old 
    else
        limits = [
            ("Target Active Limit", ideal_total_from_target),
            ("Growth Rate Limit", rate_limit_elements),
            ("Config Hard Limit", hard_element_limit)
        ]
        
        sort!(limits, by = x -> x[2])
        
        limiting_factor_name = limits[1][1]
        final_new_total = limits[1][2]
        
        println("    Constraint Analysis:")
        for (name, val) in limits
            col = (name == limiting_factor_name) ? C_YELLOW : C_RESET
            println("      - $col$name: $(Base.format_bytes(val * 200)) approx ($val elems)$C_RESET")
        end
        println("    LIMIT APPLIED: $C_YELLOW$limiting_factor_name$C_RESET")
    end

    if final_new_total > hard_element_limit
        final_new_total = hard_element_limit
    end

    
    if final_new_total < (n_total_old * 1.05)
        println(C_YELLOW * "    [SKIP] Calculated growth too small (< 5%). Skipping." * C_RESET)
        println(C_CYAN * "="^60 * "\n" * C_RESET)
        return nodes, elements, density, alpha_field, current_dims
    end

    println(C_GREEN * C_BOLD * "    >>> EXECUTING REFINEMENT TO: $final_new_total elements" * C_RESET)

    len_x, len_y, len_z = domain_bounds.len_x, domain_bounds.len_y, domain_bounds.len_z
    new_nx, new_ny, new_nz, new_dx, new_dy, new_dz, actual_count = 
        Helpers.calculate_element_distribution(len_x, len_y, len_z, final_new_total)
        
    println("      > Grid: $(new_nx)x$(new_ny)x$(new_nz) = $actual_count")
    println("      > Res:  $(new_dx) x $(new_dy) x $(new_dz)")

    new_nodes, new_elements, new_dims = Mesh.generate_mesh(
        new_nx, new_ny, new_nz; 
        dx=new_dx, dy=new_dy, dz=new_dz
    )
    
    
    min_pt = domain_bounds.min_pt
    new_nodes[:, 1] .+= min_pt[1]
    new_nodes[:, 2] .+= min_pt[2]
    new_nodes[:, 3] .+= min_pt[3]
    
    println("      > Mapping fields (Nearest Neighbor / Voxel Split)...")
    n_new_total = size(new_elements, 1)
    new_density = zeros(Float32, n_new_total)
    new_alpha   = zeros(Float32, n_new_total) 
    
    old_nx = Int(current_dims[1] - 1)
    old_ny = Int(current_dims[2] - 1)
    old_nz = Int(current_dims[3] - 1)
    
    
    new_nx_64 = Int64(new_nx)
    new_ny_64 = Int64(new_ny)
    
    Threads.@threads for e_new in 1:n_new_total
        
        e_new_idx = Int64(e_new)
        
        tmp = e_new_idx - 1
        iz = div(tmp, new_nx_64 * new_ny_64)
        rem = tmp % (new_nx_64 * new_ny_64)
        iy = div(rem, new_nx_64)
        ix = rem % new_nx_64
        
        
        
        tx = (Float32(ix) + 0.5f0) / Float32(new_nx)
        ty = (Float32(iy) + 0.5f0) / Float32(new_ny)
        tz = (Float32(iz) + 0.5f0) / Float32(new_nz)
        
        
        
        new_density[e_new] = sample_nearest_neighbor(density, old_nx, old_ny, old_nz, tx, ty, tz)
        new_alpha[e_new]   = sample_nearest_neighbor(alpha_field, old_nx, old_ny, old_nz, tx, ty, tz)
    end
    
    println(C_GREEN * "    [DONE] Refinement Complete (Boundary Preserved)." * C_RESET)
    println(C_CYAN * "="^60 * "\n" * C_RESET)

    return new_nodes, new_elements, new_density, new_alpha, new_dims
end

end
"// # FILE: .\src\Mesh\MeshShapeProcessing.jl";


module MeshShapeProcessing 
 
export apply_geometric_modifiers!
 
using LinearAlgebra 
using Base.Threads
using ..MeshUtilities     
 
"""
    precompute_shape_bboxes(shapes)

Precompute bounding boxes for each shape to enable early rejection.
"""
function precompute_shape_bboxes(shapes::Vector{Any})
    bboxes = Vector{NamedTuple{(:xmin, :xmax, :ymin, :ymax, :zmin, :zmax), NTuple{6, Float32}}}(undef, length(shapes))
    
    for (i, shape) in enumerate(shapes)
        shape_type = lowercase(get(shape, "type", ""))
        
        if shape_type == "sphere"
            center = tuple(Float32.(shape["center"])...)
            radius = Float32(shape["diameter"]) / 2.0f0
            bboxes[i] = (
                xmin = center[1] - radius, xmax = center[1] + radius,
                ymin = center[2] - radius, ymax = center[2] + radius,
                zmin = center[3] - radius, zmax = center[3] + radius
            )
        elseif shape_type == "box"
            center = tuple(Float32.(shape["center"])...)
            
            if haskey(shape, "size")
                sz_raw = shape["size"]
                if isa(sz_raw, AbstractVector) && length(sz_raw) >= 3
                    hx = Float32(sz_raw[1]) / 2.0f0
                    hy = Float32(sz_raw[2]) / 2.0f0
                    hz = Float32(sz_raw[3]) / 2.0f0
                else
                    hx = hy = hz = 0.5f0
                end
            elseif haskey(shape, "side")
                half_side = Float32(shape["side"]) / 2.0f0
                hx = hy = hz = half_side
            else
                hx = hy = hz = 0.5f0
            end
            
            bboxes[i] = (
                xmin = center[1] - hx, xmax = center[1] + hx,
                ymin = center[2] - hy, ymax = center[2] + hy,
                zmin = center[3] - hz, zmax = center[3] + hz
            )
        else
            
            bboxes[i] = (
                xmin = -Inf32, xmax = Inf32,
                ymin = -Inf32, ymax = Inf32,
                zmin = -Inf32, zmax = Inf32
            )
        end
    end
    
    return bboxes
end

"""
    bbox_contains(bbox, pt)

Fast bounding box check.
"""
@inline function bbox_contains(bbox, pt)
    return (pt[1] >= bbox.xmin && pt[1] <= bbox.xmax &&
            pt[2] >= bbox.ymin && pt[2] <= bbox.ymax &&
            pt[3] >= bbox.zmin && pt[3] <= bbox.zmax)
end

"""
    apply_geometric_modifiers!(density, alpha_field, nodes, elements, shapes, min_density)

Iterates over elements and modifies the `density` and `alpha_field` based on the 
`stiffness_ratio` of the geometric shapes defined in the configuration.

OPTIMIZED VERSION:
- Multi-threaded element processing
- Bounding box early rejection
- Vectorized centroid calculation
- Reduced allocations
"""
function apply_geometric_modifiers!(density::Vector{Float32}, 
                                    alpha_field::Vector{Float32},
                                    nodes::Matrix{Float32}, 
                                    elements::Matrix{Int}, 
                                    shapes::Vector{Any},
                                    min_density::Float32)
    
    if isempty(shapes)
        return
    end

    nElem = size(elements, 1)
    
    println("Processing geometric density and thermal modifiers...")
    t_start = time()
    
    
    bboxes = precompute_shape_bboxes(shapes)
    
    
    n_shapes = length(shapes)
    shape_types = Vector{String}(undef, n_shapes)
    shape_ratios = Vector{Float32}(undef, n_shapes)
    shape_centers = Vector{Tuple{Float32, Float32, Float32}}(undef, n_shapes)
    shape_params = Vector{Any}(undef, n_shapes)
    
    for (i, shape) in enumerate(shapes)
        shape_types[i] = lowercase(get(shape, "type", ""))
        shape_ratios[i] = Float32(get(shape, "stiffness_ratio", 0.0))
        
        if haskey(shape, "center")
            c = shape["center"]
            shape_centers[i] = (Float32(c[1]), Float32(c[2]), Float32(c[3]))
        else
            shape_centers[i] = (0.0f0, 0.0f0, 0.0f0)
        end
        
        
        if shape_types[i] == "sphere"
            shape_params[i] = Float32(shape["diameter"]) / 2.0f0  # radius
        elseif shape_types[i] == "box"
            if haskey(shape, "size")
                sz_raw = shape["size"]
                if isa(sz_raw, AbstractVector) && length(sz_raw) >= 3
                    shape_params[i] = (Float32(sz_raw[1])/2.0f0, Float32(sz_raw[2])/2.0f0, Float32(sz_raw[3])/2.0f0)
                else
                    shape_params[i] = (0.5f0, 0.5f0, 0.5f0)
                end
            elseif haskey(shape, "side")
                half_side = Float32(shape["side"]) / 2.0f0
                shape_params[i] = (half_side, half_side, half_side)
            else
                shape_params[i] = (0.5f0, 0.5f0, 0.5f0)
            end
        else
            shape_params[i] = nothing
        end
    end
    
    
    centroids = Vector{Tuple{Float32, Float32, Float32}}(undef, nElem)
    
    Threads.@threads for e in 1:nElem
        cx = 0.0f0; cy = 0.0f0; cz = 0.0f0
        
        @inbounds for i in 1:8
            node_idx = elements[e, i]
            cx += nodes[node_idx, 1]
            cy += nodes[node_idx, 2]
            cz += nodes[node_idx, 3]
        end
        
        centroids[e] = (cx * 0.125f0, cy * 0.125f0, cz * 0.125f0)
    end
    
    println("  [Optimization] Computed $(nElem) element centroids ($(round(time()-t_start, digits=2))s)")
    
    
    Threads.@threads for e in 1:nElem
        centroid = centroids[e]
        
        
        for i in 1:n_shapes
            
            if !bbox_contains(bboxes[i], centroid)
                continue
            end
            
            
            is_inside = false
            
            if shape_types[i] == "sphere"
                center = shape_centers[i]
                radius = shape_params[i]
                
                dx = centroid[1] - center[1]
                dy = centroid[2] - center[2]
                dz = centroid[3] - center[3]
                dist_sq = dx*dx + dy*dy + dz*dz
                
                is_inside = (dist_sq <= radius*radius)
                
            elseif shape_types[i] == "box"
                center = shape_centers[i]
                half_sizes = shape_params[i]
                
                is_inside = (abs(centroid[1] - center[1]) <= half_sizes[1] &&
                            abs(centroid[2] - center[2]) <= half_sizes[2] &&
                            abs(centroid[3] - center[3]) <= half_sizes[3])
            end
            
            if is_inside
                ratio = shape_ratios[i]
                
                if ratio == 0.0f0
                    
                    density[e] = min_density
                    alpha_field[e] = 0.0f0
                elseif ratio < 0.0f0
                    
                    density[e] = abs(ratio)
                    alpha_field[e] = 1.0f0
                else
                    
                    density[e] = ratio
                    alpha_field[e] = 0.0f0
                end
                
                
                break
            end
        end
    end
    
    total_time = time() - t_start
    println("  [Optimization] Element density and thermal processing complete ($(round(total_time, digits=2))s)")
    println("                 Processed $(nElem) elements with $(n_shapes) shapes")
    println("                 Throughput: $(round(nElem/total_time/1e6, digits=2))M elements/sec")
end 
 
end
"// # FILE: .\src\Mesh\MeshUtilities.jl";


module MeshUtilities 
 
export inside_sphere, inside_box, element_centroid
 
using LinearAlgebra 
 
""" 
    element_centroid(e, nodes, elements) 
 
Computes the centroid of element `e`.
OPTIMIZED: Uses scalar math to avoid allocating vectors inside threaded loops.
Returns a Tuple (x, y, z).
""" 
function element_centroid(e::Int, nodes::Matrix{Float32}, elements::Matrix{Int}) 
    cx = 0.0f0
    cy = 0.0f0
    cz = 0.0f0

    @inbounds for i in 1:8
        node_idx = elements[e, i]
        cx += nodes[node_idx, 1]
        cy += nodes[node_idx, 2]
        cz += nodes[node_idx, 3]
    end

    inv8 = 0.125f0 
    return (cx * inv8, cy * inv8, cz * inv8)  
end 

""" 
    inside_sphere(pt, center, diam) 
Return true if point `pt` is inside a sphere of diameter `diam` at `center`. 
Accepts pt as Vector or Tuple.
""" 
function inside_sphere(pt, center::Tuple{Float32,Float32,Float32}, diam::Float32) 
    r = diam / 2f0 
     
    dx = pt[1] - center[1]
    dy = pt[2] - center[2]
    dz = pt[3] - center[3]
    return (dx*dx + dy*dy + dz*dz) <= (r*r)
end 

""" 
    inside_box(pt, center, size) 
Return true if point `pt` is inside a box with dimensions `size` (x, y, z) centered at `center`. 
Accepts pt as Vector or Tuple.
""" 
function inside_box(pt, center::Tuple{Float32,Float32,Float32}, box_size::Tuple{Float32,Float32,Float32}) 
    half_x = box_size[1] / 2f0 
    half_y = box_size[2] / 2f0 
    half_z = box_size[3] / 2f0 
     
    return abs(pt[1] - center[1]) <= half_x && 
           abs(pt[2] - center[2]) <= half_y && 
           abs(pt[3] - center[3]) <= half_z 
end 
 
end
"// # FILE: .\src\Optimization\GPUExplicitFilter.jl";


module GPUExplicitFilter

using CUDA
using LinearAlgebra
using Printf

export apply_explicit_filter!





"""
    diffusion_kernel_interior!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Standard 7-point Laplacian stencil for interior elements.
    Processes elements that are at least 1 element away from all boundaries.
"""
function diffusion_kernel_interior!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    
    if i > 1 && i < nx && j > 1 && j < ny && k > 1 && k < nz
        @inbounds begin
            idx = i + (j-1)*nx + (k-1)*nx*ny
            center = rho_old[idx]
            
            
            left   = rho_old[idx - 1]
            right  = rho_old[idx + 1]
            front  = rho_old[idx - nx]
            back   = rho_old[idx + nx]
            bottom = rho_old[idx - nx*ny]
            top    = rho_old[idx + nx*ny]
            
            laplacian = (left + right + front + back + bottom + top - 6.0f0 * center)
            
            
            rho_new[idx] = center + dt_over_dx2 * laplacian
        end
    end
    return nothing
end

"""
    diffusion_kernel_faces!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Neumann BCs (ghost values) for the 6 planar faces.
"""
function diffusion_kernel_faces!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    if i < 1 || i > nx || j < 1 || j > ny || k < 1 || k > nz; return nothing; end
    
    
    on_x = (i == 1 || i == nx) && (j > 1 && j < ny) && (k > 1 && k < nz)
    on_y = (j == 1 || j == ny) && (i > 1 && i < nx) && (k > 1 && k < nz)
    on_z = (k == 1 || k == nz) && (i > 1 && i < nx) && (j > 1 && j < ny)
    
    if !(on_x || on_y || on_z); return nothing; end
    
    @inbounds begin
        idx = i + (j-1)*nx + (k-1)*nx*ny
        center = rho_old[idx]
        sum_n = 0.0f0
        w_tot = 0.0f0
        
        
        if i > 1
            sum_n += rho_old[idx-1]
            w_tot += 1.0f0
        elseif i == 1
            
            sum_n += (2.0f0*center - rho_old[idx+1])
            w_tot += 1.0f0
        end
        
        if i < nx
            sum_n += rho_old[idx+1]
            w_tot += 1.0f0
        elseif i == nx
            sum_n += (2.0f0*center - rho_old[idx-1])
            w_tot += 1.0f0
        end
        
        
        if j > 1
            sum_n += rho_old[idx-nx]
            w_tot += 1.0f0
        elseif j == 1
            sum_n += (2.0f0*center - rho_old[idx+nx])
            w_tot += 1.0f0
        end
        
        if j < ny
            sum_n += rho_old[idx+nx]
            w_tot += 1.0f0
        elseif j == ny
            sum_n += (2.0f0*center - rho_old[idx-nx])
            w_tot += 1.0f0
        end
        
        
        if k > 1
            sum_n += rho_old[idx-nx*ny]
            w_tot += 1.0f0
        elseif k == 1
            sum_n += (2.0f0*center - rho_old[idx+nx*ny])
            w_tot += 1.0f0
        end
        
        if k < nz
            sum_n += rho_old[idx+nx*ny]
            w_tot += 1.0f0
        elseif k == nz
            sum_n += (2.0f0*center - rho_old[idx-nx*ny])
            w_tot += 1.0f0
        end
        
        rho_new[idx] = center + dt_over_dx2 * (sum_n - w_tot * center)
    end
    return nothing
end

"""
    diffusion_kernel_edges!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Neumann BCs for the 12 edges (lines where 2 faces meet).
"""
function diffusion_kernel_edges!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    if i < 1 || i > nx || j < 1 || j > ny || k < 1 || k > nz; return nothing; end
    
    
    b_cnt = 0
    if i==1||i==nx; b_cnt+=1; end
    if j==1||j==ny; b_cnt+=1; end
    if k==1||k==nz; b_cnt+=1; end
    
    if b_cnt != 2; return nothing; end
    
    @inbounds begin
        idx = i + (j-1)*nx + (k-1)*nx*ny
        center = rho_old[idx]
        sum_n = 0.0f0
        w_tot = 0.0f0
        
        
        if i > 1
            sum_n += rho_old[idx-1]
            w_tot += 1.0f0
        elseif i == 1 && nx > 1
            sum_n += (2.0f0*center - rho_old[idx+1])
            w_tot += 1.0f0
        end
        
        if i < nx
            sum_n += rho_old[idx+1]
            w_tot += 1.0f0
        elseif i == nx && nx > 1
            sum_n += (2.0f0*center - rho_old[idx-1])
            w_tot += 1.0f0
        end
        
        
        if j > 1
            sum_n += rho_old[idx-nx]
            w_tot += 1.0f0
        elseif j == 1 && ny > 1
            sum_n += (2.0f0*center - rho_old[idx+nx])
            w_tot += 1.0f0
        end
        
        if j < ny
            sum_n += rho_old[idx+nx]
            w_tot += 1.0f0
        elseif j == ny && ny > 1
            sum_n += (2.0f0*center - rho_old[idx-nx])
            w_tot += 1.0f0
        end
        
        
        if k > 1
            sum_n += rho_old[idx-nx*ny]
            w_tot += 1.0f0
        elseif k == 1 && nz > 1
            sum_n += (2.0f0*center - rho_old[idx+nx*ny])
            w_tot += 1.0f0
        end
        
        if k < nz
            sum_n += rho_old[idx+nx*ny]
            w_tot += 1.0f0
        elseif k == nz && nz > 1
            sum_n += (2.0f0*center - rho_old[idx-nx*ny])
            w_tot += 1.0f0
        end
        
        if w_tot > 0.0f0
            rho_new[idx] = center + dt_over_dx2 * (sum_n - w_tot * center)
        else
            rho_new[idx] = center
        end
    end
    return nothing
end

"""
    diffusion_kernel_corners!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Neumann BCs for the 8 corners (points where 3 faces meet).
"""
function diffusion_kernel_corners!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    if i < 1 || i > nx || j < 1 || j > ny || k < 1 || k > nz; return nothing; end
    
    
    is_corner = (i==1||i==nx) && (j==1||j==ny) && (k==1||k==nz)
    if !is_corner; return nothing; end
    
    @inbounds begin
        idx = i + (j-1)*nx + (k-1)*nx*ny
        center = rho_old[idx]
        sum_n = 0.0f0
        w_tot = 0.0f0
        
        
        if i > 1
            sum_n += rho_old[idx-1]
            w_tot += 1.0f0
        elseif i == 1 && nx > 1
            sum_n += (2.0f0*center - rho_old[idx+1])
            w_tot += 1.0f0
        end
        
        if i < nx
            sum_n += rho_old[idx+1]
            w_tot += 1.0f0
        elseif i == nx && nx > 1
            sum_n += (2.0f0*center - rho_old[idx-1])
            w_tot += 1.0f0
        end
        
        
        if j > 1
            sum_n += rho_old[idx-nx]
            w_tot += 1.0f0
        elseif j == 1 && ny > 1
            sum_n += (2.0f0*center - rho_old[idx+nx])
            w_tot += 1.0f0
        end
        
        if j < ny
            sum_n += rho_old[idx+nx]
            w_tot += 1.0f0
        elseif j == ny && ny > 1
            sum_n += (2.0f0*center - rho_old[idx-nx])
            w_tot += 1.0f0
        end
        
        
        if k > 1
            sum_n += rho_old[idx-nx*ny]
            w_tot += 1.0f0
        elseif k == 1 && nz > 1
            sum_n += (2.0f0*center - rho_old[idx+nx*ny])
            w_tot += 1.0f0
        end
        
        if k < nz
            sum_n += rho_old[idx+nx*ny]
            w_tot += 1.0f0
        elseif k == nz && nz > 1
            sum_n += (2.0f0*center - rho_old[idx-nx*ny])
            w_tot += 1.0f0
        end
        
        if w_tot > 0.0f0
            rho_new[idx] = center + dt_over_dx2 * (sum_n - w_tot * center)
        else
            rho_new[idx] = center
        end
    end
    return nothing
end





"""
    apply_explicit_filter!(density, nx, ny, nz, dx, dy, dz, radius, min_density)

OPTIMIZED VERSION:
1. Dynamic Slab Sizing: Utilizes all available VRAM instead of hardcoded 500MB.
2. Optimized Thread Blocks: (32, 4, 4) for memory coalescing on X-axis.
3. Execution Timer: Logs performance.
4. Sparsity Culling: Skips processing for empty slabs.
"""
function apply_explicit_filter!(density::Vector{Float32}, 
                                nx::Int, ny::Int, nz::Int,
                                dx::Float32, dy::Float32, dz::Float32,
                                radius::Float32,
                                min_density::Float32=0.0001f0) 
    
    if !CUDA.functional(); return density; end
    
    t_start = time()
    
    
    D = (radius^2) / 6.0f0
    avg_dx = (dx + dy + dz) / 3.0f0
    dt_stable = 0.15f0 * (avg_dx^2) / D
    n_steps = max(10, round(Int, radius / avg_dx))
    dt_over_dx2 = dt_stable * D / (avg_dx^2)
    
    halo = 2
    
    
    free_mem = CUDA.available_memory()
    bytes_per_node = 8 
    
    
    usable_mem = max(500 * 1024^2, free_mem - (500 * 1024^2))
    max_nodes = div(usable_mem, bytes_per_node)
    
    slice_size = nx * ny
    max_slab_nz = div(max_nodes, slice_size)
    if max_slab_nz < (halo*2 + 1); max_slab_nz = halo*2 + 1; end 
    
    n_slabs = cld(nz, max_slab_nz - 2*halo)
    
    
    
    threads = (32, 4, 4)
    
    println(@sprintf("    [ExplicitFilter] Radius=%.3f, Steps=%d, dt=%.2e, Slabs=%d (Unclamped Diffusion)", 
                     radius, n_steps, dt_stable, n_slabs))
    
    filtered_density = copy(density)
    
    skipped_slabs = 0
    
    for slab_idx in 1:n_slabs
        z_start = max(1, (slab_idx - 1) * (max_slab_nz - 2*halo) + 1 - halo)
        z_end   = min(nz, z_start + max_slab_nz - 1)
        slab_nz = z_end - z_start + 1
        slab_size = nx * ny * slab_nz
        
        
        slab_data = zeros(Float32, slab_size)
        Threads.@threads for k in 1:slab_nz
            global_k = z_start + k - 1
            start_g = 1 + (global_k - 1) * nx * ny
            end_g   = start_g + nx * ny - 1
            start_l = 1 + (k - 1) * nx * ny
            end_l   = start_l + nx * ny - 1
            slab_data[start_l:end_l] = density[start_g:end_g]
        end
        
        
        # If the max density in this slab (including halos) is "Void",
        
        
        max_val = maximum(slab_data)
        
        
        if max_val <= (min_density * 1.01f0 + 1.0f-5)
            skipped_slabs += 1
            continue
        end
        
        rho_gpu = CuArray(slab_data)
        rho_new_gpu = CUDA.zeros(Float32, slab_size)
        
        blocks = (cld(nx, threads[1]), cld(ny, threads[2]), cld(slab_nz, threads[3]))
        
        for step in 1:n_steps
            @cuda threads=threads blocks=blocks diffusion_kernel_interior!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            @cuda threads=threads blocks=blocks diffusion_kernel_faces!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            @cuda threads=threads blocks=blocks diffusion_kernel_edges!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            @cuda threads=threads blocks=blocks diffusion_kernel_corners!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            rho_gpu, rho_new_gpu = rho_new_gpu, rho_gpu
        end
        
        CUDA.synchronize()
        copyto!(slab_data, rho_gpu)
        
        
        valid_z_start = (slab_idx == 1) ? 1 : halo + 1
        valid_z_end   = (slab_idx == n_slabs) ? slab_nz : slab_nz - halo
        
        Threads.@threads for k in valid_z_start:valid_z_end
            global_k = z_start + k - 1
            start_g = 1 + (global_k - 1) * nx * ny
            end_g   = start_g + nx * ny - 1
            start_l = 1 + (k - 1) * nx * ny
            end_l   = start_l + nx * ny - 1
            filtered_density[start_g:end_g] = slab_data[start_l:end_l]
        end
        
        CUDA.unsafe_free!(rho_gpu); CUDA.unsafe_free!(rho_new_gpu)
    end
    
    GC.gc(); CUDA.reclaim()
    
    elapsed = time() - t_start
    println(@sprintf("    [ExplicitFilter] R=%.3f, Slabs=%d/%d (Skipped %d Empty), Time=%.2fs", 
                     radius, n_slabs - skipped_slabs, n_slabs, skipped_slabs, elapsed))
    
    return filtered_density
end

end
"// # FILE: .\src\Optimization\TopOpt.jl";

module TopologyOptimization 

using LinearAlgebra
using SparseArrays
using Printf  
using Statistics 
using SuiteSparse 
using CUDA
using Base.Threads
using ..Element
using ..Mesh
using ..GPUExplicitFilter
using ..Helpers

export update_density!, reset_filter_cache!

mutable struct FilterCache
    is_initialized::Bool
    radius::Float32
    K_filter::SuiteSparse.CHOLMOD.Factor{Float64} 
    FilterCache() = new(false, 0.0f0)
end

const GLOBAL_FILTER_CACHE = FilterCache()

function reset_filter_cache!()
    GLOBAL_FILTER_CACHE.is_initialized = false
end

function apply_emergency_box_filter(density::Vector{Float32}, nx::Int, ny::Int, nz::Int)
    println("    [EMERGENCY FILTER] Applying 3x3x3 box filter (CPU)...")
    
    nElem = length(density)
    filtered = copy(density)
    
    Threads.@threads for k in 2:nz-1
        for j in 2:ny-1
            for i in 2:nx-1
                e = i + (j-1)*nx + (k-1)*nx*ny
                
                if e < 1 || e > nElem; continue; end
                
                sum_rho = 0.0f0
                count = 0
                
                for dk in -1:1, dj in -1:1, di in -1:1
                    neighbor_i = i + di
                    neighbor_j = j + dj
                    neighbor_k = k + dk
                    
                    if neighbor_i >= 1 && neighbor_i <= nx &&
                       neighbor_j >= 1 && neighbor_j <= ny &&
                       neighbor_k >= 1 && neighbor_k <= nz
                        
                        neighbor_idx = neighbor_i + (neighbor_j-1)*nx + (neighbor_k-1)*nx*ny
                        
                        if neighbor_idx >= 1 && neighbor_idx <= nElem
                            sum_rho += density[neighbor_idx]
                            count += 1
                        end
                    end
                end
                
                filtered[e] = (count > 0) ? (sum_rho / count) : density[e]
            end
        end
    end
    
    return filtered
end

function create_transition_zone(protected_mask::BitVector, nx::Int, ny::Int, nz::Int, depth::Int=3)
    nElem = length(protected_mask)
    transition_zone = falses(nElem)
    
    for k in 1:nz, j in 1:ny, i in 1:nx
        e = i + (j-1)*nx + (k-1)*nx*ny
        if e < 1 || e > nElem; continue; end
        
        if protected_mask[e]; continue; end
        
        # Check if within 'depth' layers of a protected element
        found_protected = false
        for dk in -depth:depth, dj in -depth:depth, di in -depth:depth
            ni = i + di
            nj = j + dj
            nk = k + dk
            
            if ni >= 1 && ni <= nx && nj >= 1 && nj <= ny && nk >= 1 && nk <= nz
                neighbor_idx = ni + (nj-1)*nx + (nk-1)*nx*ny
                if neighbor_idx >= 1 && neighbor_idx <= nElem && protected_mask[neighbor_idx]
                    found_protected = true
                    break
                end
            end
        end
        
        if found_protected
            transition_zone[e] = true
        end
    end
    
    return transition_zone
end

function blend_transition_zone!(density::Vector{Float32}, 
                                 filtered_density::Vector{Float32},
                                 protected_mask::BitVector,
                                 transition_zone::BitVector,
                                 original_density::Vector{Float32},
                                 nx::Int, ny::Int, nz::Int,
                                 blend_depth::Int=3)
    
    nElem = length(density)
    
    Threads.@threads for k in 1:nz
        for j in 1:ny
            for i in 1:nx
                e = i + (j-1)*nx + (k-1)*nx*ny
                if e < 1 || e > nElem; continue; end
                
                if !transition_zone[e]; continue; end
                
                min_dist = blend_depth + 1.0
                
                for dk in -blend_depth:blend_depth, dj in -blend_depth:blend_depth, di in -blend_depth:blend_depth
                    ni = i + di
                    nj = j + dj
                    nk = k + dk
                    
                    if ni >= 1 && ni <= nx && nj >= 1 && nj <= ny && nk >= 1 && nk <= nz
                        neighbor_idx = ni + (nj-1)*nx + (nk-1)*nx*ny
                        if neighbor_idx >= 1 && neighbor_idx <= nElem && protected_mask[neighbor_idx]
                            dist = sqrt(Float32(di^2 + dj^2 + dk^2))
                            min_dist = min(min_dist, dist)
                        end
                    end
                end
                
                alpha = clamp(min_dist / blend_depth, 0.0f0, 1.0f0)
                smooth_alpha = alpha * alpha * (3.0f0 - 2.0f0 * alpha)
                density[e] = (1.0f0 - smooth_alpha) * original_density[e] + smooth_alpha * filtered_density[e]
            end
        end
    end
end

function verify_boundary_filtering_detailed(density::Vector{Float32}, filtered::Vector{Float32}, 
                                            nx::Int, ny::Int, nz::Int)
    
    interior_changed = 0; interior_total = 0
    faces_changed = 0; faces_total = 0
    edges_changed = 0; edges_total = 0
    corners_changed = 0; corners_total = 0
    
    for k in 1:nz, j in 1:ny, i in 1:nx
        e = i + (j-1)*nx + (k-1)*nx*ny
        
        changed = abs(density[e] - filtered[e]) > 1e-6
        
        on_boundary_count = 0
        if i == 1 || i == nx; on_boundary_count += 1; end
        if j == 1 || j == ny; on_boundary_count += 1; end
        if k == 1 || k == nz; on_boundary_count += 1; end
        
        if on_boundary_count == 0
            interior_total += 1
            if changed; interior_changed += 1; end
        elseif on_boundary_count == 1
            faces_total += 1
            if changed; faces_changed += 1; end
        elseif on_boundary_count == 2
            edges_total += 1
            if changed; edges_changed += 1; end
        else  
            corners_total += 1
            if changed; corners_changed += 1; end
        end
    end
    
    println("    [Filter Check] Detailed Boundary Analysis:")
    
    if interior_total > 0
        pct = 100.0 * interior_changed / interior_total
        status = pct > 90.0 ? "" : ""
        println(@sprintf("      %s Interior:  %6d / %6d (%.1f%%)", 
                         status, interior_changed, interior_total, pct))
    end
    
    if faces_total > 0
        pct = 100.0 * faces_changed / faces_total
        status = pct > 90.0 ? "" : ""
        println(@sprintf("      %s Faces:       %6d / %6d (%.1f%%)", 
                         status, faces_changed, faces_total, pct))
    end
    
    if edges_total > 0
        pct = 100.0 * edges_changed / edges_total
        status = pct > 80.0 ? "" : ""
        println(@sprintf("      %s Edges:       %6d / %6d (%.1f%%)", 
                         status, edges_changed, edges_total, pct))
    end
    
    if corners_total > 0
        pct = 100.0 * corners_changed / corners_total
        status = pct > 70.0 ? "" : ""
        println(@sprintf("      %s Corners:     %6d / %6d (%.1f%%)", 
                         status, corners_changed, corners_total, pct))
    end
    
    total_boundary = faces_total + edges_total + corners_total
    total_boundary_changed = faces_changed + edges_changed + corners_changed
    
    if total_boundary > 0
        overall_pct = 100.0 * total_boundary_changed / total_boundary
        if overall_pct < 80.0
            println("    \u001b[33m[WARNING] <80%% of boundaries filtered properly!\u001b[0m")
        else
            println("    \u001b[32m[SUCCESS] Boundary filtering working correctly.\u001b[0m")
        end
    end
end

function update_density!(density::Vector{Float32}, 
                         l1_stress_norm_field::Vector{Float32}, 
                         protected_elements_mask::BitVector, 
                         E::Float32, 
                         l1_stress_allowable::Float32, 
                         iter::Int, 
                         number_of_iterations::Int, 
                         original_density::Vector{Float32}, 
                         min_density::Float32,  
                         max_density::Float32, 
                         config::Dict, 
                         elements::Matrix{Int},
                         is_annealing::Bool=false;
                         force_no_cull::Bool=false)  

    nElem = length(density)
    
    if any(isnan, l1_stress_norm_field)
        println("\n" * "\u001b[31m" * "!!!"^20 * "\u001b[0m")
        println("\u001b[31m" * ">>> [SAFEGUARD] CRITICAL: NaNs detected in stress field (Solver Diverged)." * "\u001b[0m")
        println("\u001b[31m" * ">>> [SAFEGUARD] Skipping topology update to prevent mesh corruption." * "\u001b[0m")
        println("\u001b[31m" * "!!!"^20 * "\n" * "\u001b[0m")
        return 0.0f0, 0.0f0, 0.0f0, 0.0, 0, 0.0
    end

    opt_params = config["optimization_parameters"]
    geom_params = config["geometry"]
    
    nElem_x = Int(geom_params["nElem_x_computed"]) 
    nElem_y = Int(geom_params["nElem_y_computed"])
    nElem_z = Int(geom_params["nElem_z_computed"])
    dx = Float32(geom_params["dx_computed"])
    dy = Float32(geom_params["dy_computed"])
    dz = Float32(geom_params["dz_computed"])
    avg_element_size = (dx + dy + dz) / 3.0f0
    
    proposed_density_field = zeros(Float32, nElem)
    Threads.@threads for e in 1:nElem
        if !protected_elements_mask[e] 
            current_l1_stress = l1_stress_norm_field[e]
            val = (current_l1_stress / l1_stress_allowable) / E
            proposed_density_field[e] = val
        else
            proposed_density_field[e] = original_density[e]
        end
    end

    target_d_phys = Float32(get(opt_params, "minimum_feature_size_physical", 0.0))
    floor_d_elems = Float32(get(opt_params, "minimum_feature_size_elements", 3.0)) 
    
    floor_d_phys = floor_d_elems * avg_element_size
    
    d_min_phys = 0.0f0
    active_constraint = ""
    
    if target_d_phys > floor_d_phys
        d_min_phys = target_d_phys
        active_constraint = "PHYSICAL TARGET"
    else
        d_min_phys = floor_d_phys
        active_constraint = "ELEMENT FLOOR (Stability)"
    end
    
    d_min_elems = d_min_phys / avg_element_size

    t = Float32(iter) / Float32(number_of_iterations)
    t = clamp(t, 0.0f0, 1.0f0)

    gamma = Float32(get(opt_params, "radius_decay_exponent", 1.8))
    r_max_mult = Float32(get(opt_params, "radius_max_multiplier", 4.0))
    r_min_mult = Float32(get(opt_params, "radius_min_multiplier", 0.5))
    C_safe = Float32(get(opt_params, "constraint_constant", 0.25))
    final_threshold_val = Float32(get(opt_params, "final_density_threshold", 0.98))
    
    
    exponent_cutoff = Float32(get(opt_params, "exponent_for_cutoff_schedule", 1.0))
    
    current_threshold = 0.0f0
    if iter > number_of_iterations
        current_threshold = final_threshold_val
    else
        
        t_scheduled = t ^ exponent_cutoff
        current_threshold = final_threshold_val * t_scheduled
    end
    
    effective_threshold = max(current_threshold, 0.001f0)

    decay_factor = 1.0f0 - (t^gamma)
    r_baseline = (r_max_mult * d_min_phys) * decay_factor + (r_min_mult * d_min_phys)
    
    constraint_limit_radius = (C_safe * d_min_phys) / effective_threshold
    R_final = min(r_baseline, constraint_limit_radius)
    
    R_abs_min = 1.0f0 * avg_element_size 
    R_final = max(R_final, R_abs_min)

    product_val = effective_threshold * R_final
    limit_val   = C_safe * d_min_phys
    margin_pct  = ((limit_val - product_val) / limit_val) * 100.0
    
    status_str = "[SAFE]"
    if margin_pct < 0; status_str = "[VIOLATION]";
    elseif margin_pct < 5.0; status_str = "[CRITICAL]";
    elseif margin_pct < 15.0; status_str = "[TIGHT]"; end
    
    is_constrained = (R_final < r_baseline)
    constrained_flag = is_constrained ? "[CONSTRAINED]" : ""
    R_in_elements = R_final / avg_element_size

    println("\n")
    println(@sprintf("  COUPLED FILTER SCHEDULE (Iter %d) [%s]", iter, active_constraint))
    println("")
    println(@sprintf("  Avg Element Size:         %.4f m", avg_element_size))
    println(@sprintf("  Requested Physical:       %.4f m", target_d_phys))
    println(@sprintf("  Stability Floor:          %.4f m (%.1f elems)", floor_d_phys, floor_d_elems))
    println("")
    println(@sprintf("  Effective d_min:          %.4f m (%.1f elems)", d_min_phys, d_min_elems))
    println(@sprintf("  Radius (Final):           %.4f m (%.1f elems) %s", R_final, R_in_elements, constrained_flag))
    println("")
    println(@sprintf("  Cutoff Exponent:          %.2f", exponent_cutoff))
    println(@sprintf("  Constraint Margin:        %.1f%%  %s", margin_pct, status_str))
    println("\n")

    filtered_density_field = proposed_density_field
    filter_time = 0.0
    
    if R_final > 1e-4
        t_start = time()
        
        
        filtered_density_field = GPUExplicitFilter.apply_explicit_filter!(
            proposed_density_field, 
            nElem_x, nElem_y, nElem_z,
            dx, dy, dz, R_final,
            min_density 
        )
        
        filter_time = time() - t_start
        
        if iter % 10 == 1
            verify_boundary_filtering_detailed(proposed_density_field, filtered_density_field, 
                                               nElem_x, nElem_y, nElem_z)
        end
        
        if any(isnan, filtered_density_field) || any(isinf, filtered_density_field)
            println("\u001b[33m" * ">>> [SAFEGUARD] Filter produced NaNs/Infs. Triggering emergency box filter." * "\u001b[0m")
            
            filtered_density_field = apply_emergency_box_filter(
                proposed_density_field, nElem_x, nElem_y, nElem_z
            )
            
            if any(isnan, filtered_density_field)
                println("\u001b[31m" * ">>> [CRITICAL] Emergency filter also failed. Using unfiltered density." * "\u001b[0m")
                filtered_density_field = proposed_density_field
            end
        end
    end
    
    filtered_density_field = clamp.(filtered_density_field, min_density, max_density)
    
    blend_depth = max(3, round(Int, R_final / avg_element_size / 2))
    transition_zone = create_transition_zone(protected_elements_mask, nElem_x, nElem_y, nElem_z, blend_depth)
    
    n_chunks = Threads.nthreads()
    chunk_size = cld(nElem, n_chunks)
    partial_stats = Vector{Tuple{Float32, Int}}(undef, n_chunks)
    
    @sync for (i, chunk_range) in enumerate(Iterators.partition(1:nElem, chunk_size))
        Threads.@spawn begin
            local_change = 0.0f0
            local_active = 0
            for e in chunk_range
                if !protected_elements_mask[e] 
                    old_val = density[e]
                    raw_new_val = filtered_density_field[e]
                    density[e] = raw_new_val
                    if density[e] > min_density
                        local_active += 1
                    end
                    local_change += abs(raw_new_val - old_val)
                else
                    density[e] = original_density[e]
                    if density[e] > min_density
                        local_active += 1
                    end
                end
            end
            partial_stats[i] = (local_change, local_active)
        end
    end
    
    blend_transition_zone!(density, filtered_density_field, protected_elements_mask, 
                           transition_zone, original_density, nElem_x, nElem_y, nElem_z, blend_depth)
    
    total_change = 0.0f0
    total_active = 0
    for i in 1:length(partial_stats)
        if isassigned(partial_stats, i)
            (c, a) = partial_stats[i]
            total_change += c
            total_active += a
        end
    end
    
    mean_change = (total_active > 0) ? (total_change / Float32(total_active)) : 0.0f0
    
    
    
    max_culling_ratio = Float32(get(opt_params, "max_culling_ratio", 0.2)) 
    
    
    if is_annealing
        max_culling_ratio = min(max_culling_ratio, 0.02f0)
    end
    
    
    if force_no_cull
        max_culling_ratio = 0.0f0
        println("      [GRACE PERIOD] Culling disabled for structure recovery.")
    end

    cull_candidates = Int[]
    active_count = 0
    
    for e in 1:nElem
        if !protected_elements_mask[e] && !transition_zone[e]
            if density[e] > max_density
                density[e] = max_density
            end
            
            if density[e] > min_density
                active_count += 1
                if density[e] < current_threshold
                    push!(cull_candidates, e)
                end
            end
        else
             if density[e] > min_density
                 active_count += 1
             end
        end
    end
    
    max_allowed_culls = floor(Int, active_count * max_culling_ratio)
    
    if length(cull_candidates) > max_allowed_culls
        sort!(cull_candidates, by = idx -> density[idx])
        for i in 1:max_allowed_culls
            idx = cull_candidates[i]
            density[idx] = min_density
        end
    else
        for idx in cull_candidates
            density[idx] = min_density
        end
    end

    update_method = get(opt_params, "density_update_method", "soft")
    if update_method == "hard"
        Threads.@threads for e in 1:nElem
            if !protected_elements_mask[e] && !transition_zone[e]
                if density[e] > min_density
                    density[e] = 1.0f0
                end
            end
        end
    end

    Threads.@threads for e in 1:nElem
        if protected_elements_mask[e]
            density[e] = original_density[e]
        end
    end
    
    return mean_change, R_final, current_threshold, filter_time, 0, 0.0
end

end
"// # FILE: .\src\Solvers\CPUSolver.jl";

module CPUSolver

using LinearAlgebra, SparseArrays, Base.Threads, Printf
using ..Element

export MatrixFreeSystem, solve_system_cpu

struct MatrixFreeSystem{T}
    nodes::Matrix{T}
    elements::Matrix{Int}
    E::T
    nu::T
    bc_indicator::Matrix{T}
    free_dofs::Vector{Int}
    constrained_dofs::Vector{Int}
    density::Vector{T}
    min_stiffness_threshold::T 
    canonical_ke::Matrix{T}
end

function MatrixFreeSystem(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                          bc_indicator::Matrix{T}, density::Vector{T}=nothing,
                          min_stiffness_threshold::T=Float32(1.0e-3)) where T
                                    
    nElem = size(elements, 1)
    if density === nothing; density = ones(T, nElem); end

    nNodes = size(nodes, 1)
    ndof   = nNodes * 3
    constrained = falses(ndof)
    @inbounds for i in 1:nNodes
        if bc_indicator[i,1]>0; constrained[3*(i-1)+1]=true; end
        if bc_indicator[i,2]>0; constrained[3*(i-1)+2]=true; end
        if bc_indicator[i,3]>0; constrained[3*(i-1)+3]=true; end
    end

    free_dofs        = findall(!, constrained)
    constrained_dofs = findall(x->x, constrained)

    n1, n2, n4, n5 = nodes[elements[1,1], :], nodes[elements[1,2], :], nodes[elements[1,4], :], nodes[elements[1,5], :]
    dx, dy, dz = norm(n2-n1), norm(n4-n1), norm(n5-n1)
    canonical_ke = Element.get_canonical_stiffness(dx, dy, dz, nu)

    return MatrixFreeSystem(nodes, elements, E, nu, bc_indicator,
                            free_dofs, constrained_dofs, density,
                            min_stiffness_threshold, canonical_ke) 
end

"""
    apply_stiffness(system, x)

Updated to use Task-Based Partitioning instead of threadid() indexing.
This prevents BoundsErrors when thread IDs exceed nthreads().
"""
function apply_stiffness(system::MatrixFreeSystem{T}, x::Vector{T}) where T
    nNodes = size(system.nodes, 1)
    ndof   = nNodes * 3
    nElem  = size(system.elements, 1)

    result = zeros(T, ndof)
    
    
    n_chunks = Threads.nthreads()
    chunk_size = cld(nElem, n_chunks)
    
    
    partial_results = Vector{Vector{T}}(undef, n_chunks)

    Ke_base = system.canonical_ke

    @sync for (i, chunk_range) in enumerate(Iterators.partition(1:nElem, chunk_size))
        Threads.@spawn begin
            
            local_res = zeros(T, ndof)
            
            
            u_elem = zeros(T, 24)
            
            for e in chunk_range
                dens = system.density[e]
                if dens >= system.min_stiffness_threshold
                    conn = view(system.elements, e, :)
                    factor = system.E * dens

                    
                    for k in 1:8
                        node_id = conn[k]
                        base = 3*(node_id-1)
                        u_elem[3*(k-1)+1] = x[base+1]
                        u_elem[3*(k-1)+2] = x[base+2]
                        u_elem[3*(k-1)+3] = x[base+3]
                    end

                    
                    
                    
                    f_elem = (Ke_base * u_elem) .* factor

                    
                    for k in 1:8
                        node_id = conn[k]
                        base = 3*(node_id-1)
                        local_res[base+1] += f_elem[3*(k-1)+1]
                        local_res[base+2] += f_elem[3*(k-1)+2]
                        local_res[base+3] += f_elem[3*(k-1)+3]
                    end
                end
            end
            partial_results[i] = local_res
        end
    end

    
    for res in partial_results
        if isassigned(partial_results, 1) && res !== nothing
            result .+= res
        end
    end
    
    return result
end

function apply_system(system::MatrixFreeSystem{T}, x::Vector{T}) where T
    return apply_stiffness(system, x)
end

function apply_system_free_dofs(system::MatrixFreeSystem{T}, x_free::Vector{T}) where T
    nNodes = size(system.nodes, 1)
    ndof   = nNodes * 3
    x_full = zeros(T, ndof)
    x_full[system.free_dofs] = x_free
    result_full = apply_system(system, x_full)
    return result_full[system.free_dofs]
end

"""
    compute_diagonal_preconditioner(system)

Updated to use Task-Based Partitioning.
"""
function compute_diagonal_preconditioner(system::MatrixFreeSystem{T}) where T
    nNodes = size(system.nodes, 1)
    ndof   = nNodes*3
    nElem  = size(system.elements, 1)
    
    diag_vec = zeros(T, ndof)
    
    n_chunks = Threads.nthreads()
    chunk_size = cld(nElem, n_chunks)
    partial_diags = Vector{Vector{T}}(undef, n_chunks)
    
    Ke_base = system.canonical_ke

    @sync for (i, chunk_range) in enumerate(Iterators.partition(1:nElem, chunk_size))
        Threads.@spawn begin
            local_diag = zeros(T, ndof)
            
            for e in chunk_range
                dens = system.density[e]
                if dens >= system.min_stiffness_threshold
                    conn = view(system.elements, e, :)
                    factor = system.E * dens

                    for k in 1:8
                        node_id = conn[k]
                        base_dof = 3*(k-1) 
                        
                        diag_val_x = Ke_base[base_dof+1, base_dof+1] * factor
                        diag_val_y = Ke_base[base_dof+2, base_dof+2] * factor
                        diag_val_z = Ke_base[base_dof+3, base_dof+3] * factor
                        
                        global_idx = 3*(node_id-1)
                        local_diag[global_idx+1] += diag_val_x
                        local_diag[global_idx+2] += diag_val_y
                        local_diag[global_idx+3] += diag_val_z
                    end
                end
            end
            partial_diags[i] = local_diag
        end
    end

    for d in partial_diags
        if isassigned(partial_diags, 1) && d !== nothing
            diag_vec .+= d
        end
    end
    return diag_vec
end

function matrix_free_cg_solve(system::MatrixFreeSystem{T}, f::Vector{T};
                              max_iter=1000, tol=1e-6, use_precond=true,
                              shift_factor::T=Float32(1.0e-6)) where T  
    f_free = f[system.free_dofs]
    n_free = length(system.free_dofs)
    x_free = zeros(T, n_free)

    diag_full = compute_diagonal_preconditioner(system)
    diag_free = diag_full[system.free_dofs]

    shift = T(0.0)
    try
        max_diag = maximum(diag_free)
        shift = shift_factor * max_diag
        println("CPUSolver: Applying diagonal shift: $shift (Factor: $shift_factor)")
    catch e
        @warn "Could not calculate diagonal shift: $e"
    end
    
    r = copy(f_free)
    diag_free[diag_free .<= shift] .= shift
    z = use_precond ? r ./ diag_free : copy(r)
    p = copy(z)
    rz_old = dot(r, z)

    println("Starting matrix-free CG solve with $(n_free) unknowns on $(Threads.nthreads()) threads...")
    total_time = 0.0
    norm_f = norm(f_free)
    final_res_norm = 0.0

    if norm_f == 0
        return (zeros(T, length(f)), 0.0, "None")
    end

    for iter in 1:max_iter
        iter_start = time()
        Ap = apply_system_free_dofs(system, p) .+ (shift .* p)
        alpha = rz_old / dot(p, Ap)
        x_free .+= alpha .* p
        r .-= alpha .* Ap
        
        final_res_norm = norm(r) / norm_f
        total_time += (time() - iter_start)

        if final_res_norm < tol
            println("CG converged in $iter iterations, residual = $final_res_norm, total time = $total_time sec")
            break
        end

        
        diag_free[diag_free .<= shift] .= shift
        z = use_precond ? r ./ diag_free : copy(r)
        
        rz_new = dot(r, z)
        beta = rz_new / rz_old
        p .= z .+ beta .* p
        rz_old = rz_new
    end

    x_full = zeros(T, length(f))
    x_full[system.free_dofs] = x_free
    
    return (x_full, final_res_norm, "Jacobi_CPU")
end

function solve_system_cpu(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                          bc_indicator::Matrix{T}, f::Vector{T};
                          max_iter=1000, tol=1e-6, use_precond=true,
                          density::Vector{T}=nothing,
                          shift_factor::T=Float32(1.0e-6),
                          min_stiffness_threshold::T=Float32(1.0e-3)) where T    
                                    
    system = MatrixFreeSystem(nodes, elements, E, nu, bc_indicator, density, min_stiffness_threshold)
    
    solve_start = time()
    solution = matrix_free_cg_solve(system, f, max_iter=max_iter, tol=tol, 
                                    use_precond=use_precond, shift_factor=shift_factor)
    solve_end = time()
    @printf("Total solution time (matrix-free CPU): %.6f sec\n", solve_end - solve_start)
    return solution
end

end
"// # FILE: .\src\Solvers\DirectSolver.jl";

module DirectSolver

using LinearAlgebra, SparseArrays, Base.Threads, Printf
using ..Element
using ..Boundary
using ..Mesh

export solve_system

function assemble_global_stiffness_parallel_optimized(nodes::Matrix{Float32},
                                                      elements::Matrix{Int},
                                                      E::Float32,
                                                      nu::Float32,
                                                      density::Vector{Float32},
                                                      min_stiffness_threshold::Float32) 
                                                      
    nElem = size(elements, 1)
    ndof = size(nodes, 1) * 3

    active_indices = findall(d -> d >= min_stiffness_threshold, density)
    nActive = length(active_indices)
    
    if nActive == 0; error("No active elements."); end

    n1, n2, n4, n5 = nodes[elements[1,1], :], nodes[elements[1,2], :], nodes[elements[1,4], :], nodes[elements[1,5], :]
    dx, dy, dz = norm(n2-n1), norm(n4-n1), norm(n5-n1)
    Ke_base = Element.get_canonical_stiffness(dx, dy, dz, nu)

    entries_per_elem = 576
    total_entries = nActive * entries_per_elem
    I_vec = Vector{Int32}(undef, total_entries)
    J_vec = Vector{Int32}(undef, total_entries)
    V_vec = Vector{Float32}(undef, total_entries)

    Threads.@threads for t_idx in 1:length(active_indices)
        e = active_indices[t_idx]
        offset = (t_idx - 1) * entries_per_elem
        factor = E * density[e]
        conn = view(elements, e, :)
        
        cnt = 0
        @inbounds for i in 1:8
            row_idx = 3*(conn[i]-1)
            for r in 1:3
                g_row = row_idx + r
                for j in 1:8
                    col_idx = 3*(conn[j]-1)
                    for c in 1:3
                        g_col = col_idx + c
                        cnt += 1
                        
                        I_vec[offset+cnt] = Int32(g_row)
                        J_vec[offset+cnt] = Int32(g_col)
                        V_vec[offset+cnt] = Ke_base[3*(i-1)+r, 3*(j-1)+c] * factor
                    end
                end
            end
        end
    end

    K_global = sparse(I_vec, J_vec, V_vec, ndof, ndof)
    return (K_global + K_global') / 2.0f0
end

function solve_system(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T,
                      bc_indicator::Matrix{T}, f::Vector{T};
                      density::Vector{T}=nothing,
                      shift_factor::T=Float32(1.0e-6),
                      min_stiffness_threshold::T=Float32(1.0e-3)) where T    
                                    
    nElem = size(elements,1)
    if density === nothing
        density = ones(T, nElem)
    end

    nNodes = size(nodes, 1)
    ndof   = nNodes * 3

    constrained = falses(ndof)
    for i in 1:nNodes
        if bc_indicator[i,1]>0; constrained[3*(i-1)+1]=true; end
        if bc_indicator[i,2]>0; constrained[3*(i-1)+2]=true; end
        if bc_indicator[i,3]>0; constrained[3*(i-1)+3]=true; end
    end
    free_dofs = findall(!, constrained)

    K_global = assemble_global_stiffness_parallel_optimized(nodes, elements, E, nu, density, min_stiffness_threshold)

    K_reduced = K_global[free_dofs, free_dofs]
    F_reduced = f[free_dofs]

    try
        max_diag = maximum(abs.(diag(K_reduced)))
        shift = shift_factor * max_diag
        println("DirectSolver: Applying diagonal shift: $shift (Factor: $shift_factor)")
        K_reduced = K_reduced + shift * I
    catch e
        @warn "Could not apply diagonal shift: $e"
    end
    
    println("Solving linear system via LU factorization (CPU Direct).")
    U_reduced = K_reduced \ F_reduced

    U_full = zeros(T, ndof)
    U_full[free_dofs] = U_reduced

    return (U_full, 0.0, "Direct_LU")
end

end
"// # FILE: .\src\Solvers\GPUGeometricMultigrid.jl";

module GPUGeometricMultigrid

using CUDA
using LinearAlgebra
using SparseArrays
using Printf
using ..Element
using ..Mesh 

export MGWorkspace, setup_multigrid, apply_mg_vcycle!, clear_multigrid_cache!

mutable struct MGWorkspace
    is_initialized::Bool
    levels::Int  

    
    nf_x::Int; nf_y::Int; nf_z::Int
    fine_nodes_norm::Any          
    
    
    nc_x::Int; nc_y::Int; nc_z::Int
    r_med::Any        
    x_med::Any        
    diag_med::Any     
    density_med::Any
    conn_med::Any
    dx_m::Float32; dy_m::Float32; dz_m::Float32
    med_nodes_norm::Any             

    
    n_cst_x::Int; n_cst_y::Int; n_cst_z::Int
    r_cst::Any
    x_cst::Any
    diag_cst::Any
    density_cst::Any
    conn_cst::Any
    dx_cst::Float32; dy_cst::Float32; dz_cst::Float32
    cst_nodes_norm::Any

    
    n_l4_x::Int; n_l4_y::Int; n_l4_z::Int
    r_l4::Any
    x_l4::Any
    diag_l4::Any
    density_l4::Any
    conn_l4::Any
    dx_l4::Float32; dy_l4::Float32; dz_l4::Float32

    
    r_fine_full::Any
    z_fine_full::Any
    
    MGWorkspace() = new(false, 2, 
                        
                        0,0,0, nothing,
                        
                        0,0,0, nothing, nothing, nothing, nothing, nothing, 1.0, 1.0, 1.0, nothing,
                        
                        0,0,0, nothing, nothing, nothing, nothing, nothing, 1.0, 1.0, 1.0, nothing,
                        
                        0,0,0, nothing, nothing, nothing, nothing, nothing, 1.0, 1.0, 1.0,
                        
                        nothing, nothing)
end

const GLOBAL_MG_CACHE = MGWorkspace()


function compute_diagonal_atomic_kernel!(diag_vec, conn, Ke_diag, factors, nElem)
    e = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if e <= nElem
        base_idx = (e - 1) * 8
        factor = factors[e]
        for i in 1:8
            node = conn[base_idx + i]
            k_val = Ke_diag[(i-1)*3 + 1] * factor
            CUDA.atomic_add!(pointer(diag_vec, (node - 1) * 3 + 1), k_val)
            CUDA.atomic_add!(pointer(diag_vec, (node - 1) * 3 + 2), k_val)
            CUDA.atomic_add!(pointer(diag_vec, (node - 1) * 3 + 3), k_val)
        end
    end
    return nothing
end


function restrict_residual_structured_kernel!(r_coarse, r_fine, nx_f, ny_f, nz_f, nx_c, ny_c, nz_c)
    idx = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    nNodes_fine = (nx_f + 1) * (ny_f + 1) * (nz_f + 1)
    
    if idx <= nNodes_fine
        
        slice_f = (nx_f + 1) * (ny_f + 1)
        k_f = div(idx - 1, slice_f)
        rem_k = (idx - 1) - k_f * slice_f
        j_f = div(rem_k, nx_f + 1)
        i_f = rem_k - j_f * (nx_f + 1)
        
        
        f_base = (idx - 1) * 3
        rf_x = r_fine[f_base + 1]
        rf_y = r_fine[f_base + 2]
        rf_z = r_fine[f_base + 3]
        
        
        if abs(rf_x) + abs(rf_y) + abs(rf_z) < 1.0f-12
            return nothing
        end

        
        x_c_pos = Float32(i_f) * 0.5f0
        y_c_pos = Float32(j_f) * 0.5f0
        z_c_pos = Float32(k_f) * 0.5f0
        
        i0 = floor(Int, x_c_pos)
        j0 = floor(Int, y_c_pos)
        k0 = floor(Int, z_c_pos)
        
        tx = x_c_pos - Float32(i0)
        ty = y_c_pos - Float32(j0)
        tz = z_c_pos - Float32(k0)
        
        nx_nodes_c = nx_c + 1
        ny_nodes_c = ny_c + 1
        slice_c = nx_nodes_c * ny_nodes_c
        
        
        
        
        
        ii, jj, kk = i0, j0, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (1.0f0 - ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end

        
        ii, jj, kk = i0 + 1, j0, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (1.0f0 - ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end

        
        ii, jj, kk = i0, j0 + 1, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end

        
        ii, jj, kk = i0 + 1, j0 + 1, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end

        
        ii, jj, kk = i0, j0, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (1.0f0 - ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end

        
        ii, jj, kk = i0 + 1, j0, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (1.0f0 - ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end

        
        ii, jj, kk = i0, j0 + 1, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end

        
        ii, jj, kk = i0 + 1, j0 + 1, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                CUDA.atomic_add!(pointer(r_coarse, c_base + 1), rf_x * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 2), rf_y * w)
                CUDA.atomic_add!(pointer(r_coarse, c_base + 3), rf_z * w)
            end
        end
    end
    return nothing
end


function prolongate_correction_structured_kernel!(x_fine, x_coarse, nx_f, ny_f, nz_f, nx_c, ny_c, nz_c)
    idx = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    nNodes_fine = (nx_f + 1) * (ny_f + 1) * (nz_f + 1)
    
    if idx <= nNodes_fine
        slice_f = (nx_f + 1) * (ny_f + 1)
        k_f = div(idx - 1, slice_f)
        rem_k = (idx - 1) - k_f * slice_f
        j_f = div(rem_k, nx_f + 1)
        i_f = rem_k - j_f * (nx_f + 1)
        
        x_c_pos = Float32(i_f) * 0.5f0
        y_c_pos = Float32(j_f) * 0.5f0
        z_c_pos = Float32(k_f) * 0.5f0
        
        i0 = floor(Int, x_c_pos)
        j0 = floor(Int, y_c_pos)
        k0 = floor(Int, z_c_pos)
        
        tx = x_c_pos - Float32(i0)
        ty = y_c_pos - Float32(j0)
        tz = z_c_pos - Float32(k0)
        
        
        val_x = 0.0f0
        val_y = 0.0f0
        val_z = 0.0f0
        
        nx_nodes_c = nx_c + 1
        ny_nodes_c = ny_c + 1
        slice_c = nx_nodes_c * ny_nodes_c
        
        
        
        
        
        ii, jj, kk = i0, j0, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (1.0f0 - ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end

        
        ii, jj, kk = i0 + 1, j0, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (1.0f0 - ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end

        
        ii, jj, kk = i0, j0 + 1, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end

        
        ii, jj, kk = i0 + 1, j0 + 1, k0
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (ty) * (1.0f0 - tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end

        
        ii, jj, kk = i0, j0, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (1.0f0 - ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end

        
        ii, jj, kk = i0 + 1, j0, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (1.0f0 - ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end

        
        ii, jj, kk = i0, j0 + 1, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (1.0f0 - tx) * (ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end

        
        ii, jj, kk = i0 + 1, j0 + 1, k0 + 1
        if ii >= 0 && ii <= nx_c && jj >= 0 && jj <= ny_c && kk >= 0 && kk <= nz_c
            w = (tx) * (ty) * (tz)
            if w > 1.0f-6
                c_idx = (ii + 1) + jj * nx_nodes_c + kk * slice_c
                c_base = (c_idx - 1) * 3
                val_x += x_coarse[c_base + 1] * w
                val_y += x_coarse[c_base + 2] * w
                val_z += x_coarse[c_base + 3] * w
            end
        end
        
        f_base = (idx - 1) * 3
        x_fine[f_base + 1] += val_x
        x_fine[f_base + 2] += val_y
        x_fine[f_base + 3] += val_z
    end
    return nothing
end

function normalize_coords_kernel!(out, pts, dx, dy, dz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if i <= size(pts, 1)
        out[i, 1] = pts[i, 1] / dx
        out[i, 2] = pts[i, 2] / dy
        out[i, 3] = pts[i, 3] / dz
    end
    return nothing
end

function map_density_kernel!(rho_c, coords, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if i <= size(coords, 1)
        ix = floor(Int, coords[i, 1])
        iy = floor(Int, coords[i, 2])
        iz = floor(Int, coords[i, 3])
        if ix >= 0 && iy >= 0 && iz >= 0 && ix < nx && iy < ny && iz < nz
            c_elem_idx = ix + 1 + iy * nx + iz * nx * ny
            rho_c[c_elem_idx] = 1.0f0 
        end
    end
    return nothing
end

function expand_kernel!(x_full, x_free, map, n_free)
    idx = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if idx <= n_free
        @inbounds x_full[map[idx]] = x_free[idx]
    end
    return nothing
end

function contract_add_kernel!(y_free, y_full, map, n_free)
    idx = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if idx <= n_free
        @inbounds y_free[idx] += y_full[map[idx]]
    end
    return nothing
end

function setup_multigrid(fine_nodes, fine_density, config)
    ws = GLOBAL_MG_CACHE
    
    if !isdefined(ws, :levels)
        error("MGWorkspace struct definition mismatch. Restart Julia.")
    end

    geom = config["geometry"]
    dx_f = Float32(get(geom, "dx_computed", 1.0)); dy_f = Float32(get(geom, "dy_computed", 1.0)); dz_f = Float32(get(geom, "dz_computed", 1.0))
    nx_f = Int(get(geom, "nElem_x_computed", 0)); ny_f = Int(get(geom, "nElem_y_computed", 0)); nz_f = Int(get(geom, "nElem_z_computed", 0))
    
    use_3_levels = (nx_f >= 16 && ny_f >= 16 && nz_f >= 16)
    
    
    nx_m_temp = max(1, div(nx_f, 2))
    nx_c_temp = max(1, div(nx_m_temp, 2))
    ny_m_temp = max(1, div(ny_f, 2))
    ny_c_temp = max(1, div(ny_m_temp, 2))
    nz_m_temp = max(1, div(nz_f, 2))
    nz_c_temp = max(1, div(nz_m_temp, 2))

    use_4_levels = use_3_levels && (nx_c_temp >= 16 && ny_c_temp >= 16 && nz_c_temp >= 16)

    if use_4_levels
        ws.levels = 4
    elseif use_3_levels
        ws.levels = 3
    else
        ws.levels = 2
    end
    
    
    ws.nf_x = nx_f; ws.nf_y = ny_f; ws.nf_z = nz_f

    nx_m = max(1, div(nx_f, 2)); ny_m = max(1, div(ny_f, 2)); nz_m = max(1, div(nz_f, 2))
    ws.dx_m = dx_f * 2.0; ws.dy_m = dy_f * 2.0; ws.dz_m = dz_f * 2.0
    ws.nc_x = nx_m; ws.nc_y = ny_m; ws.nc_z = nz_m
    
    nElem_m = nx_m * ny_m * nz_m
    nNodes_m = (nx_m + 1) * (ny_m + 1) * (nz_m + 1)
    
    if !ws.is_initialized || length(ws.density_med) != nElem_m
        clear_multigrid_cache!() 
        
        ws.r_med = CUDA.zeros(Float32, nNodes_m * 3)
        ws.x_med = CUDA.zeros(Float32, nNodes_m * 3)
        ws.diag_med = CUDA.zeros(Float32, nNodes_m * 3)
        ws.density_med = CUDA.zeros(Float32, nElem_m)
        nodes_m_cpu, elems_m, _ = Mesh.generate_mesh(nx_m, ny_m, nz_m)
        ws.conn_med = CuArray(Int32.(vec(elems_m')))
        
        nNodes_f = size(fine_nodes, 1)
        ws.fine_nodes_norm = CUDA.zeros(Float32, nNodes_f, 3)
        ws.r_fine_full = CUDA.zeros(Float32, nNodes_f * 3)
        ws.z_fine_full = CUDA.zeros(Float32, nNodes_f * 3)
        
        if ws.levels >= 3
            nx_c = max(1, div(nx_m, 2)); ny_c = max(1, div(ny_m, 2)); nz_c = max(1, div(nz_m, 2))
            ws.n_cst_x = nx_c; ws.n_cst_y = ny_c; ws.n_cst_z = nz_c
            ws.dx_cst = ws.dx_m * 2.0; ws.dy_cst = ws.dy_m * 2.0; ws.dz_cst = ws.dz_m * 2.0
            
            nElem_c = nx_c * ny_c * nz_c
            nNodes_c = (nx_c + 1) * (ny_c + 1) * (nz_c + 1)
            
            ws.r_cst = CUDA.zeros(Float32, nNodes_c * 3)
            ws.x_cst = CUDA.zeros(Float32, nNodes_c * 3)
            ws.diag_cst = CUDA.zeros(Float32, nNodes_c * 3)
            ws.density_cst = CUDA.zeros(Float32, nElem_c)
            _, elems_c, _ = Mesh.generate_mesh(nx_c, ny_c, nz_c)
            ws.conn_cst = CuArray(Int32.(vec(elems_c')))
            
            ws.med_nodes_norm = CUDA.zeros(Float32, nNodes_m, 3)
            nodes_m_gpu_temp = CuArray(nodes_m_cpu)
            @cuda threads=512 blocks=cld(nNodes_m, 512) normalize_coords_kernel!(
                ws.med_nodes_norm, nodes_m_gpu_temp, ws.dx_cst, ws.dy_cst, ws.dz_cst
            )
            CUDA.unsafe_free!(nodes_m_gpu_temp)
        end

        if ws.levels == 4
            nx_l4 = max(1, div(ws.n_cst_x, 2)); ny_l4 = max(1, div(ws.n_cst_y, 2)); nz_l4 = max(1, div(ws.n_cst_z, 2))
            ws.n_l4_x = nx_l4; ws.n_l4_y = ny_l4; ws.n_l4_z = nz_l4
            ws.dx_l4 = ws.dx_cst * 2.0; ws.dy_l4 = ws.dy_cst * 2.0; ws.dz_l4 = ws.dz_cst * 2.0

            nElem_l4 = nx_l4 * ny_l4 * nz_l4
            nNodes_l4 = (nx_l4 + 1) * (ny_l4 + 1) * (nz_l4 + 1)

            ws.r_l4 = CUDA.zeros(Float32, nNodes_l4 * 3)
            ws.x_l4 = CUDA.zeros(Float32, nNodes_l4 * 3)
            ws.diag_l4 = CUDA.zeros(Float32, nNodes_l4 * 3)
            ws.density_l4 = CUDA.zeros(Float32, nElem_l4)
            nodes_l3_cpu, elems_l3, _ = Mesh.generate_mesh(ws.n_cst_x, ws.n_cst_y, ws.n_cst_z) 
            _, elems_l4, _ = Mesh.generate_mesh(nx_l4, ny_l4, nz_l4)
            ws.conn_l4 = CuArray(Int32.(vec(elems_l4')))

            nNodes_c = (ws.n_cst_x + 1) * (ws.n_cst_y + 1) * (ws.n_cst_z + 1)
            ws.cst_nodes_norm = CUDA.zeros(Float32, nNodes_c, 3)
            
            
            nodes_l3_gpu_temp = CuArray(nodes_l3_cpu) 
            @cuda threads=512 blocks=cld(nNodes_c, 512) normalize_coords_kernel!(
                ws.cst_nodes_norm, nodes_l3_gpu_temp, ws.dx_l4, ws.dy_l4, ws.dz_l4
            )
            CUDA.unsafe_free!(nodes_l3_gpu_temp)
        end
        
        ws.is_initialized = true
    end
    
    nNodes_f = size(fine_nodes, 1)
    nodes_gpu_temp = CuArray(fine_nodes)
    @cuda threads=512 blocks=cld(nNodes_f, 512) normalize_coords_kernel!(
        ws.fine_nodes_norm, nodes_gpu_temp, ws.dx_m, ws.dy_m, ws.dz_m
    )
    CUDA.unsafe_free!(nodes_gpu_temp)
    
    fill!(ws.density_med, 0.001f0) 
    @cuda threads=512 blocks=cld(nNodes_f, 512) map_density_kernel!(
        ws.density_med, ws.fine_nodes_norm, ws.nc_x, ws.nc_y, ws.nc_z
    )
    
    fill!(ws.diag_med, 1.0f0)
    Ke_base_m = Element.get_canonical_stiffness(ws.dx_m, ws.dy_m, ws.dz_m, 0.3f0)
    Ke_diag_m = CuArray(diag(Ke_base_m))
    @cuda threads=512 blocks=cld(nElem_m, 512) compute_diagonal_atomic_kernel!(
        ws.diag_med, ws.conn_med, Ke_diag_m, ws.density_med, nElem_m
    )
    CUDA.unsafe_free!(Ke_diag_m)
    
    if ws.levels >= 3
        nodes_gpu_temp = CuArray(fine_nodes)
        fine_nodes_to_cst_norm = CUDA.zeros(Float32, nNodes_f, 3)
        @cuda threads=512 blocks=cld(nNodes_f, 512) normalize_coords_kernel!(
            fine_nodes_to_cst_norm, nodes_gpu_temp, ws.dx_m * 2.0, ws.dy_m * 2.0, ws.dz_m * 2.0
        )
        CUDA.unsafe_free!(nodes_gpu_temp)
        
        fill!(ws.density_cst, 0.001f0)
        @cuda threads=512 blocks=cld(nNodes_f, 512) map_density_kernel!(
            ws.density_cst, fine_nodes_to_cst_norm, ws.n_cst_x, ws.n_cst_y, ws.n_cst_z
        )
        CUDA.unsafe_free!(fine_nodes_to_cst_norm)
        
        fill!(ws.diag_cst, 1.0f0)
        Ke_base_c = Element.get_canonical_stiffness(ws.dx_cst, ws.dy_cst, ws.dz_cst, 0.3f0)
        Ke_diag_c = CuArray(diag(Ke_base_c))
        nElem_c = ws.n_cst_x * ws.n_cst_y * ws.n_cst_z
        @cuda threads=512 blocks=cld(nElem_c, 512) compute_diagonal_atomic_kernel!(
            ws.diag_cst, ws.conn_cst, Ke_diag_c, ws.density_cst, nElem_c
        )
        CUDA.unsafe_free!(Ke_diag_c)
    end

    if ws.levels == 4
        
        nodes_gpu_temp = CuArray(fine_nodes)
        fine_nodes_to_l4_norm = CUDA.zeros(Float32, nNodes_f, 3)
        @cuda threads=512 blocks=cld(nNodes_f, 512) normalize_coords_kernel!(
            fine_nodes_to_l4_norm, nodes_gpu_temp, ws.dx_l4, ws.dy_l4, ws.dz_l4
        )
        CUDA.unsafe_free!(nodes_gpu_temp)

        fill!(ws.density_l4, 0.001f0)
        @cuda threads=512 blocks=cld(nNodes_f, 512) map_density_kernel!(
            ws.density_l4, fine_nodes_to_l4_norm, ws.n_l4_x, ws.n_l4_y, ws.n_l4_z
        )
        CUDA.unsafe_free!(fine_nodes_to_l4_norm)

        fill!(ws.diag_l4, 1.0f0)
        Ke_base_l4 = Element.get_canonical_stiffness(ws.dx_l4, ws.dy_l4, ws.dz_l4, 0.3f0)
        Ke_diag_l4 = CuArray(diag(Ke_base_l4))
        nElem_l4 = ws.n_l4_x * ws.n_l4_y * ws.n_l4_z
        @cuda threads=512 blocks=cld(nElem_l4, 512) compute_diagonal_atomic_kernel!(
            ws.diag_l4, ws.conn_l4, Ke_diag_l4, ws.density_l4, nElem_l4
        )
        CUDA.unsafe_free!(Ke_diag_l4)
    end
    
    return ws
end

function apply_mg_vcycle!(z_fine_free, r_fine_free, ws::MGWorkspace, fine_diag_inv_free, map_gpu, n_free)
    
    @. z_fine_free = r_fine_free * fine_diag_inv_free
    
    
    fill!(ws.r_fine_full, 0.0f0)
    @cuda threads=512 blocks=cld(n_free, 512) expand_kernel!(ws.r_fine_full, r_fine_free, map_gpu, n_free)
    
    fill!(ws.r_med, 0.0f0)
    
    
    nNodes_f = size(ws.fine_nodes_norm, 1)
    
    @cuda threads=512 blocks=cld(nNodes_f, 512) restrict_residual_structured_kernel!(
        ws.r_med, ws.r_fine_full, ws.nf_x, ws.nf_y, ws.nf_z, ws.nc_x, ws.nc_y, ws.nc_z
    )
    
    
    @. ws.x_med = ws.r_med / (ws.diag_med + 1.0f-9)
    
    if ws.levels >= 3
        
        fill!(ws.r_cst, 0.0f0)
        nNodes_m = size(ws.med_nodes_norm, 1)
        
        @cuda threads=512 blocks=cld(nNodes_m, 512) restrict_residual_structured_kernel!(
            ws.r_cst, ws.r_med, ws.nc_x, ws.nc_y, ws.nc_z, ws.n_cst_x, ws.n_cst_y, ws.n_cst_z
        )
        
        
        @. ws.x_cst = ws.r_cst / (ws.diag_cst + 1.0f-9)

        if ws.levels == 4
            
            fill!(ws.r_l4, 0.0f0)
            nNodes_c = size(ws.cst_nodes_norm, 1)

            @cuda threads=512 blocks=cld(nNodes_c, 512) restrict_residual_structured_kernel!(
                ws.r_l4, ws.r_cst, ws.n_cst_x, ws.n_cst_y, ws.n_cst_z, ws.n_l4_x, ws.n_l4_y, ws.n_l4_z
            )

            @. ws.x_l4 = ws.r_l4 / (ws.diag_l4 + 1.0f-9)

            
            @cuda threads=512 blocks=cld(nNodes_c, 512) prolongate_correction_structured_kernel!(
                ws.x_cst, ws.x_l4, ws.n_cst_x, ws.n_cst_y, ws.n_cst_z, ws.n_l4_x, ws.n_l4_y, ws.n_l4_z
            )
        end
        
        
        @cuda threads=512 blocks=cld(nNodes_m, 512) prolongate_correction_structured_kernel!(
            ws.x_med, ws.x_cst, ws.nc_x, ws.nc_y, ws.nc_z, ws.n_cst_x, ws.n_cst_y, ws.n_cst_z
        )
    end
    
    
    fill!(ws.z_fine_full, 0.0f0)
    @cuda threads=512 blocks=cld(nNodes_f, 512) prolongate_correction_structured_kernel!(
        ws.z_fine_full, ws.x_med, ws.nf_x, ws.nf_y, ws.nf_z, ws.nc_x, ws.nc_y, ws.nc_z
    )
    
    
    @cuda threads=512 blocks=cld(n_free, 512) contract_add_kernel!(z_fine_free, ws.z_fine_full, map_gpu, n_free)
    
    return nothing
end

function clear_multigrid_cache!()
    ws = GLOBAL_MG_CACHE
    if ws.is_initialized
        if ws.r_med !== nothing; CUDA.unsafe_free!(ws.r_med); ws.r_med = nothing; end
        if ws.x_med !== nothing; CUDA.unsafe_free!(ws.x_med); ws.x_med = nothing; end
        if ws.diag_med !== nothing; CUDA.unsafe_free!(ws.diag_med); ws.diag_med = nothing; end
        if ws.density_med !== nothing; CUDA.unsafe_free!(ws.density_med); ws.density_med = nothing; end
        if ws.conn_med !== nothing; CUDA.unsafe_free!(ws.conn_med); ws.conn_med = nothing; end
        
        if ws.r_cst !== nothing; CUDA.unsafe_free!(ws.r_cst); ws.r_cst = nothing; end
        if ws.x_cst !== nothing; CUDA.unsafe_free!(ws.x_cst); ws.x_cst = nothing; end
        if ws.diag_cst !== nothing; CUDA.unsafe_free!(ws.diag_cst); ws.diag_cst = nothing; end
        if ws.density_cst !== nothing; CUDA.unsafe_free!(ws.density_cst); ws.density_cst = nothing; end
        if ws.conn_cst !== nothing; CUDA.unsafe_free!(ws.conn_cst); ws.conn_cst = nothing; end

        if ws.r_l4 !== nothing; CUDA.unsafe_free!(ws.r_l4); ws.r_l4 = nothing; end
        if ws.x_l4 !== nothing; CUDA.unsafe_free!(ws.x_l4); ws.x_l4 = nothing; end
        if ws.diag_l4 !== nothing; CUDA.unsafe_free!(ws.diag_l4); ws.diag_l4 = nothing; end
        if ws.density_l4 !== nothing; CUDA.unsafe_free!(ws.density_l4); ws.density_l4 = nothing; end
        if ws.conn_l4 !== nothing; CUDA.unsafe_free!(ws.conn_l4); ws.conn_l4 = nothing; end

        if ws.fine_nodes_norm !== nothing; CUDA.unsafe_free!(ws.fine_nodes_norm); ws.fine_nodes_norm = nothing; end
        if ws.med_nodes_norm !== nothing; CUDA.unsafe_free!(ws.med_nodes_norm); ws.med_nodes_norm = nothing; end
        if ws.cst_nodes_norm !== nothing; CUDA.unsafe_free!(ws.cst_nodes_norm); ws.cst_nodes_norm = nothing; end
        
        if ws.r_fine_full !== nothing; CUDA.unsafe_free!(ws.r_fine_full); ws.r_fine_full = nothing; end
        if ws.z_fine_full !== nothing; CUDA.unsafe_free!(ws.z_fine_full); ws.z_fine_full = nothing; end

        ws.is_initialized = false
    end
end

end
"// # FILE: .\src\Solvers\GPUSolver.jl";

module GPUSolver

using LinearAlgebra, Printf
using CUDA
using SparseArrays
using Base.Threads
using Dates 
using Statistics
using ..Element
using ..GPUGeometricMultigrid 
using ..Diagnostics
using ..Helpers

export solve_system_gpu

const HISTORY_LOG_FILE = "convergence_history_log.txt"

function dual_log(msg::String; force_file::Bool=false)
    print(msg)
    if force_file
        clean_msg = replace(msg, r"\u001b\[[0-9;]*m" => "")
        try
            open(HISTORY_LOG_FILE, "a") do io; write(io, clean_msg); end
        catch e; @warn "Log write failed: $e"; end
    end
    flush(stdout)
end

function log_section_header(title::String, outer_iter::Any="?")
    width = 80
    s = "\n\u001b[36m" * "="^width * "\u001b[0m\n"
    full_title = "$title [Topo Opt Iter: $outer_iter]"
    pad = max(0, (width - length(full_title) - 2)  2)
    s *= " "^pad * "\u001b[1m" * full_title * "\u001b[0m\n"
    s *= "\u001b[36m" * "="^width * "\u001b[0m\n"
    dual_log(s; force_file=true)
end

mutable struct CGWorkspace
    is_initialized::Bool
    precision_type::DataType
    n_nodes_cached::Int  
    r::Any 
    p::Any
    z_Ap::Any 
    x::Any    
    conn_gpu::Any                
    factors_gpu::Any        
    Ke_gpu::Any                
    map_gpu::Any            
    CGWorkspace() = new(false, Float32, 0, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)
end

const GLOBAL_CG_CACHE = CGWorkspace()

function free_cg_workspace_if_needed(n_free::Int, n_elem::Int, n_nodes::Int)
    ws = GLOBAL_CG_CACHE
    if ws.is_initialized
        current_r_len = (ws.r !== nothing) ? length(ws.r) : 0
        current_factors_len = (ws.factors_gpu !== nothing) ? length(ws.factors_gpu) : 0
        
        if current_r_len != n_free || current_factors_len != n_elem || ws.n_nodes_cached != n_nodes
            dual_log("  [GPU Memory] Releasing Stale Solver Cache to free VRAM...\n"; force_file=true)
            if ws.r !== nothing; CUDA.unsafe_free!(ws.r); ws.r = nothing; end
            if ws.p !== nothing; CUDA.unsafe_free!(ws.p); ws.p = nothing; end
            if ws.z_Ap !== nothing; CUDA.unsafe_free!(ws.z_Ap); ws.z_Ap = nothing; end
            if ws.x !== nothing; CUDA.unsafe_free!(ws.x); ws.x = nothing; end
            if ws.conn_gpu !== nothing; CUDA.unsafe_free!(ws.conn_gpu); ws.conn_gpu = nothing; end
            if ws.factors_gpu !== nothing; CUDA.unsafe_free!(ws.factors_gpu); ws.factors_gpu = nothing; end
            if ws.Ke_gpu !== nothing; CUDA.unsafe_free!(ws.Ke_gpu); ws.Ke_gpu = nothing; end
            if ws.map_gpu !== nothing; CUDA.unsafe_free!(ws.map_gpu); ws.map_gpu = nothing; end
            ws.is_initialized = false
            ws.n_nodes_cached = 0
            Helpers.cleanup_memory()
        end
    end
end

function get_cg_workspace(n_free::Int, n_total_nodes::Int, n_elem::Int, T::DataType)
    ws = GLOBAL_CG_CACHE
    if !ws.is_initialized
        dual_log("  [GPU Alloc] Allocating solver workspace vectors... "; force_file=false)
        ws.r = CUDA.zeros(T, n_free)
        ws.p = CUDA.zeros(T, n_free)
        ws.z_Ap = CUDA.zeros(T, n_free) 
        ws.x = CUDA.zeros(T, n_free)
        ws.conn_gpu = CUDA.zeros(Int, n_elem * 8)
        ws.factors_gpu = CUDA.zeros(T, n_elem)
        ws.Ke_gpu = CUDA.zeros(T, 24, 24)
        ws.map_gpu = CUDA.zeros(Int, n_free) 
        ws.precision_type = T
        ws.n_nodes_cached = n_total_nodes
        ws.is_initialized = true
        dual_log("Done.\n"; force_file=false)
    end
    fill!(ws.r, T(0.0)); fill!(ws.p, T(0.0)); fill!(ws.z_Ap, T(0.0)); fill!(ws.x, T(0.0))
    return ws
end

function matvec_unstructured_atomic_kernel!(y_full, x_full, conn, Ke, factors, nElem, nDof)
    e = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if e <= nElem
        base_idx = (e - 1) * 8
        n1 = conn[base_idx+1]; n2 = conn[base_idx+2]; n3 = conn[base_idx+3]; n4 = conn[base_idx+4]
        n5 = conn[base_idx+5]; n6 = conn[base_idx+6]; n7 = conn[base_idx+7]; n8 = conn[base_idx+8]

        if n1 < 1 || n2 < 1 || n3 < 1 || n4 < 1 || n5 < 1 || n6 < 1 || n7 < 1 || n8 < 1
            return 
        end

        u1x = x_full[(n1-1)*3+1]; u1y = x_full[(n1-1)*3+2]; u1z = x_full[(n1-1)*3+3]
        u2x = x_full[(n2-1)*3+1]; u2y = x_full[(n2-1)*3+2]; u2z = x_full[(n2-1)*3+3]
        u3x = x_full[(n3-1)*3+1]; u3y = x_full[(n3-1)*3+2]; u3z = x_full[(n3-1)*3+3]
        u4x = x_full[(n4-1)*3+1]; u4y = x_full[(n4-1)*3+2]; u4z = x_full[(n4-1)*3+3]
        u5x = x_full[(n5-1)*3+1]; u5y = x_full[(n5-1)*3+2]; u5z = x_full[(n5-1)*3+3]
        u6x = x_full[(n6-1)*3+1]; u6y = x_full[(n6-1)*3+2]; u6z = x_full[(n6-1)*3+3]
        u7x = x_full[(n7-1)*3+1]; u7y = x_full[(n7-1)*3+2]; u7z = x_full[(n7-1)*3+3]
        u8x = x_full[(n8-1)*3+1]; u8y = x_full[(n8-1)*3+2]; u8z = x_full[(n8-1)*3+3]

        u_loc = (u1x, u1y, u1z, u2x, u2y, u2z, u3x, u3y, u3z, u4x, u4y, u4z, 
                 u5x, u5y, u5z, u6x, u6y, u6z, u7x, u7y, u7z, u8x, u8y, u8z)
        factor = factors[e]
        node_lookup = (n1, n2, n3, n4, n5, n6, n7, n8)

        @inbounds for i in 1:24
            val = zero(u1x)
            val += Ke[i, 1]*u_loc[1] + Ke[i, 2]*u_loc[2] + Ke[i, 3]*u_loc[3] + Ke[i, 4]*u_loc[4]
            val += Ke[i, 5]*u_loc[5] + Ke[i, 6]*u_loc[6] + Ke[i, 7]*u_loc[7] + Ke[i, 8]*u_loc[8]
            val += Ke[i, 9]*u_loc[9] + Ke[i, 10]*u_loc[10] + Ke[i, 11]*u_loc[11] + Ke[i, 12]*u_loc[12]
            val += Ke[i, 13]*u_loc[13] + Ke[i, 14]*u_loc[14] + Ke[i, 15]*u_loc[15] + Ke[i, 16]*u_loc[16]
            val += Ke[i, 17]*u_loc[17] + Ke[i, 18]*u_loc[18] + Ke[i, 19]*u_loc[19] + Ke[i, 20]*u_loc[20]
            val += Ke[i, 21]*u_loc[21] + Ke[i, 22]*u_loc[22] + Ke[i, 23]*u_loc[23] + Ke[i, 24]*u_loc[24]
            
            target_node_idx = (i - 1)  3 + 1
            target_node = node_lookup[target_node_idx]
            target_dof_idx = (target_node - 1) * 3 + (i - 1) % 3 + 1
            
            if target_dof_idx >= 1 && target_dof_idx <= nDof
                CUDA.atomic_add!(pointer(y_full, target_dof_idx), val * factor)
            end
        end
    end
    return nothing
end

function compute_diagonal_atomic_kernel!(diag_vec, conn, Ke_diag, factors, nElem, nDof)
    e = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if e <= nElem
        base_idx = (e - 1) * 8
        factor = factors[e]
        for i in 1:8
            node = conn[base_idx + i]
            if node < 1; continue; end
            idx1 = (node - 1) * 3 + 1
            idx3 = (node - 1) * 3 + 3
            if idx3 > nDof; continue; end
            k_val = Ke_diag[(i-1)*3 + 1] * factor
            CUDA.atomic_add!(pointer(diag_vec, idx1), k_val)
            CUDA.atomic_add!(pointer(diag_vec, idx1 + 1), k_val)
            CUDA.atomic_add!(pointer(diag_vec, idx1 + 2), k_val)
        end
    end
    return nothing
end

function expand_kernel!(x_full, x_free, map, n_free, nDof)
    idx = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if idx <= n_free
        target = map[idx]
        if target > 0 && target <= nDof
            @inbounds x_full[target] = x_free[idx]
        end
    end
    return nothing
end

function contract_kernel!(y_free, y_full, map, n_free, nDof)
    idx = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if idx <= n_free
        src = map[idx]
        if src > 0 && src <= nDof
            @inbounds y_free[idx] = y_full[src]
        end
    end
    return nothing
end

function jacobi_precond_kernel!(z, r, M_inv, n)
    idx = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if idx <= n
        @inbounds z[idx] = r[idx] * M_inv[idx]
    end
    return nothing
end

function get_free_dofs(bc_indicator)
    nNodes = size(bc_indicator, 1)
    ndof = nNodes * 3
    constrained = falses(ndof)
    for i in 1:nNodes
        if bc_indicator[i,1] > 0; constrained[3*(i-1)+1] = true; end
        if bc_indicator[i,2] > 0; constrained[3*(i-1)+2] = true; end
        if bc_indicator[i,3] > 0; constrained[3*(i-1)+3] = true; end
    end
    return findall(!, constrained)
end

function gpu_matrix_free_cg_solve(nodes, elements, E, nu, bc, f, density;
                                  max_iter=40000, tol=1e-6, shift_factor=1.0e-4,
                                  min_stiffness_threshold=1.0e-3, u_guess=[], config=Dict())
    
    
    Helpers.cleanup_memory()
    
    CUDA.allowscalar(false)
    gpu_profile = get(config, "hardware_profile_applied", "RTX")
    use_double = (gpu_profile == "H200" || gpu_profile == "V100" || gpu_profile == "A100") || get(config, "force_float64", false)
    T = use_double ? Float64 : Float32
    
    outer_iter = get(config, "current_outer_iter", "?")
    
    if outer_iter == 1 || outer_iter == "1"
        try
            open(HISTORY_LOG_FILE, "a") do io 
                write(io, "\n\n" * "-"^80 * "\n")
                write(io, "NEW JOB SESSION STARTED: $(Dates.now())\n")
                write(io, "-"^80 * "\n")
            end
        catch; end
    end
    
    solver_params = get(config, "solver_parameters", Dict())
    stagnation_tol = T(get(solver_params, "stagnation_tolerance", 0.0))
    max_shift_attempts = Int(get(solver_params, "max_shift_attempts", 3))
    shift_multiplier = T(get(solver_params, "shift_multiplier", 10.0))
    
    nNodes = size(nodes, 1)
    nElem = size(elements, 1)
    nDof = nNodes * 3
    free_dofs = get_free_dofs(bc)
    n_free = length(free_dofs)
    
    geom_conf = config["geometry"]
    dx = Float32(get(geom_conf, "dx_computed", 1.0))
    dy = Float32(get(geom_conf, "dy_computed", 1.0))
    dz = Float32(get(geom_conf, "dz_computed", 1.0))
    nx_f = Int(get(geom_conf, "nElem_x_computed", 0))
    ny_f = Int(get(geom_conf, "nElem_y_computed", 0))
    nz_f = Int(get(geom_conf, "nElem_z_computed", 0))
    
    want_mg = (get(solver_params, "preconditioner", "jacobi") == "multigrid")
    
    n_active_check = nElem
    if length(density) == nElem
        n_active_check = count(d -> d > min_stiffness_threshold, density)
    end

    # Clean existing workspace to ensure "fresh" VRAM for every solve
    free_cg_workspace_if_needed(n_free, nElem, nNodes)
    Helpers.enforce_gpu_memory_safety(n_active_check, nNodes, use_double, want_mg)
    
    if CUDA.functional()
        free_mem, tot_mem = CUDA.available_memory(), CUDA.total_memory()
        log_section_header("GPU SOLVER (ATOMIC)", outer_iter)
        dual_log(@sprintf("  Nodes: %d | Elems: %d | Free DOFs: %d\n", nNodes, nElem, n_free); force_file=true)
        dual_log(@sprintf("  Pre-Alloc VRAM: %.2f GB Free / %.2f GB Total\n", free_mem/1024^3, tot_mem/1024^3); force_file=true)
    end

    try 
        Helpers.log_gpu_state("Pre-Workspace Alloc")
        
        ws = get_cg_workspace(n_free, nNodes, nElem, T)
        
        Helpers.log_gpu_state("Post-Workspace Alloc")

        
        
        current_free = CUDA.available_memory()
        if current_free < (400 * 1024^2) && want_mg
            dual_log("\n\u001b[31m[CRITICAL MEMORY WARNING]\u001b[0m\n"; force_file=true)
            dual_log("  Free VRAM is critically low ($(round(current_free/1024^3, digits=2)) GB).\n"; force_file=true)
            dual_log("  Enabling Multigrid will likely freeze the system due to swapping.\n"; force_file=true)
            dual_log("  \u001b[33m>>> FORCING FALLBACK TO JACOBI PRECONDITIONER <<<\u001b[0m\n"; force_file=true)
            want_mg = false
        end
        
        Ke_base = Element.get_canonical_stiffness(dx, dy, dz, Float32(nu))
        copyto!(ws.Ke_gpu, Matrix{T}(Ke_base))
        
        
        Helpers.cleanup_memory()
        
        dual_log("  [GPU Data] GMG Mode: Using Implicit Connectivity (Saved ~0.01 GB).\n"; force_file=false)
        
        
        
        dual_log("  [GPU Data] Transferring connectivity (~$(round(nElem*8*4/1024^3, digits=2)) GB)... "; force_file=false)
        conn_flat = collect(vec(elements')) 
        copyto!(ws.conn_gpu, conn_flat) 
        dual_log("Done.\n"; force_file=false)
        
        dual_log("  [GPU Data] Transferring stiffness factors... "; force_file=false)
        fact_vec = Vector{T}(E .* density)
        copyto!(ws.factors_gpu, fact_vec) 
        dual_log("Done.\n"; force_file=false)
        
        dual_log("  [GPU Data] Transferring DOF map (~$(round(n_free*4/1024^3, digits=2)) GB)... "; force_file=false)
        copyto!(ws.map_gpu, free_dofs) 
        dual_log("Done.\n"; force_file=false)

        mg_ws = nothing
        if want_mg
            try
                dual_log("  [MG Init] Setting up Multigrid... \n"; force_file=false)
                mg_ws = GPUGeometricMultigrid.setup_multigrid(nodes, density, config)
                dual_log("\u001b[32m  [MG Init] Multigrid Levels Initialized Successfully:\u001b[0m\n"; force_file=true)
                dual_log(@sprintf("    Lv 1 (Fine): %dx%dx%d\n", nx_f, ny_f, nz_f); force_file=true)
                dual_log(@sprintf("    Lv 2 (Med):  %dx%dx%d\n", mg_ws.nc_x, mg_ws.nc_y, mg_ws.nc_z); force_file=true)
                if mg_ws.levels >= 3
                    dual_log(@sprintf("    Lv 3 (Cst):  %dx%dx%d\n", mg_ws.n_cst_x, mg_ws.n_cst_y, mg_ws.n_cst_z); force_file=true)
                end
                if mg_ws.levels == 4
                    dual_log(@sprintf("    Lv 4 (VCst): %dx%dx%d\n", mg_ws.n_l4_x, mg_ws.n_l4_y, mg_ws.n_l4_z); force_file=true)
                end
            catch e
                dual_log("\u001b[33m  [MG Init Failed] Error: $e. Falling back to Jacobi.\u001b[0m\n"; force_file=true)
                want_mg = false
                Helpers.cleanup_memory()
            end
        end
        
        x_gpu, r_gpu, p_gpu = ws.x, ws.r, ws.p
        Ap_free = ws.z_Ap; z_gpu = ws.z_Ap            
        conn_gpu = ws.conn_gpu; factors_gpu = ws.factors_gpu; Ke_gpu = ws.Ke_gpu; map_gpu = ws.map_gpu
        
        b_gpu = CuVector{T}(f[free_dofs])
        x_full = CUDA.zeros(T, nDof)
        Ap_full = CUDA.zeros(T, nDof)
        diag_full = CUDA.zeros(T, nDof)
        
        Ke_diag_cpu = diag(Ke_base)
        Ke_diag_gpu = CuArray{T}(Ke_diag_cpu)
        
        threads_per_block = 256
        @cuda threads=threads_per_block blocks=cld(nElem, threads_per_block) compute_diagonal_atomic_kernel!(
            diag_full, conn_gpu, Ke_diag_gpu, factors_gpu, nElem, nDof
        )
        
        diag_free = CUDA.zeros(T, n_free)
        @cuda threads=threads_per_block blocks=cld(n_free, threads_per_block) contract_kernel!(diag_free, diag_full, map_gpu, n_free, nDof)
        
        max_diag = maximum(diag_free)
        M_inv = CUDA.zeros(T, n_free)
        norm_b = norm(b_gpu)
        best_x = zeros(T, n_free)
        final_rel_res = 0.0
        
        function apply_A!(y_f, x_f)
            fill!(x_full, T(0.0)) 
            @cuda threads=threads_per_block blocks=cld(n_free, threads_per_block) expand_kernel!(x_full, x_f, map_gpu, n_free, nDof)
            fill!(Ap_full, T(0.0)) 
            @cuda threads=threads_per_block blocks=cld(nElem, threads_per_block) matvec_unstructured_atomic_kernel!(
                Ap_full, x_full, conn_gpu, Ke_gpu, factors_gpu, nElem, nDof
            )
            @cuda threads=threads_per_block blocks=cld(n_free, threads_per_block) contract_kernel!(y_f, Ap_full, map_gpu, n_free, nDof)
        end

        current_use_mg = want_mg
        global_solve_success = false
        
        while true
            precond_name = current_use_mg ? "Geometric Multigrid (V-Cycle)" : "Jacobi"
            dual_log(@sprintf("  Preconditioner: %s\n", precond_name); force_file=true)
            cur_shift = shift_factor
            solve_ok = false
            fallback_to_jacobi_immediate = false
            
            for attempt in 1:max_shift_attempts
                real_shift = cur_shift * max_diag
                dual_log(@sprintf("\n  >>> ATTEMPT %d | Shift: %.1e\n", attempt, real_shift); force_file=true)
                diverged = false
                
                if !isempty(u_guess) && attempt == 1 && current_use_mg == want_mg
                    copyto!(x_gpu, CuVector{T}(u_guess[free_dofs]))
                elseif attempt > 1 || current_use_mg != want_mg
                    fill!(x_gpu, T(0.0))
                end
                
                M_inv .= T(1.0) ./ (diag_free .+ real_shift)
                apply_A!(Ap_free, x_gpu)
                Ap_free .+= real_shift .* x_gpu
                r_gpu .= b_gpu .- Ap_free
                
                if current_use_mg
                    GPUGeometricMultigrid.apply_mg_vcycle!(z_gpu, r_gpu, mg_ws, M_inv, map_gpu, n_free)
                else
                    @cuda threads=threads_per_block blocks=cld(n_free, threads_per_block) jacobi_precond_kernel!(z_gpu, r_gpu, M_inv, n_free)
                end
                
                p_gpu .= z_gpu
                rz = dot(r_gpu, z_gpu)
                t_cg = time()
                best_rel = Inf
                last_rel_res = Inf 
                
                dual_log(@sprintf("  \u001b[1m%8s %12s %12s %10s %10s %10s %10s\u001b[0m\n", 
                                  "Iter", "Res", "RelRes", "Alpha", "Beta", "Time(s)", "Clock"); force_file=true)
                
                alpha_val = T(0.0)
                beta_val = T(0.0)

                for k in 1:max_iter
                    apply_A!(Ap_free, p_gpu)
                    Ap_free .+= real_shift .* p_gpu
                    
                    denom = dot(p_gpu, Ap_free)
                    
                    if abs(denom) < 1e-20
                        dual_log("\u001b[31m  >>> SINGULARITY DETECTED: Denom ~ 0 at iter $k. Aborting.\u001b[0m\n"; force_file=true)
                        diverged = true
                        break
                    end
                    
                    alpha = rz / denom
                    alpha_val = alpha 
                    
                    x_gpu .+= alpha .* p_gpu
                    r_gpu .-= alpha .* Ap_free
                    
                    if k % 500 == 0 || k == 1
                        res = sqrt(dot(r_gpu, r_gpu))
                        rel = res / norm_b
                        final_rel_res = rel
                        clock_now = Dates.format(now(), "HH:MM:SS")
                        
                        if rel < best_rel; best_rel = rel; copyto!(best_x, x_gpu); end
                        if rel < tol; solve_ok = true; break; end
                        
                        if isnan(rel) || isinf(rel)
                            dual_log("\u001b[31m  >>> NaN/Inf DETECTED at iter $k. Aborting attempt.\u001b[0m\n"; force_file=true)
                            if current_use_mg; fallback_to_jacobi_immediate = true; else; diverged = true; end
                            break
                        end

                        is_startup_transient = (k <= 20)
                        hard_divergence_limit = 100000.0
                        drift_limit = best_rel * 5000.0
                        
                        if !is_startup_transient && (rel > hard_divergence_limit || (k > 500 && rel > drift_limit))
                            dual_log("\u001b[31m  >>> DIVERGENCE DETECTED at iter $k (Rel=$rel).\u001b[0m\n"; force_file=true)
                            if current_use_mg; fallback_to_jacobi_immediate = true; else; diverged = true; end
                            break
                        end
                        
                        color = rel < tol ? "\u001b[32m" : (rel < 0.1 ? "\u001b[33m" : "\u001b[0m")
                        
                        dual_log(@sprintf("  %s%8d %12.4e %12.4e %10.2e %10.2e %10.3f %10s\u001b[0m\n", 
                                          color, k, res, rel, alpha_val, beta_val, time() - t_cg, clock_now); force_file=true)
                    end
                    
                    if k % 1000 == 0
                        improvement = (last_rel_res - final_rel_res) / (last_rel_res + 1e-20)
                        if improvement < 1e-4 && final_rel_res > tol
                            dual_log(@sprintf("   [STAGNATION CHECK] Iter %d: Improvement %.2e%% (Potential Stall)\n", k, improvement*100); force_file=true)
                        end
                        last_rel_res = final_rel_res
                    end
                    
                    if current_use_mg
                        GPUGeometricMultigrid.apply_mg_vcycle!(z_gpu, r_gpu, mg_ws, M_inv, map_gpu, n_free)
                    else
                        @cuda threads=threads_per_block blocks=cld(n_free, threads_per_block) jacobi_precond_kernel!(z_gpu, r_gpu, M_inv, n_free)
                    end
                    rz_new = dot(r_gpu, z_gpu)
                    beta = rz_new / rz
                    beta_val = beta 
                    
                    p_gpu .= z_gpu .+ beta .* p_gpu
                    rz = rz_new
                end
                
                if fallback_to_jacobi_immediate
                    dual_log("\u001b[33m  >>> RESTARTING SOLVE WITH JACOBI PRECONDITIONER <<<\u001b[0m\n"; force_file=true)
                    current_use_mg = false; continue
                end
                if solve_ok; global_solve_success = true; break; end
                if diverged
                    if attempt == max_shift_attempts
                    else; cur_shift *= shift_multiplier; continue; end
                end
                if stagnation_tol > 0.0 && best_rel < stagnation_tol
                    solve_ok = true; global_solve_success = true; copyto!(x_gpu, best_x)
                    dual_log(@sprintf("  [Adaptive] Stagnated below tolerance. Accepting.\n"); force_file=true)
                    break
                end
                cur_shift *= shift_multiplier
            end
            
            if fallback_to_jacobi_immediate
                dual_log("\u001b[33m  >>> RESTARTING SOLVE WITH JACOBI PRECONDITIONER <<<\u001b[0m\n"; force_file=true)
                current_use_mg = false; continue
            end
            if global_solve_success; break; else
                dual_log("\u001b[31m  [Failure] Solver failed to reach strict tolerance.\u001b[0m\n"; force_file=true)
                copyto!(x_gpu, best_x)
                break
            end
        end
        
        fill!(x_full, T(0.0))
        @cuda threads=threads_per_block blocks=cld(n_free, threads_per_block) expand_kernel!(x_full, x_gpu, map_gpu, n_free, nDof)
        x_final_full = Array(x_full) 
        CUDA.unsafe_free!(x_full); CUDA.unsafe_free!(Ap_full); CUDA.unsafe_free!(diag_full)
        CUDA.unsafe_free!(M_inv); CUDA.unsafe_free!(Ke_diag_gpu)
        CUDA.unsafe_free!(diag_free); CUDA.unsafe_free!(b_gpu)
        dual_log("\u001b[36m" * "-"^80 * "\u001b[0m\n"; force_file=true)
        final_method_name = current_use_mg ? "GMG_GPU" : "Jacobi_GPU"
        return (x_final_full, final_rel_res, final_method_name)

    finally
        
    end
end


function solve_system_gpu(nodes, elements, E, nu, bc, f, density;
                          max_iter=40000, tol=1e-6, method=:native, solver=:cg, use_precond=true,
                          shift_factor=1.0e-4, min_stiffness_threshold=1.0e-3, u_guess=[], config=Dict())
    if !CUDA.functional()
        error("CUDA not functional!")
    end
    return gpu_matrix_free_cg_solve(nodes, elements, E, nu, bc, f, density;
                                    max_iter=max_iter, tol=tol, shift_factor=shift_factor,
                                    min_stiffness_threshold=min_stiffness_threshold,
                                    u_guess=u_guess, config=config)
end

end
"// # FILE: .\src\Solvers\IterativeSolver.jl";
// 
module IterativeSolver 
 
using LinearAlgebra, Printf 
using ..CPUSolver 
using ..GPUSolver 
 
export solve_system_iterative 
 
function solve_system_iterative(nodes::Matrix{T}, elements::Matrix{Int}, E::T, nu::T, 
                                bc_indicator::Matrix{T}, f::Vector{T}; 
                                solver_type=:matrix_free, max_iter=1000, tol=1e-6, 
                                use_precond=true, density::Vector{T}=nothing, 
                                gpu_method=:native, krylov_solver=:cg, 
                                shift_factor::T=Float32(1.0e-6), 
                                min_stiffness_threshold::T=Float32(1.0e-3),
                                u_guess::AbstractVector=T[], 
                                config::Dict=Dict()) where T                                 
                                  
    if solver_type == :matrix_free 
        return CPUSolver.solve_system_cpu( 
            nodes, elements, E, nu, bc_indicator, f; 
            max_iter=max_iter, tol=tol, use_precond=use_precond,  
            density=density, shift_factor=shift_factor,  
            min_stiffness_threshold=min_stiffness_threshold 
        ) 
    elseif solver_type == :gpu 
        if density === nothing 
            error("You must provide a density array for GPU solver.") 
        end 
        
        
        return GPUSolver.solve_system_gpu( 
            nodes, elements, E, nu, bc_indicator, f, density; 
            max_iter=max_iter, tol=tol,  
            method=gpu_method, solver=krylov_solver, use_precond=use_precond, 
            shift_factor=shift_factor, 
            min_stiffness_threshold=min_stiffness_threshold,
            u_guess=u_guess, 
            config=config 
        ) 
    else 
        error("Unknown solver type: $solver_type. Use :matrix_free or :gpu.") 
    end 
end 
 
end
"// # FILE: .\src\Solvers\Solver.jl";
// 
module Solver 

using CUDA 
using Printf
using ..Helpers  
using ..DirectSolver: solve_system as solve_system_direct 
using ..IterativeSolver: solve_system_iterative 
using ..MeshPruner 

export solve_system 

function choose_solver(nNodes, nElem, config) 
    solver_params = config["solver_parameters"] 
    configured_type = Symbol(lowercase(get(solver_params, "solver_type", "direct"))) 

    if configured_type == :direct 
        if nElem > 100_000 
            @warn "Direct solver requested for large mesh ($(nElem) elements). Switching to Matrix-Free iterative." 
            return :matrix_free 
        end 
        return :direct 
    elseif configured_type == :gpu 
        if CUDA.functional() 
            return :gpu 
        else 
            @warn "No CUDA GPU detected. Falling back to CPU."
            return :matrix_free 
        end 
    elseif configured_type == :matrix_free 
        return :matrix_free 
    else 
        @warn "Unknown solver_type: $(configured_type). Defaulting to matrix_free." 
        return :matrix_free 
    end 
end 

function solve_system(nodes::AbstractMatrix{<:AbstractFloat}, 
                      elements::Matrix{Int}, 
                      E::AbstractFloat, 
                      nu::AbstractFloat, 
                      bc_indicator::AbstractMatrix{<:AbstractFloat}, 
                      F::AbstractVector{<:AbstractFloat}; 
                      density::AbstractVector{<:AbstractFloat}=Float32[], 
                      config::Dict, 
                      min_stiffness_threshold::AbstractFloat=1.0e-3f0,
                      prune_voids::Bool=true,
                      u_prev::AbstractVector{<:AbstractFloat}=Float32[]) 
      
    nNodes_solve = size(nodes, 1) 
    nElem_solve = size(elements, 1) 
      
    solver_params = config["solver_parameters"] 
    solver_type = choose_solver(nNodes_solve, nElem_solve, config) 
      
    target_tol = Float32(get(solver_params, "tolerance", 1.0e-6)) 
    max_iter = Int(get(solver_params, "max_iterations", 1000)) 
    shift_factor = Float32(get(solver_params, "diagonal_shift_factor", 1.0e-6)) 
    precond_type = get(solver_params, "preconditioner", "jacobi")
      
    iter_current = get(config, "current_outer_iter", 1) 
    
    
    if solver_type == :gpu
        tol_str = @sprintf("%.1e", target_tol)
        println("   [Solver] Strict Tol: $tol_str")
        
        is_huge_model = (nElem_solve > 5_000_000)
        use_double = get(config, "force_float64", false)

        if precond_type == "multigrid"
            
            
            feasible, req_gb, free_gb = Helpers.is_gmg_feasible_on_gpu(nElem_solve, use_double; config=config)
            
            if feasible
                
                if prune_voids
                    println("   [Solver] Pruning DISABLED (Required for Geometric Multigrid).")
                    prune_voids = false
                end
            else
                
                
                
                
                println("\n\u001b[33m" * ">>> [AUTO-FALLBACK] VRAM limit reached for GMG (Req: $(round(req_gb,digits=2)) GB vs Limit: $(round(free_gb, digits=2)) GB)." * "\u001b[0m")
                println("\u001b[33m" * ">>> [AUTO-FALLBACK] Switching to JACOBI and enabling PRUNING to save memory." * "\u001b[0m\n")
                
                precond_type = "jacobi"
                config["solver_parameters"]["preconditioner"] = "jacobi" 
                prune_voids = true 
            end
        else
            
            if prune_voids
                 if iter_current < 3 && !is_huge_model
                     prune_voids = false
                     println("   [Solver] Pruning skipped (Early Iteration protection).")
                 elseif iter_current < 3 && is_huge_model
                     println("   [Solver] Pruning FORCED (Huge Model Protection).")
                 end
            end
        end
    end

    
    active_system = nothing 
    solve_nodes = nodes
    solve_elements = elements
    solve_bc = bc_indicator
    solve_F = F
    solve_density = density
    solve_u_guess = u_prev

    if prune_voids && !isempty(density)
        prune_threshold = min_stiffness_threshold * 1.01f0 
        nElem_total = size(elements, 1)
        nActive = count(d -> d > prune_threshold, density)
           
        if nActive < (nElem_total * 0.99)
            active_system = MeshPruner.prune_system(nodes, elements, density, prune_threshold, bc_indicator, F)
              
            solve_nodes = active_system.nodes
            solve_elements = active_system.elements
            solve_bc = active_system.bc_indicator
            solve_F = active_system.F
            solve_density = active_system.density
            
            if !isempty(u_prev) && length(u_prev) == length(F)
                nActiveNodes = length(active_system.new_to_old_node_map)
                solve_u_guess = zeros(eltype(u_prev), nActiveNodes * 3)
                
                for (new_idx, old_idx) in enumerate(active_system.new_to_old_node_map)
                    base_old = 3 * (old_idx - 1)
                    base_new = 3 * (new_idx - 1)
                    solve_u_guess[base_new+1] = u_prev[base_old+1]
                    solve_u_guess[base_new+2] = u_prev[base_old+2]
                    solve_u_guess[base_new+3] = u_prev[base_old+3]
                end
            end
        else
            solve_u_guess = u_prev
        end
    else
        solve_u_guess = u_prev
    end

    use_precond = true 
      
    U_solved_tuple = if solver_type == :direct 
        solve_system_direct(solve_nodes, solve_elements, Float32(E), Float32(nu), solve_bc, solve_F; 
                            density=solve_density, 
                            shift_factor=shift_factor, 
                            min_stiffness_threshold=min_stiffness_threshold) 
                             
    elseif solver_type == :gpu 
        gpu_method = Symbol(lowercase(get(solver_params, "gpu_method", "krylov"))) 
        krylov_solver = Symbol(lowercase(get(solver_params, "krylov_solver", "cg"))) 
 
        solve_system_iterative(solve_nodes, solve_elements, E, nu, solve_bc, solve_F; 
                             solver_type=:gpu, max_iter=max_iter, tol=target_tol, 
                             density=solve_density, 
                             use_precond=use_precond,  
                             gpu_method=gpu_method, krylov_solver=krylov_solver, 
                             shift_factor=shift_factor, 
                             min_stiffness_threshold=min_stiffness_threshold,
                             u_guess=solve_u_guess, 
                             config=config) 
                             
    else    
        solve_system_iterative(solve_nodes, solve_elements, E, nu, solve_bc, solve_F; 
                             solver_type=:matrix_free, max_iter=max_iter, tol=target_tol, 
                             use_precond=use_precond, 
                             density=solve_density, 
                             shift_factor=shift_factor, 
                             min_stiffness_threshold=min_stiffness_threshold, 
                             config=config) 
    end 
 
    U_solved_vec = U_solved_tuple[1]
    res_val = U_solved_tuple[2]
    prec_str = U_solved_tuple[3]

    if active_system !== nothing
        U_full = MeshPruner.reconstruct_full_solution(U_solved_vec, active_system.new_to_old_node_map, size(nodes, 1))
        return (U_full, res_val, prec_str)
    else
        return U_solved_tuple
    end
end 
 
end
"// # FILE: .\src\Utils\Diagnostics.jl";


module Diagnostics

using CUDA
using Printf
using Dates
using JSON

export log_status, check_memory, init_log_file, write_iteration_log, write_crash_log
export print_banner, print_info, print_warn, print_error, print_success, print_substep
export log_memory_snapshot, get_hardware_info, log_full_config, config_to_string

const C_RESET   = "\u001b[0m"
const C_BOLD    = "\u001b[1m"
const C_RED     = "\u001b[31m"
const C_GREEN   = "\u001b[32m"
const C_YELLOW  = "\u001b[33m"
const C_BLUE    = "\u001b[34m"
const C_MAGENTA = "\u001b[35m"
const C_CYAN    = "\u001b[36m"
const C_WHITE   = "\u001b[37m"

const LOG_HEADER = """
| Iter |  Mesh Size  | Total El | Active El |  Radius  |  Cutoff  | Compliance | Strain Energy | Avg L1 Stress | Vol Frac | Delta Rho | Refine? | Residual | Preconditioner | Iter Time | Wall Time | VRAM |"""

function get_timestamp()
    return Dates.format(now(), "HH:MM:SS")
end

function print_banner(title::String; char="=", color=C_CYAN)
    width = 90
    println("\n" * color * char^width * C_RESET)
    println(color * C_BOLD * ">>> " * title * C_RESET)
    println(color * char^width * C_RESET)
    flush(stdout)
end

function print_info(msg::String)
    println(" " * C_CYAN * "[INFO] " * C_RESET * msg)
    flush(stdout)
end

function print_warn(msg::String)
    println(" " * C_YELLOW * C_BOLD * "[WARN] " * C_RESET * C_YELLOW * msg * C_RESET)
    flush(stdout)
end

function print_error(msg::String)
    println(" " * C_RED * C_BOLD * "[ERROR] " * C_RESET * C_RED * msg * C_RESET)
    flush(stdout)
end

function print_success(msg::String)
    println(" " * C_GREEN * C_BOLD * "[DONE] " * C_RESET * msg)
    flush(stdout)
end

function print_substep(msg::String)
    println("    " * C_MAGENTA * "-> " * C_RESET * msg)
    flush(stdout)
end

function log_status(msg::String)
    println(C_BOLD * "[$(get_timestamp())] " * C_RESET * msg)
    flush(stdout) 
end

function check_memory()
    if CUDA.functional()
        free_gpu, total_gpu = CUDA.available_memory(), CUDA.total_memory()
        return free_gpu
    end
    return 0
end

function get_hardware_info()
    cpu_threads = Threads.nthreads()
    sys_mem_free = Sys.free_memory() / 1024^3
    sys_mem_total = Sys.total_memory() / 1024^3
    
    gpu_info = "None"
    if CUDA.functional()
        dev = CUDA.device()
        name = CUDA.name(dev)
        free_gpu, total_gpu = CUDA.available_memory(), CUDA.total_memory()
        gpu_info = "$name | VRAM: $(round(free_gpu/1024^3, digits=2)) GB Free / $(round(total_gpu/1024^3, digits=2)) GB Total"
    end

    return """
    Hardware Profile:
      CPU Threads: $cpu_threads
      System RAM:  $(round(sys_mem_free, digits=2)) GB Free / $(round(sys_mem_total, digits=2)) GB Total
      GPU Device:  $gpu_info
      Julia Ver:   $VERSION
    """
end

function format_memory_str()
    if CUDA.functional()
        free_gpu, total_gpu = CUDA.available_memory(), CUDA.total_memory()
        used_gb = (total_gpu - free_gpu) / 1024^3
        total_gb = total_gpu / 1024^3
        pct = (used_gb / total_gb) * 100
        
        col = C_GREEN
        if pct > 80; col = C_YELLOW; end
        if pct > 95; col = C_RED; end
        
        return "$col" * @sprintf("%4.1fG", used_gb) * C_RESET
    end
    return " CPU"
end

function log_memory_snapshot(label::String)
    if CUDA.functional()
        free, total = CUDA.available_memory(), CUDA.total_memory()
        used = total - free
        return @sprintf("[%s] VRAM: %.2f GB Used / %.2f GB Total (%.1f%%)", 
            label, used/1024^3, total/1024^3, (used/total)*100)
    end
    return "[$label] VRAM: N/A"
end

function format_seconds_to_hms(seconds::Float64)
    total_seconds = round(Int, seconds)
    h = div(total_seconds, 3600)
    m = div(total_seconds % 3600, 60)
    s = total_seconds % 60
    return @sprintf("%02d:%02d:%02d", h, m, s)
end

function log_full_config(io::IO, config::Dict, indent::Int=0)
    prefix = " " ^ indent
    for (k, v) in config
        if isa(v, Dict)
            write(io, "$prefix$k:\n")
            log_full_config(io, v, indent + 2)
        elseif isa(v, Vector)
            write(io, "$prefix$k: [")
            join(io, v, ", ")
            write(io, "]\n")
        else
            write(io, "$prefix$k: $v\n")
        end
    end
end

function config_to_string(config::Dict)
    io = IOBuffer()
    log_full_config(io, config)
    return String(take!(io))
end

function init_log_file(filename::String, config::Dict)
    open(filename, "w") do io
        write(io, "================================================================================\n")
        write(io, "HEXA FEM TOPOLOGY OPTIMIZATION LOG\n")
        write(io, "Start Date: $(now())\n")
        write(io, "================================================================================\n\n")
        
        write(io, "--- HARDWARE INFO ---\n")
        write(io, get_hardware_info())
        write(io, "\n")

        write(io, "--- CONFIGURATION ECHO ---\n")
        log_full_config(io, config)
        write(io, "\n")
        
        write(io, "="^220 * "\n") 
        write(io, LOG_HEADER * "\n")
    end
    print_success("Log file initialized at: $filename")
end

function write_iteration_log(filename::String, iter, mesh_dims_str, nTotal, nActive, 
                             filter_R, threshold, compliance, strain_energy, avg_l1, 
                             vol_frac, delta_rho, refine_status, time_sec, 
                             lin_residual=0.0, precond_type="-")
    
    vram_str_clean = replace(format_memory_str(), r"\u001b\[[0-9;]*m" => "") 
    vram_str_colored = format_memory_str() 
    
    wall_time = Dates.format(now(), "HH:MM:SS")
    time_hms = format_seconds_to_hms(Float64(time_sec))
    
    
    f_R = Float64(filter_R)
    f_th = Float64(threshold)
    f_comp = Float64(compliance)
    f_se = Float64(strain_energy)
    f_l1 = Float64(avg_l1)
    f_vf = Float64(vol_frac)
    f_dr = Float64(delta_rho)
    f_res = Float64(lin_residual)
    f_total = Float64(nTotal)
    f_active = Float64(nActive)

    stat_col = C_RESET
    if refine_status == "Refined"; stat_col = C_CYAN; end
    if refine_status == "Annealing"; stat_col = C_MAGENTA; end
    if refine_status == "Skip"; stat_col = C_YELLOW; end

    line_console = @sprintf("| %s%4d%s | %11s | %8.2e | %9.2e | %8.4f | %8.3f | %10.2e | %13.2e | %13.2e | %8.3f | %7.2f%% | %s%7s%s | %8.2e | %-14s | %9s | %9s | %s |",
                    C_BOLD, iter, C_RESET, mesh_dims_str, f_total, f_active, f_R, f_th,
                    f_comp, f_se, f_l1, f_vf, 
                    f_dr*100, stat_col, refine_status, C_RESET, f_res, precond_type, time_hms, wall_time, vram_str_colored)

    line_file = @sprintf("| %4d | %11s | %8.2e | %9.2e | %8.4f | %8.3f | %10.2e | %13.2e | %13.2e | %8.3f | %7.2f%% | %7s | %8.2e | %-14s | %9s | %9s | %4s |",
                    iter, mesh_dims_str, f_total, f_active, f_R, f_th,
                    f_comp, f_se, f_l1, f_vf, 
                    f_dr*100, refine_status, f_res, precond_type, time_hms, wall_time, vram_str_clean)
    
    try
        open(filename, "a") do io
            println(io, line_file)
        end
    catch e
        println(C_RED * "[LOG ERROR] Could not write to log file." * C_RESET)
    end
    
    if iter == 1 || iter % 10 == 0 || refine_status != "Nominal"
        println("\n" * C_BOLD * LOG_HEADER * C_RESET)
    end
    println(line_console)
    flush(stdout)
end

function write_crash_log(filename, stage, err, stack, iter, config, density_sample)
    try
        open(filename, "a") do io
            write(io, "\n" * "="^80 * "\n")
            write(io, "CRASH REPORT [$(Dates.now())]\n")
            write(io, "="^80 * "\n")
            write(io, "Stage: $stage\n")
            write(io, "Iteration: $iter\n")
            write(io, "Error: $err\n")
            write(io, "\nStacktrace:\n")
            showerror(io, err, stack)
            write(io, "\n\nSystem State:\n")
            write(io, get_hardware_info())
            write(io, "="^80 * "\n")
        end
        print_warn("Detailed crash log written to: $filename")
    catch e
        print_error("Could not write crash log: $e")
    end
end

end
"// # FILE: .\src\Utils\Helpers.jl";
// 
module Helpers 

using CUDA 
using Printf

export expand_element_indices, nodes_from_location, parse_location_component 
export calculate_element_distribution, has_enough_gpu_memory, clear_gpu_memory, get_max_feasible_elements
export enforce_gpu_memory_safety, log_gpu_state, is_gmg_feasible_on_gpu, cleanup_memory

"""
    cleanup_memory()

Aggressively reclaims GPU and System memory. 
Should be called before large allocations.
"""
function cleanup_memory()
    GC.gc()
    if CUDA.functional()
        CUDA.reclaim()
    end
end

function expand_element_indices(elem_inds, dims) 
    nElem_x = dims[1] - 1 
    nElem_y = dims[2] - 1 
    nElem_z = dims[3] - 1 
    inds = Vector{Vector{Int}}() 
    for d in 1:3 
        if (typeof(elem_inds[d]) == String && elem_inds[d] == ":") 
            if d == 1 
                push!(inds, collect(1:nElem_x)) 
            elseif d == 2 
                push!(inds, collect(1:nElem_y)) 
            elseif d == 3 
                push!(inds, collect(1:nElem_z)) 
            end 
        else 
            push!(inds, [Int(elem_inds[d])]) 
        end 
    end 
    result = Int[] 
    for i in inds[1], j in inds[2], k in inds[3] 
        eidx = i + (j-1)*nElem_x + (k-1)*nElem_x*nElem_y 
        push!(result, eidx) 
    end 
    return result 
end 

function nodes_from_location(loc::Vector, dims) 
    nNodes_x, nNodes_y, nNodes_z = dims 
    ix = parse_location_component(loc[1], nNodes_x) 
    iy = parse_location_component(loc[2], nNodes_y) 
    iz = parse_location_component(loc[3], nNodes_z) 
    nodes = Int[] 
    for k in iz, j in iy, i in ix 
        node = i + (j-1)*nNodes_x + (k-1)*nNodes_x*nNodes_y 
        push!(nodes, node) 
    end 
    return nodes 
end 

function parse_location_component(val, nNodes::Int) 
    if val == ":" 
        return collect(1:nNodes) 
    elseif isa(val, String) && endswith(val, "%") 
        perc = parse(Float64, replace(val, "%"=>"")) / 100.0 
        idx = round(Int, 1 + perc*(nNodes-1)) 
        return [idx] 
    elseif isa(val, Number) 
        if 0.0 <= val <= 1.0 
            idx = round(Int, 1 + val*(nNodes-1)) 
            return [idx] 
        else 
            idx = clamp(round(Int, val), 1, nNodes) 
            return [idx] 
        end 
    else 
        error("Invalid location component: $val") 
    end 
end 

function clear_gpu_memory() 
    if !CUDA.functional() 
        return (0, 0) 
    end 
    GC.gc() 
    CUDA.reclaim() 

    final_free, total = CUDA.available_memory(), CUDA.total_memory() 
    return (final_free, total) 
end 

function log_gpu_state(label::String)
    if CUDA.functional()
        free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory()
        used_mem = total_mem - free_mem
        @printf("   [GPU STATE] %-25s | Used: %6.2f GB | Free: %6.2f GB\n", 
                label, used_mem/1024^3, free_mem/1024^3)
        flush(stdout)
    end
end

"""
    estimate_bytes_per_element(matrix_free::Bool=true)

Revised to account for IMPLICIT connectivity in GMG mode.
"""
function estimate_bytes_per_element(matrix_free::Bool=true, use_double::Bool=false)
    prec_mult = use_double ? 2.0 : 1.0

    if matrix_free
        return 80.0 * prec_mult 
    else
        return 12000.0
    end
end

"""
    is_gmg_feasible_on_gpu(nElem::Int, use_double::Bool)

Updated to check the Machine Limits from config.
"""
function is_gmg_feasible_on_gpu(nElem::Int, use_double::Bool; config::Dict=Dict())
    if !CUDA.functional()
        return (false, 0.0, 0.0)
    end
    
    
    if haskey(config, "machine_limits")
        limits = config["machine_limits"]
        max_safe = get(limits, "MAX_GMG_ELEMENTS", 5_000_000)
        
        
        if use_double
            max_safe = div(max_safe, 2)
        end
        
        if nElem <= max_safe
             return (true, 0.0, 0.0) 
        else
             return (false, Float64(nElem), Float64(max_safe))
        end
    end

    # 2. Fallback Heuristic (If test didn't run)
    cleanup_memory()
    free_mem = Float64(CUDA.available_memory())
    
    prec_mult = use_double ? 2.0 : 1.0
    bytes_per_elem_total = 80.0 * prec_mult * 1.15
    required_mem = nElem * bytes_per_elem_total
    safety_buffer = 400 * 1024^2
    available_for_job = free_mem - safety_buffer
    
    required_gb = required_mem / 1024^3
    free_gb = free_mem / 1024^3
    
    return (required_mem < available_for_job, required_gb, free_gb)
end

function get_max_feasible_elements(matrix_free::Bool=true; safety_factor::Float64=0.95, bytes_per_elem::Int=0)
    if !CUDA.functional() 
        return 5_000_000 
    end 
      
    free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory() 
    if safety_factor == 0.95; safety_factor = 0.99; end 
    usable_mem = free_mem * safety_factor 
    bpe = (bytes_per_elem > 0) ? bytes_per_elem : estimate_bytes_per_element(matrix_free) 
    max_elems = floor(Int, usable_mem / bpe) 
    return max_elems
end
 
function estimate_gpu_memory_required(nNodes, nElem, matrix_free::Bool=true) 
    return nElem * estimate_bytes_per_element(matrix_free)
end
 
function has_enough_gpu_memory(nNodes, nElem, matrix_free::Bool=true) 
    if !CUDA.functional(); return false; end 
    try 
        free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory() 
        required_mem = estimate_gpu_memory_required(nNodes, nElem, matrix_free) 
        utilization_limit = 0.99 
        usable_mem = free_mem * utilization_limit 
        req_gb = required_mem / 1024^3 
        avail_gb = usable_mem / 1024^3

        if required_mem > usable_mem 
            @warn "GPU Memory Estimate:" 
            @printf("   Required:  %.2f GB\n", req_gb) 
            @printf("   Available: %.2f GB\n", avail_gb) 
            return true 
        end 
        return true 
    catch e 
        println("Error checking GPU memory: $e") 
        return true 
    end 
end 

function calculate_element_distribution(length_x, length_y, length_z, target_elem_count) 
    total_volume = length_x * length_y * length_z 
    k = cbrt(target_elem_count / total_volume) 
    nElem_x = max(1, round(Int, k * length_x)) 
    nElem_y = max(1, round(Int, k * length_y)) 
    nElem_z = max(1, round(Int, k * length_z)) 
    dx = length_x / nElem_x 
    dy = length_y / nElem_y 
    dz = length_z / nElem_z 
    actual_elem_count = nElem_x * nElem_y * nElem_z 
    return nElem_x, nElem_y, nElem_z, Float32(dx), Float32(dy), Float32(dz), actual_elem_count
end

function enforce_gpu_memory_safety(n_active_elem::Int, n_nodes::Int, use_double_precision::Bool, use_multigrid::Bool)
    if !CUDA.functional(); return; end
    cleanup_memory()
    free_mem = CUDA.available_memory()
    
    bytes_per = estimate_bytes_per_element(true, use_double_precision)
    
    if use_multigrid
        bytes_per *= 1.2
    end

    mem_est = n_active_elem * bytes_per
    
    req_gb = mem_est / 1024^3
    avail_gb = free_mem / 1024^3
    
    if mem_est > free_mem
        println("\n\u001b[31m>>> [MEMORY GUARD] VRAM DEFICIT DETECTED (Active: $(Base.format_bytes(n_active_elem)))")
        @printf("   Req: %.2f GB | Free: %.2f GB\n", req_gb, avail_gb)
        println("   [WARNING] Expect SEVERE slowdowns (PCIe swapping) or Crash.")
        flush(stdout)
    else
        @printf("   [Memory Guard] %.2f GB est / %.2f GB free. Safe.\n", req_gb, avail_gb)
    end
end
 
end
"// # FILE: .\src\Utils\Project.toml";
name = "HEXA_TopOpt"
uuid = "a1b2c3d4-e5f6-4a5b-9c8d-7e6f5g4h3i2j"
authors = ["User"]
version = "1.0.0"

[deps]
AbstractTrees = "1520ce14-60c1-5f80-bbc7-55ef81b5835c"
AlgebraicMultigrid = "2169fc97-5a83-5252-b627-83903c6c433c"
CSV = "336ed68f-0bac-5ca0-87d4-7b16caf5d00b"
CUDA = "052768ef-5323-5732-b1bb-66c8b64840ba"
DataFrames = "a93c6f00-e57d-5684-b7b6-d8193f3e46c0"
Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"
FFTW = "7a1cc6ca-52ef-59f5-83cd-3a7055c09341"
FilePathsBase = "48062228-2e41-5def-b9a4-89aafe57970f"
Gumbo = "708ec375-b3d6-5a57-a7ce-8257bf98657a"
HTTP = "cd3eb016-35fb-5094-929b-558a96fad6f3"
ImageFiltering = "6a3955dd-da59-5b1f-98d4-e7296123deb5"
IterativeSolvers = "42fd0dbc-a981-5370-80f2-aaf504508153"
JSON = "682c06a0-de6a-54ab-a142-c8b1cf79cde6"
Krylov = "ba0b0d4f-ebba-5204-a429-3ac8c609bfb7"
LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
LinearOperators = "5c8ed15e-5a4c-59e4-a42b-c7e8811fb125"
MarchingCubes = "299715c1-40a9-479a-aaf9-4a633d36f717"
MsgPack = "99f44e22-a591-53d1-9472-aa23ef4bd671"
OffsetArrays = "6fe1bfb0-de20-5000-8ca7-80f57d26f881"
Plots = "91a5bcdd-55d7-5caf-9e0b-520d859cae80"
Pluto = "c3e4b0f8-55cb-11ea-2926-15256bba5781"
PlutoUI = "7f904dfe-b85e-4ff6-b463-dae2292396a8"
Random = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"
SparseArrays = "2f01184e-e22b-5df5-ae63-d93ebab69eaf"
StaticArrays = "90137ffa-7385-5640-81b9-e52037218182"
Statistics = "10745b16-79ce-11e8-11f9-7d13ad32a3b2"
URIs = "5c2747f8-b7ea-4ff2-ba2e-563bfd36b1d4"
VortexLattice = "7a09bdf8-3785-11e9-0bdd-57d0ec69af3f"
WebSockets = "104b5d7c-a370-577a-8038-80a2059c5097"
YAML = "ddb6d928-2868-570f-bddf-ab3f9cf99eb6"

[compat]
julia = "1.9"
AbstractTrees = "=0.4.5"
AlgebraicMultigrid = "=1.1.0"
CSV = "=0.10.15"
CUDA = "=5.9.4"
DataFrames = "=1.8.1"
Dates = "=1.11.0"
FFTW = "=1.10.0"
FilePathsBase = "=0.9.24"
Gumbo = "=0.8.3"
HTTP = "=1.10.19"
ImageFiltering = "=0.7.12"
IterativeSolvers = "=0.9.4"
JSON = "=1.3.0"
Krylov = "=0.10.3"
LinearAlgebra = "=1.11.0"
LinearOperators = "=2.11.0"
MarchingCubes = "=0.1.11"
MsgPack = "=1.2.1"
OffsetArrays = "=1.17.0"
Plots = "=1.41.2"
Pluto = "=0.20.21"
PlutoUI = "=0.7.75"
Random = "=1.11.0"
SparseArrays = "=1.11.0"
StaticArrays = "=1.9.15"
Statistics = "=1.11.1"
URIs = "=1.6.1"
VortexLattice = "=0.2.3"
WebSockets = "=1.6.0"
YAML = "=0.4.16"
"// # FILE: .\src\Utils\get_package_versions.jl";

import Pkg

const TARGET_FILE = joinpath(@__DIR__, "..", "..", "Project.toml") # Adjusted path to root

println(">>> Generating Project.toml from current environment...")

deps = Pkg.dependencies()
sorted_deps = sort(collect(deps), by=x->x[2].name)

buffer = IOBuffer()

println(buffer, "name = \"HEXA_TopOpt\"")
println(buffer, "uuid = \"a1b2c3d4-e5f6-4a5b-9c8d-7e6f5g4h3i2j\"")
println(buffer, "authors = [\"User\"]")
println(buffer, "version = \"1.0.0\"")
println(buffer, "")

println(buffer, "[deps]")
for (uuid, pkg) in sorted_deps
    if pkg.is_direct_dep
        println(buffer, "$(pkg.name) = \"$uuid\"")
    end
end
println(buffer, "")

println(buffer, "[compat]")

println(buffer, "julia = \"1.6\"") 

for (uuid, pkg) in sorted_deps
    if pkg.is_direct_dep
        if pkg.version !== nothing
            # FIX: Removed the "=" sign. 
            # "$(pkg.version)" implies semver compatibility (e.g., "1.2.3" allows "1.2.4" and "1.9.0")
            println(buffer, "$(pkg.name) = \"$(pkg.version)\"")
        else
            println(buffer, "# Warning: Could not detect version for $(pkg.name)")
        end
    end
end

new_content = String(take!(buffer))

if isfile(TARGET_FILE)
    mv(TARGET_FILE, TARGET_FILE * ".bak", force=true)
    println(">>> Existing Project.toml backed up to Project.toml.bak")
end

open(TARGET_FILE, "w") do io
    write(io, new_content)
end

println("-"^60)
println(">>> SUCCESS: Project.toml has been written successfully.")
println(">>> Location: $TARGET_FILE")
println("-"^60)
